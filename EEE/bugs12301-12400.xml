<?xml version="1.0" encoding="UTF-8"?>
<infozilla-output>
  <Bug>
    <BugId amount="12301" />
    <CreationDate amount="2002-03-26 12:18:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P4" />
    <bug_severity amount="enhancement" />
    <Summery>default keyword expansion mode</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>It would be nice to be able to choose the default keyword expansion mode (text/binary) for files with unknown content rather than using binary.
For files with unknown content, binary is the safe choice, otherwise you risk 
bogus EOL conversion on, say, your gifs.

The way it works now is the safest for people.
Yes but there are very few binary files that are to be managed by cvs (gif, jpeg, jar ... ?) compared to the text files (java, c, h, cpp, sh, html, css, js, xml, jsp, pm, pl, ......)

cvs is supposed to manage source files which are (almost) always text files.

And, by the way : there is a native mechanism in cvs (called cvswrappers) in order to handle binary files.

See also the discussion in eclipse.tools with subject "proposals for improving Team2.0"

Even if you think that binary is the safest for people, it would be great to make it an option for people that do not think so.


*** Bug 12409 has been marked as a duplicate of this bug. ***
Actually, a 'treat unknown as text' option would make things worse: people will 
get burned because they will not have thought to add the binary ones into the 
known file types preference.  That is, adding that option means the text/bin 
preferences list must contain the 'opposite' set of file patterns than it does.

- We have a larger audience than typical CVS and thus try to make the 
product 'safer'.  Working "the same way as CVS in all ways" is not our goal 
(CVS has known horrendous usability problems).  

- Eventually we expect to use mime types or something more intelligent

- While the total set of file types that people will author will be text, for a 
given person the set is not large and the text/bin preferences are not hard to 
keep up to date

- We've also been discussing some way for people to share the text/bin 
preferences, and discussed prompting for unknown file types</WithStack>
    <WithOutStack>It would be nice to be able to choose the default keyword expansion mode (text/binary) for files with unknown content rather than using binary.
For files with unknown content, binary is the safe choice, otherwise you risk 
bogus EOL conversion on, say, your gifs.

The way it works now is the safest for people.
Yes but there are very few binary files that are to be managed by cvs (gif, jpeg, jar ... ?) compared to the text files (java, c, h, cpp, sh, html, css, js, xml, jsp, pm, pl, ......)

cvs is supposed to manage source files which are (almost) always text files.

And, by the way : there is a native mechanism in cvs (called cvswrappers) in order to handle binary files.

See also the discussion in eclipse.tools with subject "proposals for improving Team2.0"

Even if you think that binary is the safest for people, it would be great to make it an option for people that do not think so.


*** Bug 12409 has been marked as a duplicate of this bug. ***
Actually, a 'treat unknown as text' option would make things worse: people will 
get burned because they will not have thought to add the binary ones into the 
known file types preference.  That is, adding that option means the text/bin 
preferences list must contain the 'opposite' set of file patterns than it does.

- We have a larger audience than typical CVS and thus try to make the 
product 'safer'.  Working "the same way as CVS in all ways" is not our goal 
(CVS has known horrendous usability problems).  

- Eventually we expect to use mime types or something more intelligent

- While the total set of file types that people will author will be text, for a 
given person the set is not large and the text/bin preferences are not hard to 
keep up to date

- We've also been discussing some way for people to share the text/bin 
preferences, and discussed prompting for unknown file types</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12302" />
    <CreationDate amount="2002-03-26 12:29:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="User Assistance" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Text Analyzer need to be tied with index</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Help allows pluggin in analyzers, but search index needs to use the same 
analyzer for indexing and search.  For this reason search will not work 
correctly if a new Analyzer is added for the language for which index already 
exists.

Either the new analyzer should not be used for the existing index, or index 
should be recreated from scratch using the new Analyzer.
Fixed.</WithStack>
    <WithOutStack>Help allows pluggin in analyzers, but search index needs to use the same 
analyzer for indexing and search.  For this reason search will not work 
correctly if a new Analyzer is added for the language for which index already 
exists.

Either the new analyzer should not be used for the existing index, or index 
should be recreated from scratch using the new Analyzer.
Fixed.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12303" />
    <CreationDate amount="2002-03-26 12:40:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="Build" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Building a plugin where the workspace does not have all projects under the same folder</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Newsgroups: 
             eclipse.tools

I'm having a difficult time creating a build.xml through the PDE to get my
plugin jar file build. I have the project created outside the default
workspace hierarchy under Eclipse (to allow me to reinstall Eclipse without
harming my projects). I've tried modifying build.properties every way that I
can, but I still get the same message in the task window, after ant runs:

cannot find plugin: org.eclipse.swt

I included this as a dependecy in the Plugin Editor, but no luck, even after
having Eclipse update my classpaths for me.

I'm running the 20020321 stable build. Any advice?

Thanks,
bab
A workaround is to set the property plugin.path="url1, url2, url3" for the 
script.
It should be integrated between PDE and Ant (maybe setting local properties).

Fixed for build &gt;= 20020501. The pluginLocation task has been removed. Plugin
locations are now represented as file system paths and are relative to the
target plug-in.</WithStack>
    <WithOutStack>Newsgroups: 
             eclipse.tools

I'm having a difficult time creating a build.xml through the PDE to get my
plugin jar file build. I have the project created outside the default
workspace hierarchy under Eclipse (to allow me to reinstall Eclipse without
harming my projects). I've tried modifying build.properties every way that I
can, but I still get the same message in the task window, after ant runs:

cannot find plugin: org.eclipse.swt

I included this as a dependecy in the Plugin Editor, but no luck, even after
having Eclipse update my classpaths for me.

I'm running the 20020321 stable build. Any advice?

Thanks,
bab
A workaround is to set the property plugin.path="url1, url2, url3" for the 
script.
It should be integrated between PDE and Ant (maybe setting local properties).

Fixed for build &gt;= 20020501. The pluginLocation task has been removed. Plugin
locations are now represented as file system paths and are relative to the
target plug-in.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12304" />
    <CreationDate amount="2002-03-26 12:52:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Plugin debugging does not work when plugin is loaded in hosting IDE</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="3">
        <Lines>
          <Line>- Breakpoints are not hit.</Line>
          <Line>- Stepping seems to step through different code.</Line>
          <Line>- Changes to code do not work.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build 2002-03-21 (stable)

Developing a Perforce Team integration, we are experiencing the following 
problem with the above mentioned build:

- Breakpoints are not hit.
- Stepping seems to step through different code.
- Changes to code do not work.

We tried several settings in the launch configuration. It's currently 
configured to not load any external plugins but only loads those found in the 
workspace. Nevertheless, there is no differnece.

The only thing that helps is disabling the plugin in our development IDE. 
Originally, we had planned to self-host in the near future but we have to wait 
until this is fixed.
You are right, the fix is to disabled all external plug-ins. If you don't and 
you have duplicates in the workspace and in the external list, the wrong (old) 
plug-in may be loaded by the run-time workbench.

We are currently working on revising self-hosting so these things do not happen.
Fixed in 0328 build. External plug-ins that are masked by the workspace 'twins' 
are removed from the list of plug-ins sent to the run-time workbench.

Run-time workbench launcher now provides a button to examine the URLs of plug-
ins that will be sent to the run-time workbench. This list makes is easy to 
spot problems like this because you can see exactly what location has been used.</WithStack>
    <WithOutStack>Build 2002-03-21 (stable)

Developing a Perforce Team integration, we are experiencing the following 
problem with the above mentioned build:

- Breakpoints are not hit.
- Stepping seems to step through different code.
- Changes to code do not work.

We tried several settings in the launch configuration. It's currently 
configured to not load any external plugins but only loads those found in the 
workspace. Nevertheless, there is no differnece.

The only thing that helps is disabling the plugin in our development IDE. 
Originally, we had planned to self-host in the near future but we have to wait 
until this is fixed.
You are right, the fix is to disabled all external plug-ins. If you don't and 
you have duplicates in the workspace and in the external list, the wrong (old) 
plug-in may be loaded by the run-time workbench.

We are currently working on revising self-hosting so these things do not happen.
Fixed in 0328 build. External plug-ins that are masked by the workspace 'twins' 
are removed from the list of plug-ins sent to the run-time workbench.

Run-time workbench launcher now provides a button to examine the URLs of plug-
ins that will be sent to the run-time workbench. This list makes is easy to 
spot problems like this because you can see exactly what location has been used.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12305" />
    <CreationDate amount="2002-03-26 13:07:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Setting for open editors is ignored</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="CLOSED" />
    <resolution amount="WORKSFORME" />
    <WithStack>I set the value to 6 open editors. But i'm able to open 10 editors.
I use the browsing perspective and the java perspective in one window. 
It could be the debug perspective which seems to set the reuse value higher, as 
i worked a lot with debugging today, before i noticed this.
Tested in 2.0. Works for me.
Please reopen if this is still a problem.

Oh, you are right. This bug (without a build#; sorry) reflects a very old 
build. So I close it.</WithStack>
    <WithOutStack>I set the value to 6 open editors. But i'm able to open 10 editors.
I use the browsing perspective and the java perspective in one window. 
It could be the debug perspective which seems to set the reuse value higher, as 
i worked a lot with debugging today, before i noticed this.
Tested in 2.0. Works for me.
Please reopen if this is still a problem.

Oh, you are right. This bug (without a build#; sorry) reflects a very old 
build. So I close it.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12306" />
    <CreationDate amount="2002-03-26 13:08:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="IDE" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[IDE] Copy and Paste project fails</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="4">
        <Lines>
          <Line>1) You don't want the copy in the workspace</Line>
          <Line>2) You want it close to where the source project is located.</Line>
          <Line>So I think the default settings are correct.</Line>
          <Line>We need to disable finish until the destination is not the same as the source.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Select a project and choose Edit &gt; Copy. Then choose Edit &gt; Paste. You get a 
dialog with "Copy of &lt;project name&gt;". Press OK and you get an error dialog 
about location overlap with workspace.

The value placed in the "location" field is bogus (same as the project you 
copied from). We know that is an invalid value. We need to provide a better 
default value for that field or better yet, just default to using "use default 
location" instead.
This only happens if the project is not located in the workspace.
The assumption is
1) You don't want the copy in the workspace
2) You want it close to where the source project is located.
So I think the default settings are correct.
We need to disable finish until the destination is not the same as the source.

You can use IWorkspace.validateProjectLocation() to make sure the location 
doesn't overlap with another project.

Let's say the source project is called "Foo" and its location is c:\temp\Foo.  
Since the dialog suggests a new name of "Copy of Foo", it seems it would be 
consistent for the suggested (default) location to be "c:\temp\Copy of Foo".
Reassigning to Platform-UI-Inbox (I left IBM 18 months ago..)
should not change this before RC2, as there is no loss of data I'm reducing the severity.
When I try this with Eclipse 3.3, the dialog that pops up shows both the new name "Copy of P1" and the location that will be chosen if you don't update it. Since there's no requirement that there is any relationship between the old location and the old project name, it's not clear that we should attempt to guess a better location based on the new name.

Since the user can easily alter the location in the project copy dialog, and thus avoid the error dialog, I believe the current behavior is acceptable.</WithStack>
    <WithOutStack>Select a project and choose Edit &gt; Copy. Then choose Edit &gt; Paste. You get a 
dialog with "Copy of &lt;project name&gt;". Press OK and you get an error dialog 
about location overlap with workspace.

The value placed in the "location" field is bogus (same as the project you 
copied from). We know that is an invalid value. We need to provide a better 
default value for that field or better yet, just default to using "use default 
location" instead.
This only happens if the project is not located in the workspace.
The assumption is
1) You don't want the copy in the workspace
2) You want it close to where the source project is located.
So I think the default settings are correct.
We need to disable finish until the destination is not the same as the source.

You can use IWorkspace.validateProjectLocation() to make sure the location 
doesn't overlap with another project.

Let's say the source project is called "Foo" and its location is c:\temp\Foo.  
Since the dialog suggests a new name of "Copy of Foo", it seems it would be 
consistent for the suggested (default) location to be "c:\temp\Copy of Foo".
Reassigning to Platform-UI-Inbox (I left IBM 18 months ago..)
should not change this before RC2, as there is no loss of data I'm reducing the severity.
When I try this with Eclipse 3.3, the dialog that pops up shows both the new name "Copy of P1" and the location that will be chosen if you don't update it. Since there's no requirement that there is any relationship between the old location and the old project name, it's not clear that we should attempt to guess a better location based on the new name.

Since the user can easily alter the location in the project copy dialog, and thus avoid the error dialog, I believe the current behavior is acceptable.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12307" />
    <CreationDate amount="2002-03-26 14:02:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Update  (deprecated - use RT&gt;Equinox&gt;p2)" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>JarVerifier returning null result</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>20020321 M4, Win2K

JarVerifier is returning a null result if it sees a reference that is not a Jar 
reference. This is causing downstream NPEs. The verifier should never return a 
null result. It should always return something, even if it indicates that it was 
not able to do the verification.
One possible strategy is to create a JarContentReference using the passed in 
ContentReference (new JarContentReference(ref.getIdentifier(), ref.asFile())) 
and then try to verify. If this is not a jar, it will not have a manifest and 
the verification will fail. If the above code throws an exeption, verification 
fails. The end result is that we return a result indicating the file could not 
be verified and is not trusted.
Fixed, verify in next Integration Build
Wrong action
Default result code is no Not_Signed instead of Error
Features with no JarContentReference will return Not_Signed

Verify and close
verified</WithStack>
    <WithOutStack>20020321 M4, Win2K

JarVerifier is returning a null result if it sees a reference that is not a Jar 
reference. This is causing downstream NPEs. The verifier should never return a 
null result. It should always return something, even if it indicates that it was 
not able to do the verification.
One possible strategy is to create a JarContentReference using the passed in 
ContentReference (new JarContentReference(ref.getIdentifier(), ref.asFile())) 
and then try to verify. If this is not a jar, it will not have a manifest and 
the verification will fail. If the above code throws an exeption, verification 
fails. The end result is that we return a result indicating the file could not 
be verified and is not trusted.
Fixed, verify in next Integration Build
Wrong action
Default result code is no Not_Signed instead of Error
Features with no JarContentReference will return Not_Signed

Verify and close
verified</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12308" />
    <CreationDate amount="2002-03-26 14:05:00 -0500" />
    <DupId amount="11257" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Edit Template dialog doesn't populate Context field correctly</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Stable Build 20020321
In Preferences, Java, Templates, select a template whose Context is something 
other than 'java' ('javadoc' for example) and click Edit. The Edit Template 
dialog that is displayed always has the 'java' Context selected.


*** This bug has been marked as a duplicate of 11257 ***</WithStack>
    <WithOutStack>Stable Build 20020321
In Preferences, Java, Templates, select a template whose Context is something 
other than 'java' ('javadoc' for example) and click Edit. The Edit Template 
dialog that is displayed always has the 'java' Context selected.


*** This bug has been marked as a duplicate of 11257 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12309" />
    <CreationDate amount="2002-03-26 14:27:00 -0500" />
    <DupId amount="9374" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Surround try/catch fails in static block</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="class">
        <location start="183" end="292" />
        <code>public class foo {
  static Object bar;
  static {
     bar = new XXXX();  /// this throws an exception
  }
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>0321 stable Win32
The surround try/catch feature is failing with the following error:
Selection does not contain statements from a method body.

I have something like the following:

public class foo {
  static Object bar;
  static {
     bar = new XXXX();  /// this throws an exception
  }
}

When I select the above line, I get the reported error.


*** This bug has been marked as a duplicate of 9374 ***</WithStack>
    <WithOutStack>0321 stable Win32
The surround try/catch feature is failing with the following error:
Selection does not contain statements from a method body.

I have something like the following:

public class foo {
  static Object bar;
  static {
     bar = new XXXX();  /// this throws an exception
  }
}

When I select the above line, I get the reported error.


*** This bug has been marked as a duplicate of 9374 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12310" />
    <CreationDate amount="2002-03-26 14:39:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Need ability to determine if a breakpoint applies to a target</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="10">
        <Lines>
          <Line>(1) add API to IDebugTarget to determine if a breakpoint is applicable to a</Line>
          <Line>target (something like #accpets(IBreakpoint)).</Line>
          <Line>(2) Change the filter to use this acceptance test (rather than model ids).</Line>
          <Line>(3) when there is no selection in the debug view, all breakpoints should be</Line>
          <Line>shown</Line>
          <Line>Added API to core and implemented in java debugger. UI action/filter needs</Line>
          <Line>updating.</Line>
          <Line>Fixed in ShowSupportedBreakpointsAction.</Line>
          <Line>Please verify (Darin W)</Line>
          <Line>Verified</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>The PICL debug model allows breakpoints from one model to be used in other 
models. Our "filter breakpoints for selected target" button does not work in 
this case.

We should
(1) add API to IDebugTarget to determine if a breakpoint is applicable to a 
target (something like #accpets(IBreakpoint)). 
(2) Change the filter to use this acceptance test (rather than model ids).
(3) when there is no selection in the debug view, all breakpoints should be 
shown
Added API to core and implemented in java debugger. UI action/filter needs 
updating.
Fixed in ShowSupportedBreakpointsAction.
Please verify (Darin W)
Verified</WithStack>
    <WithOutStack>The PICL debug model allows breakpoints from one model to be used in other 
models. Our "filter breakpoints for selected target" button does not work in 
this case.

We should
(1) add API to IDebugTarget to determine if a breakpoint is applicable to a 
target (something like #accpets(IBreakpoint)). 
(2) Change the filter to use this acceptance test (rather than model ids).
(3) when there is no selection in the debug view, all breakpoints should be 
shown
Added API to core and implemented in java debugger. UI action/filter needs 
updating.
Fixed in ShowSupportedBreakpointsAction.
Please verify (Darin W)
Verified</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12311" />
    <CreationDate amount="2002-03-26 14:43:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>The filter settings aren't persisted between eclipse executions</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="10">
        <Lines>
          <Line>1. Open eclipse</Line>
          <Line>2. Add a filter to hide all the deprecate warnings.</Line>
          <Line>* all check boxes select on the tree</Line>
          <Line>* "on any resource" selected</Line>
          <Line>* "doesn't contains"</Line>
          <Line>* text = "deprecate"</Line>
          <Line>3. Restart eclipse</Line>
          <Line>4. The filter will not be there</Line>
          <Line>This is about the Task list moving to Platform UI</Line>
          <Line>This is a dup, but the scenario here is simpler than others.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>Scenario:
1. Open eclipse
2. Add a filter to hide all the deprecate warnings.
     * all check boxes select on the tree
     * "on any resource" selected
     * "doesn't contains"
     * text = "deprecate"
3. Restart eclipse
4. The filter will not be there
This is about the Task list moving to Platform UI
This is a dup, but the scenario here is simpler than others.

Could not reproduce with these steps. I think this is a dup of bug 6513.

Can you reproduce it without using other perspectives? I.e. start the 
workbench, change the filter, restart and have no filter without doing anything 
else like switching perspectives?
I recently updated my driver to the 020502 - integration build and the problem 
seems to be solved.  Just a quick comment, if I "open the workspace" I am 
working with a previous driver (the stable one for example), the settings are 
erased.
Please, Can you give a bit more details on your "quick comment"?
Is it related do this problem or is it something else?
If it is not related to this problem could you open another bug report?
Did you check the .log file to see if there was any exception logged?
The "quick note" is related to this problem.  I guess the old driver (020416) 
doesn't read the filter settings and problaby save an empty filter definition 
when it exits.  Btw, no errors were logged.
Can't reproduce this. Guess it was a dup of bug 6513.
Please reopen this report if you see this problem in new builds.</WithStack>
    <WithOutStack>Scenario:
1. Open eclipse
2. Add a filter to hide all the deprecate warnings.
     * all check boxes select on the tree
     * "on any resource" selected
     * "doesn't contains"
     * text = "deprecate"
3. Restart eclipse
4. The filter will not be there
This is about the Task list moving to Platform UI
This is a dup, but the scenario here is simpler than others.

Could not reproduce with these steps. I think this is a dup of bug 6513.

Can you reproduce it without using other perspectives? I.e. start the 
workbench, change the filter, restart and have no filter without doing anything 
else like switching perspectives?
I recently updated my driver to the 020502 - integration build and the problem 
seems to be solved.  Just a quick comment, if I "open the workspace" I am 
working with a previous driver (the stable one for example), the settings are 
erased.
Please, Can you give a bit more details on your "quick comment"?
Is it related do this problem or is it something else?
If it is not related to this problem could you open another bug report?
Did you check the .log file to see if there was any exception logged?
The "quick note" is related to this problem.  I guess the old driver (020416) 
doesn't read the filter settings and problaby save an empty filter definition 
when it exits.  Btw, no errors were logged.
Can't reproduce this. Guess it was a dup of bug 6513.
Please reopen this report if you see this problem in new builds.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12312" />
    <CreationDate amount="2002-03-26 14:48:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>The Ctrl+C, V and X doesn't work on Text in EditorPart</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>It is really simple to simulate this.  Create a dialog with a 
org.eclipse.swt.widgets.Text and try these keys combinations while running your 
dialog.  Everything should work.  Now do the same in an EditorPart (NOT a text 
editor!).
When running as an editor or view, these actions are defined by the Cut, Copy 
and Paste actions in the Edit menu.  These are global actions for which editors 
and views can hook handlers.
To do this, use editor.getSite().getActionBars().setGlobalActionHandler(...).
See org.eclipse.ui.IActionBars and IWorkbenchActionConstants.

For example, in your editor's createPartControl method, do:
   getSite().getActionBars().setGlobalActionHandler(
      IWorkbenchActionConstants.CUT, 
      myCutAction);

Your cut action can do whatever you want, including delegating to Text.cut.

See also org.eclipse.ui.actions.TextActionHandler, which may help you manage 
this delegation, particularly if you are navigating between different text 
fields.</WithStack>
    <WithOutStack>It is really simple to simulate this.  Create a dialog with a 
org.eclipse.swt.widgets.Text and try these keys combinations while running your 
dialog.  Everything should work.  Now do the same in an EditorPart (NOT a text 
editor!).
When running as an editor or view, these actions are defined by the Cut, Copy 
and Paste actions in the Edit menu.  These are global actions for which editors 
and views can hook handlers.
To do this, use editor.getSite().getActionBars().setGlobalActionHandler(...).
See org.eclipse.ui.IActionBars and IWorkbenchActionConstants.

For example, in your editor's createPartControl method, do:
   getSite().getActionBars().setGlobalActionHandler(
      IWorkbenchActionConstants.CUT, 
      myCutAction);

Your cut action can do whatever you want, including delegating to Text.cut.

See also org.eclipse.ui.actions.TextActionHandler, which may help you manage 
this delegation, particularly if you are navigating between different text 
fields.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12313" />
    <CreationDate amount="2002-03-26 14:57:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Strange behaviour when pressing Tab on text editor</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="3">
        <Lines>
          <Line>1. Open a text editor by opening an existing txt file</Line>
          <Line>2. Select PART of any line STARTING from the beginning of the line</Line>
          <Line>3. Press TAB</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Scenario:
1. Open a text editor by opening an existing txt file
2. Select PART of any line STARTING from the beginning of the line
3. Press TAB

Outcome:
The whole line will the shifted right.  Is is the correct behaviour?  Shouldn't 
it be replace the selected text with Tab leaving this behaviour only for full 
line selections?
I suspect it's working as coded. I don't know if this the intended behavior or 
not. Moving to UI for investigation.

If a selection contains line delimiters, all lines overlapping with the 
selection are shifted when pressing TAB. All other selections are replaced. 
Build 20020508.</WithStack>
    <WithOutStack>Scenario:
1. Open a text editor by opening an existing txt file
2. Select PART of any line STARTING from the beginning of the line
3. Press TAB

Outcome:
The whole line will the shifted right.  Is is the correct behaviour?  Shouldn't 
it be replace the selected text with Tab leaving this behaviour only for full 
line selections?
I suspect it's working as coded. I don't know if this the intended behavior or 
not. Moving to UI for investigation.

If a selection contains line delimiters, all lines overlapping with the 
selection are shifted when pressing TAB. All other selections are replaced. 
Build 20020508.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12314" />
    <CreationDate amount="2002-03-26 15:31:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>VM crash when step in String constructor</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="11">
      <source_code type="package">
        <location start="840" end="859" />
        <code>package debug.test;</code>
      </source_code>
      <source_code type="import">
        <location start="860" end="887" />
        <code>import javax.swing.JFrame;</code>
      </source_code>
      <source_code type="import">
        <location start="888" end="918" />
        <code>import javax.swing.JTextField;</code>
      </source_code>
      <source_code type="import">
        <location start="919" end="946" />
        <code>import java.awt.Container;</code>
      </source_code>
      <source_code type="import">
        <location start="947" end="973" />
        <code>import java.awt.Dimension;</code>
      </source_code>
      <source_code type="import">
        <location start="974" end="1001" />
        <code>import java.awt.FlowLayout;</code>
      </source_code>
      <source_code type="class">
        <location start="1003" end="1667" />
        <code>public class DebugStringTest extends JFrame {
	private JTextField testField;
	/**
	 * Constructor for DebugStringTest.
	 */
	public DebugStringTest() {
		testField = new JTextField();
		testField.setDocument(new DebugTestDocument());
		testField.setPreferredSize(new Dimension(150,50));
		Container content = getContentPane();
		content.setLayout((new FlowLayout(FlowLayout.LEFT)));
		content.add(testField);
	}

	/**
	 * Constructor for DebugStringTest.
	 * @param title
	 */
	public DebugStringTest(String title) {
		super(title);
	}

	public static void main(String[] args) {
		DebugStringTest test = new DebugStringTest();
		test.pack();
		test.show();
		
	}
}</code>
      </source_code>
      <source_code type="package">
        <location start="1730" end="1749" />
        <code>package debug.test;</code>
      </source_code>
      <source_code type="import">
        <location start="1750" end="1789" />
        <code>import javax.swing.text.PlainDocument;</code>
      </source_code>
      <source_code type="import">
        <location start="1790" end="1839" />
        <code>import javax.swing.text.AbstractDocument.Content;</code>
      </source_code>
      <source_code type="class">
        <location start="1841" end="2716" />
        <code>public class DebugTestDocument extends PlainDocument {
	/**
 * This method was created in VisualAge.
 * @param offs int
 * @param str java.lang.String
 * @param a AttributeSet
 * @exception javax.swing.text.BadLocationException The exception description.
 */
public void insertString( int offs, String str, javax.swing.text.AttributeSet 
a ) throws javax.swing.text.BadLocationException {
	if( str == null ) {
		return;
	}
	
	char[] upper = str.toCharArray();
	for( int i = 0; i &lt; upper.length; i++ ) {
		upper[i] = Character.toUpperCase( upper[i] );
	}
	super.insertString( offs, new String(upper), a);  //&lt;--- breakpoint 
here, then step into
	
}


	/**
	 * Constructor for DebugTestDocument.
	 */
	public DebugTestDocument() {
		super();
	}

	/**
	 * Constructor for DebugTestDocument.
	 * @param arg0
	 */
	protected DebugTestDocument(Content arg0) {
		super(arg0);
	}

}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Build 20020321 Stable
While trying to step into the String constructor, I receive an Application 
Error: The instruction at "0x504cd71f" referenced memory at "0x00000000". The 
memory could not be "read".  The error occurs in the VM being debugged, so 
Eclipse isn't crashing.

I am able to reproduce this problem and even have a simple example that 
displays the problem.  The problem occurs when debugging on the Sun jdk1.2.2 
fullversion:JDK-1.2.2_008

Here is the example code.  Run the DebugStringTest class with a breakpoint set 
in the insertString() method of the DebugTestDocument class.  When the frame is 
displayed, enter a character, step into while on the line marked in the 
source.  This will attempt to step into the String constructor.  This is where 
I get the error.

---------------------------------------------------
package debug.test;

import javax.swing.JFrame;
import javax.swing.JTextField;

import java.awt.Container;
import java.awt.Dimension;
import java.awt.FlowLayout;

public class DebugStringTest extends JFrame {
	private JTextField testField;
	/**
	 * Constructor for DebugStringTest.
	 */
	public DebugStringTest() {
		testField = new JTextField();
		testField.setDocument(new DebugTestDocument());
		testField.setPreferredSize(new Dimension(150,50));
		Container content = getContentPane();
		content.setLayout((new FlowLayout(FlowLayout.LEFT)));
		content.add(testField);
	}

	/**
	 * Constructor for DebugStringTest.
	 * @param title
	 */
	public DebugStringTest(String title) {
		super(title);
	}

	public static void main(String[] args) {
		DebugStringTest test = new DebugStringTest();
		test.pack();
		test.show();
		
	}
}


--------------------------------------------------------



package debug.test;

import javax.swing.text.PlainDocument;
import javax.swing.text.AbstractDocument.Content;

public class DebugTestDocument extends PlainDocument {
	/**
 * This method was created in VisualAge.
 * @param offs int
 * @param str java.lang.String
 * @param a AttributeSet
 * @exception javax.swing.text.BadLocationException The exception description.
 */
public void insertString( int offs, String str, javax.swing.text.AttributeSet 
a ) throws javax.swing.text.BadLocationException {
	if( str == null ) {
		return;
	}
	
	char[] upper = str.toCharArray();
	for( int i = 0; i &lt; upper.length; i++ ) {
		upper[i] = Character.toUpperCase( upper[i] );
	}
	super.insertString( offs, new String(upper), a);  //&lt;--- breakpoint 
here, then step into
	
}


	/**
	 * Constructor for DebugTestDocument.
	 */
	public DebugTestDocument() {
		super();
	}

	/**
	 * Constructor for DebugTestDocument.
	 * @param arg0
	 */
	protected DebugTestDocument(Content arg0) {
		super(arg0);
	}

}
Joe, I think you saw this before, but I could not find the bug report. I 
believe this is a VM bug, and if so, we cannot fix.
Yes, this is the same problem I had reported.  The bug was given to J9, and 
they actually fixed it in the class library (internal bugzilla).  The 
fundamental problem is the ordering of statements in the String constructor, in 
particular the order of setting the length and the content.  Given that the 
only way to fix this is make a change in the class library, this probably won't 
happen for Sun VMs.  Marking as WONTFIX.</WithStack>
    <WithOutStack>Build 20020321 Stable
While trying to step into the String constructor, I receive an Application 
Error: The instruction at "0x504cd71f" referenced memory at "0x00000000". The 
memory could not be "read".  The error occurs in the VM being debugged, so 
Eclipse isn't crashing.

I am able to reproduce this problem and even have a simple example that 
displays the problem.  The problem occurs when debugging on the Sun jdk1.2.2 
fullversion:JDK-1.2.2_008

Here is the example code.  Run the DebugStringTest class with a breakpoint set 
in the insertString() method of the DebugTestDocument class.  When the frame is 
displayed, enter a character, step into while on the line marked in the 
source.  This will attempt to step into the String constructor.  This is where 
I get the error.

---------------------------------------------------
package debug.test;

import javax.swing.JFrame;
import javax.swing.JTextField;

import java.awt.Container;
import java.awt.Dimension;
import java.awt.FlowLayout;

public class DebugStringTest extends JFrame {
	private JTextField testField;
	/**
	 * Constructor for DebugStringTest.
	 */
	public DebugStringTest() {
		testField = new JTextField();
		testField.setDocument(new DebugTestDocument());
		testField.setPreferredSize(new Dimension(150,50));
		Container content = getContentPane();
		content.setLayout((new FlowLayout(FlowLayout.LEFT)));
		content.add(testField);
	}

	/**
	 * Constructor for DebugStringTest.
	 * @param title
	 */
	public DebugStringTest(String title) {
		super(title);
	}

	public static void main(String[] args) {
		DebugStringTest test = new DebugStringTest();
		test.pack();
		test.show();
		
	}
}


--------------------------------------------------------



package debug.test;

import javax.swing.text.PlainDocument;
import javax.swing.text.AbstractDocument.Content;

public class DebugTestDocument extends PlainDocument {
	/**
 * This method was created in VisualAge.
 * @param offs int
 * @param str java.lang.String
 * @param a AttributeSet
 * @exception javax.swing.text.BadLocationException The exception description.
 */
public void insertString( int offs, String str, javax.swing.text.AttributeSet 
a ) throws javax.swing.text.BadLocationException {
	if( str == null ) {
		return;
	}
	
	char[] upper = str.toCharArray();
	for( int i = 0; i &lt; upper.length; i++ ) {
		upper[i] = Character.toUpperCase( upper[i] );
	}
	super.insertString( offs, new String(upper), a);  //&lt;--- breakpoint 
here, then step into
	
}


	/**
	 * Constructor for DebugTestDocument.
	 */
	public DebugTestDocument() {
		super();
	}

	/**
	 * Constructor for DebugTestDocument.
	 * @param arg0
	 */
	protected DebugTestDocument(Content arg0) {
		super(arg0);
	}

}
Joe, I think you saw this before, but I could not find the bug report. I 
believe this is a VM bug, and if so, we cannot fix.
Yes, this is the same problem I had reported.  The bug was given to J9, and 
they actually fixed it in the class library (internal bugzilla).  The 
fundamental problem is the ordering of statements in the String constructor, in 
particular the order of setting the length and the content.  Given that the 
only way to fix this is make a change in the class library, this probably won't 
happen for Sun VMs.  Marking as WONTFIX.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12315" />
    <CreationDate amount="2002-03-26 15:58:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>fireListeners called a huge number of times on startup by CVS decorator</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Referring to the image Darin S gave us for Bug 10903 when I started it up I 
discovered that fireListeners was called 677 times when the image was invoked. 

Turning on the decorator resulted in the same number of calls to fireListeners.

I tested the same thing with other decorators and fireListeners is not called 
at all so this is not generated by the framework.
Problem is that because we compute the decorators in a background thread we 
must fire the listeners to get desktop to pick up the new decorators we've just 
computed.

Discussed with Tod the issues surrounding it:

- we need a way of later giving the decorator to the desktop without firing the 
update event, especially since this causes all other decorators to recompute 
themselves needlessly.

- not being asked to decorate items which are not visible would help reduce 
work spent

We can do no better with the current API: computing of decorators is expensive 
and must be done in a background thread, but the current API is not ameanable 
to this threading.

Thus moving the PR to UI.
Supported added for multi element label updates and decoration of text and 
images.

The IBatchLabelDecorator (which extends ILabelDecorator) has been added that 
allows for Decoration of an Image and a Text in the same method invocation 
using the decorateTextAndImage method.

The LabelProviderChangedEvent can now accept an Array of Objects as its 
elements. The default handleLabelProviderChanged method in StructuredViewer now 
calls update(Object[],String[]) rather than update(Object,String[]). The 
previous getElement() API remains and now returns the first element in the list 
of elements if there is one (otherwise null as before).

Moving the PR back to VCM so that it can be closed when the new support is 
integrated.
Will move to new API in M6
Now use array of elements for event</WithStack>
    <WithOutStack>Referring to the image Darin S gave us for Bug 10903 when I started it up I 
discovered that fireListeners was called 677 times when the image was invoked. 

Turning on the decorator resulted in the same number of calls to fireListeners.

I tested the same thing with other decorators and fireListeners is not called 
at all so this is not generated by the framework.
Problem is that because we compute the decorators in a background thread we 
must fire the listeners to get desktop to pick up the new decorators we've just 
computed.

Discussed with Tod the issues surrounding it:

- we need a way of later giving the decorator to the desktop without firing the 
update event, especially since this causes all other decorators to recompute 
themselves needlessly.

- not being asked to decorate items which are not visible would help reduce 
work spent

We can do no better with the current API: computing of decorators is expensive 
and must be done in a background thread, but the current API is not ameanable 
to this threading.

Thus moving the PR to UI.
Supported added for multi element label updates and decoration of text and 
images.

The IBatchLabelDecorator (which extends ILabelDecorator) has been added that 
allows for Decoration of an Image and a Text in the same method invocation 
using the decorateTextAndImage method.

The LabelProviderChangedEvent can now accept an Array of Objects as its 
elements. The default handleLabelProviderChanged method in StructuredViewer now 
calls update(Object[],String[]) rather than update(Object,String[]). The 
previous getElement() API remains and now returns the first element in the list 
of elements if there is one (otherwise null as before).

Moving the PR back to VCM so that it can be closed when the new support is 
integrated.
Will move to new API in M6
Now use array of elements for event</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12316" />
    <CreationDate amount="2002-03-26 15:59:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Message (stack trace) silently written to console when trying to run small java example</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="3">
      <Enumeration lines="17">
        <Lines>
          <Line>(1) Getting the memento for the last launch pref was checking null</Line>
          <Line>instead of empty String.  This led to problem of an empty memento.</Line>
          <Line>(2) If the memento was invalid,</Line>
          <Line>we were getting the last launch from the DebugUIPlugin, but never using this value.</Line>
          <Line>(3) Do we</Line>
          <Line>need two mechanisms for tracking the last launch? The</Line>
          <Line>PREF_LAST_LAUNCH_CONFIGURATION_SELECTION and the DebugUIPlugin's fRecentLaunch field</Line>
          <Line>seem to be duplicating work.  Can we remove one or the other?</Line>
          <Line>Fixed (1) &amp; (2).</Line>
          <Line>Another issue:</Line>
          <Line>(4) How to delete config if it failed to parse correctly.  Because it didn't</Line>
          <Line>parse, we don't have an ILaunchConfiguration that we can just call delete() on.  We do have the</Line>
          <Line>memento, but if we make a File from this and delete, there's no notification so history, etc.</Line>
          <Line>doesn't get cleaned up.</Line>
          <Line>(3) If the fRecentLanuch field is just a cache of the preference, that is fine</Line>
          <Line>(although, we could just get this dyanamically). We need the preference for</Line>
          <Line>persistence accross workbench invocations.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="12">
        <Lines>
          <Line>(3) If the fRecentLanuch field is just a cache of the preference, that is fine</Line>
          <Line>(although, we could just get this dyanamically). We need the preference for</Line>
          <Line>persistence accross workbench invocations.</Line>
          <Line />
          <Line>(4) cleanup is not required, as long as we overwrite the invalid memento with</Line>
          <Line>new ones - i.e. the preference will be overwritten as the user makes more</Line>
          <Line>launches. The default config for a resource should be overwritten as the users</Line>
          <Line>make new configs for a resource.</Line>
          <Line>(3) BOTH the preference, and fRecentLaunch in DebugUIPlugin get persisted.  The preference</Line>
          <Line>through the usual preference persistence mechanism, and fRecentLaunch gets persisted via the</Line>
          <Line>history XML file.  Since they both get updated when a configuration is launched, it seems like one</Line>
          <Line>of them is redundant.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="11">
        <Lines>
          <Line>(3) BOTH the preference, and fRecentLaunch in DebugUIPlugin get persisted.  The preference</Line>
          <Line>through the usual preference persistence mechanism, and fRecentLaunch gets persisted via the</Line>
          <Line>history XML file.  Since they both get updated when a configuration is launched, it seems like one</Line>
          <Line>of them is redundant.</Line>
          <Line />
          <Line>(4) An invalid format config will have its memento overwritten as the</Line>
          <Line>last launch when another (validly formatted) config is launched.  But until then, F( generates an</Line>
          <Line>error.  And the memento could still be present in the Favorites and the Histories, so I think these</Line>
          <Line>would have to checked and cleaned up.</Line>
          <Line>(4) is not an issue after support for old launcher-style launching is removed.  The odds of having an</Line>
          <Line>invalidly formatted config XML will be very low.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>build 20020326

Fresh workspace. Create a Java project and a HelloWorld application. Click on 
the "running man" (not the arrow down, the real guy). Check the .log file and 
you get problems. It does not seem to prevent the user from doing anything.
Log is attached.
Created attachment 519
log file
The launch config dialog is trying to restore the last selection. It could be 
an old (different format memento), or we are trying to parse an empty string. 
Joe, can we update this code to delete the old memento if it is an invalid 
format?
*** Bug 12365 has been marked as a duplicate of this bug. ***
*** Bug 12185 has been marked as a duplicate of this bug. ***
Several problems here:
(1) Getting the memento for the last launch pref was checking null 
instead of empty String.  This led to problem of an empty memento.
(2) If the memento was invalid, 
we were getting the last launch from the DebugUIPlugin, but never using this value.
(3) Do we 
need two mechanisms for tracking the last launch? The 
PREF_LAST_LAUNCH_CONFIGURATION_SELECTION and the DebugUIPlugin's fRecentLaunch field 
seem to be duplicating work.  Can we remove one or the other?
Fixed (1) &amp; (2).
Another issue:
(4) How to delete config if it failed to parse correctly.  Because it didn't 
parse, we don't have an ILaunchConfiguration that we can just call delete() on.  We do have the 
memento, but if we make a File from this and delete, there's no notification so history, etc. 
doesn't get cleaned up.
(3) If the fRecentLanuch field is just a cache of the preference, that is fine 
(although, we could just get this dyanamically). We need the preference for 
persistence accross workbench invocations.

(4) cleanup is not required, as long as we overwrite the invalid memento with 
new ones - i.e. the preference will be overwritten as the user makes more 
launches. The default config for a resource should be overwritten as the users 
make new configs for a resource.
(3) BOTH the preference, and fRecentLaunch in DebugUIPlugin get persisted.  The preference 
through the usual preference persistence mechanism, and fRecentLaunch gets persisted via the 
history XML file.  Since they both get updated when a configuration is launched, it seems like one 
of them is redundant.

(4) An invalid format config will have its memento overwritten as the 
last launch when another (validly formatted) config is launched.  But until then, F( generates an 
error.  And the memento could still be present in the Favorites and the Histories, so I think these 
would have to checked and cleaned up.
(4) is not an issue after support for old launcher-style launching is removed.  The odds of having an 
invalidly formatted config XML will be very low.

(3) Defer until M6.  Not critical 
functionality-wise, really just a code-optimization.
(3) has already been taken care of in splitting out the launch config history stuff to 
LaunchConfigurationManager.  So all issues have been resolved.
Please verify.
Verified.</WithStack>
    <WithOutStack>build 20020326

Fresh workspace. Create a Java project and a HelloWorld application. Click on 
the "running man" (not the arrow down, the real guy). Check the .log file and 
you get problems. It does not seem to prevent the user from doing anything.
Log is attached.
Created attachment 519
log file
The launch config dialog is trying to restore the last selection. It could be 
an old (different format memento), or we are trying to parse an empty string. 
Joe, can we update this code to delete the old memento if it is an invalid 
format?
*** Bug 12365 has been marked as a duplicate of this bug. ***
*** Bug 12185 has been marked as a duplicate of this bug. ***
Several problems here:
(1) Getting the memento for the last launch pref was checking null 
instead of empty String.  This led to problem of an empty memento.
(2) If the memento was invalid, 
we were getting the last launch from the DebugUIPlugin, but never using this value.
(3) Do we 
need two mechanisms for tracking the last launch? The 
PREF_LAST_LAUNCH_CONFIGURATION_SELECTION and the DebugUIPlugin's fRecentLaunch field 
seem to be duplicating work.  Can we remove one or the other?
Fixed (1) &amp; (2).
Another issue:
(4) How to delete config if it failed to parse correctly.  Because it didn't 
parse, we don't have an ILaunchConfiguration that we can just call delete() on.  We do have the 
memento, but if we make a File from this and delete, there's no notification so history, etc. 
doesn't get cleaned up.
(3) If the fRecentLanuch field is just a cache of the preference, that is fine 
(although, we could just get this dyanamically). We need the preference for 
persistence accross workbench invocations.

(4) cleanup is not required, as long as we overwrite the invalid memento with 
new ones - i.e. the preference will be overwritten as the user makes more 
launches. The default config for a resource should be overwritten as the users 
make new configs for a resource.
(3) BOTH the preference, and fRecentLaunch in DebugUIPlugin get persisted.  The preference 
through the usual preference persistence mechanism, and fRecentLaunch gets persisted via the 
history XML file.  Since they both get updated when a configuration is launched, it seems like one 
of them is redundant.

(4) An invalid format config will have its memento overwritten as the 
last launch when another (validly formatted) config is launched.  But until then, F( generates an 
error.  And the memento could still be present in the Favorites and the Histories, so I think these 
would have to checked and cleaned up.
(4) is not an issue after support for old launcher-style launching is removed.  The odds of having an 
invalidly formatted config XML will be very low.

(3) Defer until M6.  Not critical 
functionality-wise, really just a code-optimization.
(3) has already been taken care of in splitting out the launch config history stuff to 
LaunchConfigurationManager.  So all issues have been resolved.
Please verify.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12317" />
    <CreationDate amount="2002-03-26 16:13:00 -0500" />
    <DupId amount="" />
    <classification amount="Tools" />
    <Product amount="CDT" />
    <component amount="cdt-core" />
    <Version amount="1.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>shutdown eclipse after closing remote project</Summery>
    <Patches amount="0" />
    <Stacktraces amount="2">
      <Stacktrace timestamp="1437330633933">
        <Exception>java.io.IOException</Exception>
        <Reason>Connection reset by peer</Reason>
        <Frames>
          <Frame depth="0">java.net.SocketOutputStream.socketWrite(Native Method)</Frame>
          <Frame depth="1">java.net.SocketOutputStream.write(SocketOutputStream.java(CompiledCode))</Frame>
          <Frame depth="2">java.io.OutputStreamWriter.write(OutputStreamWriter.java(CompiledCode))</Frame>
          <Frame depth="3">java.io.BufferedWriter.flushBuffer(BufferedWriter.java(CompiledCode))</Frame>
          <Frame depth="4">java.io.BufferedWriter.write(BufferedWriter.java(Compiled Code))</Frame>
          <Frame depth="5">org.eclipse.cdt.dstore.core.util.XMLgenerator.flushData(XMLgenerator.java:104)</Frame>
          <Frame depth="6">org.eclipse.cdt.dstore.core.util.XMLgenerator.endTag(XMLgenerator.java(CompiledCode))</Frame>
          <Frame depth="7">org.eclipse.cdt.dstore.core.util.XMLgenerator.endTag(XMLgenerator.java(CompiledCode))</Frame>
          <Frame depth="8">org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(CompiledCode))</Frame>
          <Frame depth="9">org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(CompiledCode))</Frame>
          <Frame depth="10">org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(CompiledCode))</Frame>
          <Frame depth="11">org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(CompiledCode))</Frame>
          <Frame depth="12">org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(CompiledCode))</Frame>
          <Frame depth="13">org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(CompiledCode))</Frame>
          <Frame depth="14">org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java:470)</Frame>
          <Frame depth="15">org.eclipse.cdt.dstore.core.util.Sender.sendDocument(Sender.java:110)</Frame>
          <Frame depth="16">org.eclipse.cdt.dstore.core.server.ServerUpdateHandler.sendUpdates(ServerUpdateHandler.java(CompiledCode))</Frame>
          <Frame depth="17">org.eclipse.cdt.dstore.core.model.UpdateHandler.handle(UpdateHandler.java:29)</Frame>
          <Frame depth="18">org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java:89)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437330633933">
        <Exception>java.io.IOException</Exception>
        <Reason>Connection reset by peer
java.lang.NullPointerException</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.cdt.dstore.core.util.XMLgenerator.flushData(XMLgenerator.java:104)</Frame>
          <Frame depth="1">org.eclipse.cdt.dstore.core.util.Sender.sendDocument(Sender.java:111)</Frame>
          <Frame depth="2">org.eclipse.cdt.dstore.core.server.ServerUpdateHandler.removeSenderWith(ServerUpdateHandler.java:120)</Frame>
          <Frame depth="3">org.eclipse.cdt.dstore.core.server.ConnectionEstablisher.finished(ConnectionEstablisher.java:116)</Frame>
          <Frame depth="4">org.eclipse.cdt.dstore.core.server.ServerReceiver.handleDocument(ServerReceiver.java:39)</Frame>
          <Frame depth="5">org.eclipse.cdt.dstore.core.util.Receiver.handleInput(Receiver.java:90)</Frame>
          <Frame depth="6">org.eclipse.cdt.dstore.core.util.Receiver.run(Receiver.java:64)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Create a remote project(e.g. jikes) and parse it. Then, close the project and
shutdown eclipse. A stacktrace is printed in the server. Even though the server
is restarted successfully (and the client can connect), parsing again would
never finish.Need to kill "server.linux" and restart it again.
----------------Here is the stacktrace--------------
Server Started Successfully
4030
Server running on: hack
java.io.IOException: Connection reset by peer
        at java.net.SocketOutputStream.socketWrite(Native Method)
        at java.net.SocketOutputStream.write(SocketOutputStream.java(Compiled
Code))
        at java.io.OutputStreamWriter.write(OutputStreamWriter.java(Compiled
Code))
        at java.io.BufferedWriter.flushBuffer(BufferedWriter.java(Compiled
Code))
        at java.io.BufferedWriter.write(BufferedWriter.java(Compiled Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.flushData(XMLgenerator.java:104)
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.endTag(XMLgenerator.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.endTag(XMLgenerator.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.generate(XMLgenerator.java:470)
        at org.eclipse.cdt.dstore.core.util.Sender.sendDocument(Sender.java:110)
        at
org.eclipse.cdt.dstore.core.server.ServerUpdateHandler.sendUpdates(ServerUpdateHandler.java(Compiled
Code))
        at
org.eclipse.cdt.dstore.core.model.UpdateHandler.handle(UpdateHandler.java:29)
        at org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java:89)
java.io.IOException: Connection reset by peer
java.lang.NullPointerException
        at
org.eclipse.cdt.dstore.core.util.XMLgenerator.flushData(XMLgenerator.java:104)
        at org.eclipse.cdt.dstore.core.util.Sender.sendDocument(Sender.java:111)
        at
org.eclipse.cdt.dstore.core.server.ServerUpdateHandler.removeSenderWith(ServerUpdateHandler.java:120)
        at
org.eclipse.cdt.dstore.core.server.ConnectionEstablisher.finished(ConnectionEstablisher.java:116)
        at
org.eclipse.cdt.dstore.core.server.ServerReceiver.handleDocument(ServerReceiver.java:39)
        at
org.eclipse.cdt.dstore.core.util.Receiver.handleInput(Receiver.java:90)
        at org.eclipse.cdt.dstore.core.util.Receiver.run(Receiver.java:64)
java.lang.NullPointerException
java.lang.OutOfMemoryError
Server Finished
Server Started Successfully
4030
Server running on: hack
Does this happen if you don't parse it?  Does it happen if the project is 
smaller than jikes?  Do you shutdown during parse activity or after?
&gt;&gt;Does this happen if you don't parse it?  
No. This does not happen if the project is not parsed

&gt;&gt;Does it happen if the project is smaller than jikes?  
It does not happen with small projects(e.g. the sample payroll in
org.eclipse.cdt.cpp.docs.user/sample/payroll)

&gt;&gt;Do you shutdown during parse activity or after?
I close the project once I see that the CPU usage in the server is close to
zero(I assume that the parse has finished). But after closing the project,
server does not display "Server Finished" and CPU usage in the client goes up to
100%. Sthutting down eclipse under these conditions would cause the exceptions.
However, If I wait long enough after closing the project(~1 minute), the CPU
usage in the client finally goes down to zero and the "Server Finished" message
is displayed in the server;then, shutting down eclipse would not cause the
exceptions. 
Okay, it sounds to me like we're still processing the parse, but instead of the 
parser doing stuff, the client is receiving a lot of information (XML) across 
the wire while we try to shutdown.  We tell the client to end and it severs it's 
connection before the server has had a chance to finish it's send.  I thought 
that the client waits for an exit ACK before severing the connection, but 
apparently that isn't the case.      
We handle this exception and print the stack trace that you see below.  The 
handling is used for detecting when a connection is lost so that we gracefully 
terminate.  Although the XML generator didn't expect to get here in this 
scenario, this should not cause any problems.   I've removed the print so that 
this doesn't give the appearance of a drastic problem.</WithStack>
    <WithOutStack>Create a remote project(e.g. jikes) and parse it. Then, close the project and
shutdown eclipse. A stacktrace is printed in the server. Even though the server
is restarted successfully (and the client can connect), parsing again would
never finish.Need to kill "server.linux" and restart it again.
----------------Here is the stacktrace--------------
Server Started Successfully
4030
Server running on: hack

java.lang.NullPointerException
java.lang.OutOfMemoryError
Server Finished
Server Started Successfully
4030
Server running on: hack
Does this happen if you don't parse it?  Does it happen if the project is 
smaller than jikes?  Do you shutdown during parse activity or after?
&gt;&gt;Does this happen if you don't parse it?  
No. This does not happen if the project is not parsed

&gt;&gt;Does it happen if the project is smaller than jikes?  
It does not happen with small projects(e.g. the sample payroll in
org.eclipse.cdt.cpp.docs.user/sample/payroll)

&gt;&gt;Do you shutdown during parse activity or after?
I close the project once I see that the CPU usage in the server is close to
zero(I assume that the parse has finished). But after closing the project,
server does not display "Server Finished" and CPU usage in the client goes up to
100%. Sthutting down eclipse under these conditions would cause the exceptions.
However, If I wait long enough after closing the project(~1 minute), the CPU
usage in the client finally goes down to zero and the "Server Finished" message
is displayed in the server;then, shutting down eclipse would not cause the
exceptions. 
Okay, it sounds to me like we're still processing the parse, but instead of the 
parser doing stuff, the client is receiving a lot of information (XML) across 
the wire while we try to shutdown.  We tell the client to end and it severs it's 
connection before the server has had a chance to finish it's send.  I thought 
that the client waits for an exit ACK before severing the connection, but 
apparently that isn't the case.      
We handle this exception and print the stack trace that you see below.  The 
handling is used for detecting when a connection is lost so that we gracefully 
terminate.  Although the XML generator didn't expect to get here in this 
scenario, this should not cause any problems.   I've removed the print so that 
this doesn't give the appearance of a drastic problem.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12318" />
    <CreationDate amount="2002-03-26 16:22:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Delete key kills eclipse</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>build 20020326

Fresh workspace. Create a java project with some class. Use the "Show source 
of Selected element only". Select more than one line of code. Press "Delete" 
key.
Dialog "Internal Error, Exit Workspace?"
Created attachment 520
log file
This problem exists since the very beginning. It has become more obvious by the 
introduction of key binding support. Fixed in build &gt; 20020326.

Workaround for 20020326: Answer No in dialog. Use BS.</WithStack>
    <WithOutStack>build 20020326

Fresh workspace. Create a java project with some class. Use the "Show source 
of Selected element only". Select more than one line of code. Press "Delete" 
key.
Dialog "Internal Error, Exit Workspace?"
Created attachment 520
log file
This problem exists since the very beginning. It has become more obvious by the 
introduction of key binding support. Fixed in build &gt; 20020326.

Workaround for 20020326: Answer No in dialog. Use BS.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12319" />
    <CreationDate amount="2002-03-26 16:22:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Console: need to delineate which output from which action</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>The CVS console is difficult to interpret because you can't tell which actions 
resulted in which output.
Could you also delineate the debug output (e.g. cvs protocol debug option).
I am not clear on what you mean, JM.  CVS protocol debug information
always goes to System.out -- not the CVS console -- so that it is visible
from outside the debugging context.  There is nothing to delineate.

Added display of each CVS command that is executed.
Eg. cvs update foo

Much better, very nice.
Verified.</WithStack>
    <WithOutStack>The CVS console is difficult to interpret because you can't tell which actions 
resulted in which output.
Could you also delineate the debug output (e.g. cvs protocol debug option).
I am not clear on what you mean, JM.  CVS protocol debug information
always goes to System.out -- not the CVS console -- so that it is visible
from outside the debugging context.  There is nothing to delineate.

Added display of each CVS command that is executed.
Eg. cvs update foo

Much better, very nice.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12320" />
    <CreationDate amount="2002-03-26 16:24:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P1" />
    <bug_severity amount="normal" />
    <Summery>Some Viewers update label decorators very slowly</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>3 of the JDT viewers update labels very slowly when they get a 
labelProviderChanged event from the DecoratorManager.

using the large workbench provided for Bug 10903 the following ContentViewers 
took a large amount of time to process labelProviderChanged for a very simple 
decorator (I have one that appends the currentTimeMilliseconds to the label and 
does nothing to the image).

ProblemTreeViewer (sometimes upwards of 500 ms)
JavaOutlineViewer (around 200 ms)
MethodsViewer (around 200ms)

This can potentially cause a large delay in update due to the amount of updates 
being sent by the CVS decorator (see Bug 12315).
As of build &gt;20020328 we have changed the LabelChangedEvent such that it can 
now accept arrays of elements to update instead of always forcing a change to a 
single item. 

This may affect the ProblemTreeViewer as it does a preprocessing step before 
calling the default implementation in StructuredViewer. ProblemTreeViewer calls 
getElement() which will now return the first element in the list of elements 
for the change - this may no longer be a suffecient check.
adapted to new LabelChangedEvent API build &gt; 20020404
closing this bug</WithStack>
    <WithOutStack>3 of the JDT viewers update labels very slowly when they get a 
labelProviderChanged event from the DecoratorManager.

using the large workbench provided for Bug 10903 the following ContentViewers 
took a large amount of time to process labelProviderChanged for a very simple 
decorator (I have one that appends the currentTimeMilliseconds to the label and 
does nothing to the image).

ProblemTreeViewer (sometimes upwards of 500 ms)
JavaOutlineViewer (around 200 ms)
MethodsViewer (around 200ms)

This can potentially cause a large delay in update due to the amount of updates 
being sent by the CVS decorator (see Bug 12315).
As of build &gt;20020328 we have changed the LabelChangedEvent such that it can 
now accept arrays of elements to update instead of always forcing a change to a 
single item. 

This may affect the ProblemTreeViewer as it does a preprocessing step before 
calling the default implementation in StructuredViewer. ProblemTreeViewer calls 
getElement() which will now return the first element in the list of elements 
for the change - this may no longer be a suffecient check.
adapted to new LabelChangedEvent API build &gt; 20020404
closing this bug</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12321" />
    <CreationDate amount="2002-03-26 16:48:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Code formatter and comments</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="3">
      <source_code type="class">
        <location start="150" end="346" />
        <code>public class ttt {

	public static void main() {
		if (true)
			if (false)
				System.out.println("meuh");
			else
				System.out.println("coucou");
		else {
			System.out.println("bar");
		}
	}
}</code>
      </source_code>
      <source_code type="functioncall">
        <location start="415" end="445" />
        <code>System.out.println("meuh");</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="944" end="1017" />
        <code>if (clearNonBlockIndents &amp;&amp; (token != Scanner.TokenNameWHITESPACE)) {</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>The following code formats correctly. 
However if you add a comment at the end of the 6th line and then format the
code, the result is very strange.

public class ttt {

	public static void main() {
		if (true)
			if (false)
				System.out.println("meuh");
			else
				System.out.println("coucou");
		else {
			System.out.println("bar");
		}
	}
}

    PaScaL
The comment needs to be added at the end of the line : 
   System.out.println("meuh");
Will consider post 2.0
Reopening
Clearing resolution
The cause of the problem is that 'clearNonBlockIndents' is reset during the use 
of the comment token in the format method from CodeFormatter.

A solution is to exclude comment tokens from the condition that protect the 
removing of all indentations made by statements not followed by a block
except if the current token is ELSE, CATCH or if we are in a switch/case

The proposal is to update the line 365 in the version from eclipse 2.0.1
from
    if (clearNonBlockIndents &amp;&amp; (token != Scanner.TokenNameWHITESPACE)) {
to
    if (clearNonBlockIndents &amp;&amp; (token != Scanner.TokenNameWHITESPACE) 
	&amp;&amp; (token != TokenNameCOMMENT_BLOCK)
    	&amp;&amp; (token != TokenNameCOMMENT_JAVADOC)
        &amp;&amp; (token != TokenNameCOMMENT_LINE	)) {

We need to clear 2.1 bug reports that won't be addressed before 2.1. The new 
implementation is still in the works. Therefore we cannot include it for 2.1. 
Not enough testing and we need to polish the preferences. This will be address 
for 2.2 as stated in the JDT/Core plan.
Resurrecting for 3.0
Reopen for 3.0 consideration.
This is addressed in the new formatter.
Fixed and released in HEAD.
Regression test added.
Verified.</WithStack>
    <WithOutStack>The following code formats correctly. 
However if you add a comment at the end of the 6th line and then format the
code, the result is very strange.

public class ttt {

	public static void main() {
		if (true)
			if (false)
				System.out.println("meuh");
			else
				System.out.println("coucou");
		else {
			System.out.println("bar");
		}
	}
}

    PaScaL
The comment needs to be added at the end of the line : 
   System.out.println("meuh");
Will consider post 2.0
Reopening
Clearing resolution
The cause of the problem is that 'clearNonBlockIndents' is reset during the use 
of the comment token in the format method from CodeFormatter.

A solution is to exclude comment tokens from the condition that protect the 
removing of all indentations made by statements not followed by a block
except if the current token is ELSE, CATCH or if we are in a switch/case

The proposal is to update the line 365 in the version from eclipse 2.0.1
from
    if (clearNonBlockIndents &amp;&amp; (token != Scanner.TokenNameWHITESPACE)) {
to
    if (clearNonBlockIndents &amp;&amp; (token != Scanner.TokenNameWHITESPACE) 
	&amp;&amp; (token != TokenNameCOMMENT_BLOCK)
    	&amp;&amp; (token != TokenNameCOMMENT_JAVADOC)
        &amp;&amp; (token != TokenNameCOMMENT_LINE	)) {

We need to clear 2.1 bug reports that won't be addressed before 2.1. The new 
implementation is still in the works. Therefore we cannot include it for 2.1. 
Not enough testing and we need to polish the preferences. This will be address 
for 2.2 as stated in the JDT/Core plan.
Resurrecting for 3.0
Reopen for 3.0 consideration.
This is addressed in the new formatter.
Fixed and released in HEAD.
Regression test added.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12322" />
    <CreationDate amount="2002-03-26 16:52:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="1.0" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Eclipse should support changing a project directory</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="3">
      <Enumeration lines="9">
        <Lines>
          <Line>1. Create a WSWB project Disappear on a mapped drive X: (not the</Line>
          <Line>default location). I specified X:\TESTING\MYDIR.</Line>
          <Line>2. Create a HelloWorld class in Disappear.</Line>
          <Line>3. Exit WSWB.</Line>
          <Line>4. Delete the mapping for X:.</Line>
          <Line>5. Create a mapping for Y: to the same network drive.</Line>
          <Line>6. Start WSWB.</Line>
          <Line>7. You get a log file (see attachment)</Line>
          <Line>8. The project isn't there.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="13">
        <Lines>
          <Line>1. Start up WSWB.</Line>
          <Line>2. Find out what type of project Disappear is.</Line>
          <Line>3. Delete the project Disappear but DO NOT DELETE the contents of the directory.</Line>
          <Line>4. Create a new project Disappear (of the same type) specifying the new</Line>
          <Line>location.</Line>
          <Line>5. Refresh from Local.</Line>
          <Line>Created attachment 521</Line>
          <Line>Log file</Line>
          <Line>Changed from feature request to defect - it really shouldn't generate a .log</Line>
          <Line>when you start Eclipse.</Line>
          <Line>This would also happen in Linux with links/symlinks on the filesystem.</Line>
          <Line>The behaviour in 2.0 is now slightly different, but still not what you're asking</Line>
          <Line>for.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="3">
        <Lines>
          <Line>1. Create the mapping Y:</Line>
          <Line>2. Inside Eclipse, move the project location to the new mapping</Line>
          <Line>3. Delete the mapping X:</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>When I created a project, I specified it using a certain drive letter. Later,
that mapping was removed. The project is still available, however it's under the 
wrong drive letter. I'd like to be able to change the directory of the project 
from within the IDE.

Steps to Reproduce:
1. Create a WSWB project Disappear on a mapped drive X: (not the 
default location). I specified X:\TESTING\MYDIR.
2. Create a HelloWorld class in Disappear.
3. Exit WSWB.
4. Delete the mapping for X:.
5. Create a mapping for Y: to the same network drive.
6. Start WSWB.
7. You get a log file (see attachment)
8. The project isn't there.

The workaround we're using now is:

1. Start up WSWB.
2. Find out what type of project Disappear is.
3. Delete the project Disappear but DO NOT DELETE the contents of the directory.
4. Create a new project Disappear (of the same type) specifying the new 
location.
5. Refresh from Local.
Created attachment 521
Log file
Changed from feature request to defect - it really shouldn't generate a .log 
when you start Eclipse.
This would also happen in Linux with links/symlinks on the filesystem.
The behaviour in 2.0 is now slightly different, but still not what you're asking 
for.

On startup, if the content area for the project cannot be found, this is printed 
to the log file as an error, and the project is marked as closed.  It will not 
be possible to open, move, or otherwise manipulate the project until its 
content area is accessible.  Since the project description file is in the 
content area, this information is also not available, and this is treated as a 
serious problem.  It makes complete sense to treat this as an error (thus 
generating a log message), because part of the workspace content is now missing. 
There is no plan to change this behaviour.  

Recommended steps for changing the mapping are:

1. Create the mapping Y:
2. Inside Eclipse, move the project location to the new mapping
3. Delete the mapping X:

See John's comments above for the recommended approach.

Alternatively you can delete the project and create a new one with the same 
name with the new mapping.</WithStack>
    <WithOutStack>When I created a project, I specified it using a certain drive letter. Later,
that mapping was removed. The project is still available, however it's under the 
wrong drive letter. I'd like to be able to change the directory of the project 
from within the IDE.

Steps to Reproduce:
1. Create a WSWB project Disappear on a mapped drive X: (not the 
default location). I specified X:\TESTING\MYDIR.
2. Create a HelloWorld class in Disappear.
3. Exit WSWB.
4. Delete the mapping for X:.
5. Create a mapping for Y: to the same network drive.
6. Start WSWB.
7. You get a log file (see attachment)
8. The project isn't there.

The workaround we're using now is:

1. Start up WSWB.
2. Find out what type of project Disappear is.
3. Delete the project Disappear but DO NOT DELETE the contents of the directory.
4. Create a new project Disappear (of the same type) specifying the new 
location.
5. Refresh from Local.
Created attachment 521
Log file
Changed from feature request to defect - it really shouldn't generate a .log 
when you start Eclipse.
This would also happen in Linux with links/symlinks on the filesystem.
The behaviour in 2.0 is now slightly different, but still not what you're asking 
for.

On startup, if the content area for the project cannot be found, this is printed 
to the log file as an error, and the project is marked as closed.  It will not 
be possible to open, move, or otherwise manipulate the project until its 
content area is accessible.  Since the project description file is in the 
content area, this information is also not available, and this is treated as a 
serious problem.  It makes complete sense to treat this as an error (thus 
generating a log message), because part of the workspace content is now missing. 
There is no plan to change this behaviour.  

Recommended steps for changing the mapping are:

1. Create the mapping Y:
2. Inside Eclipse, move the project location to the new mapping
3. Delete the mapping X:

See John's comments above for the recommended approach.

Alternatively you can delete the project and create a new one with the same 
name with the new mapping.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12323" />
    <CreationDate amount="2002-03-26 17:05:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="major" />
    <Summery>Application dies after hitting a breakpoint</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>When I debug my servelet, A few seconds after hitting a breakpoint the 
application terminates with no messages, errors, or any other indication.

If I execute the application it works fine.
Any breakpoint being tripped will cause the silent termination.
Which VM? Can you reproduce this without a servlet? Which version of Eclipse?
Not enough information to reproduce. Closing.</WithStack>
    <WithOutStack>When I debug my servelet, A few seconds after hitting a breakpoint the 
application terminates with no messages, errors, or any other indication.

If I execute the application it works fine.
Any breakpoint being tripped will cause the silent termination.
Which VM? Can you reproduce this without a servlet? Which version of Eclipse?
Not enough information to reproduce. Closing.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12324" />
    <CreationDate amount="2002-03-26 17:05:00 -0500" />
    <DupId amount="21256" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="major" />
    <Summery>unable to change the thread name in debug view</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>After I attached the JVM, I changed the thread name, then later on, when the 
thread was paused, instead of showing the new thread name in debug view, the 
old name was still there. 

However, if I changed the thread name, then try to attach to the JVM, the 
changed name was displayed in the debug view.

So we ( users ) hope that the right thread name will be showed up the debug 
view, whenever we change the thread name.
There are no callbacks from a VM when a thread name changes.

Deferred
Reopening to mark as duplicate


*** This bug has been marked as a duplicate of 21256 ***</WithStack>
    <WithOutStack>After I attached the JVM, I changed the thread name, then later on, when the 
thread was paused, instead of showing the new thread name in debug view, the 
old name was still there. 

However, if I changed the thread name, then try to attach to the JVM, the 
changed name was displayed in the debug view.

So we ( users ) hope that the right thread name will be showed up the debug 
view, whenever we change the thread name.
There are no callbacks from a VM when a thread name changes.

Deferred
Reopening to mark as duplicate


*** This bug has been marked as a duplicate of 21256 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12325" />
    <CreationDate amount="2002-03-26 17:45:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Update  (deprecated - use RT&gt;Equinox&gt;p2)" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Eclipse won't start after crash</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437330633949">
        <Exception>java.lang.ClassNotFoundException</Exception>
        <Reason>org.eclipse.team.internal.ccvs.ui.CVSDecorator</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.core.internal.boot.DelegatingURLClassLoader.loadClass(DelegatingURLClassLoader.java:755)</Frame>
          <Frame depth="1">java.lang.ClassLoader.loadClass(ClassLoader.java(Compiled Code))</Frame>
          <Frame depth="2">org.eclipse.core.internal.plugins.PluginDescriptor.createExecutableExtension(PluginDescriptor.java:128)</Frame>
          <Frame depth="3">org.eclipse.core.internal.plugins.PluginDescriptor.createExecutableExtension(PluginDescriptor.java:165)</Frame>
          <Frame depth="4">org.eclipse.core.internal.plugins.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:96)</Frame>
          <Frame depth="5">org.eclipse.ui.internal.WorkbenchPlugin$1.run(WorkbenchPlugin.java:118)</Frame>
          <Frame depth="6">org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)</Frame>
          <Frame depth="7">org.eclipse.ui.internal.WorkbenchPlugin.createExtension(WorkbenchPlugin.java:115)</Frame>
          <Frame depth="8">org.eclipse.ui.internal.DecoratorDefinition.getDecorator(DecoratorDefinition.java:85)</Frame>
          <Frame depth="9">org.eclipse.ui.internal.DecoratorDefinition.setEnabled(DecoratorDefinition.java:120)</Frame>
          <Frame depth="10">org.eclipse.ui.internal.DecoratorManager.applyDecoratorsPreference(DecoratorManager.java:427)</Frame>
          <Frame depth="11">org.eclipse.ui.internal.DecoratorManager.restoreListeners(DecoratorManager.java:58)</Frame>
          <Frame depth="12">org.eclipse.ui.internal.WorkbenchPlugin.getDecoratorManager(WorkbenchPlugin.java:481)</Frame>
          <Frame depth="13">org.eclipse.ui.internal.DecoratorActionFactory.makeActions(DecoratorActionFactory.java:28)</Frame>
          <Frame depth="14">org.eclipse.ui.internal.WorkbenchActionBuilder.makeActions(WorkbenchActionBuilder.java:649)</Frame>
          <Frame depth="15">org.eclipse.ui.internal.WorkbenchActionBuilder.buildActions(WorkbenchActionBuilder.java:137)</Frame>
          <Frame depth="16">org.eclipse.ui.internal.WorkbenchWindow.&lt;init&gt;(WorkbenchWindow.java:215)</Frame>
          <Frame depth="17">org.eclipse.ui.internal.Workbench.restoreState(Workbench.java:678)</Frame>
          <Frame depth="18">org.eclipse.ui.internal.Workbench$5.run(Workbench.java:524)</Frame>
          <Frame depth="19">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:817)</Frame>
          <Frame depth="20">org.eclipse.core.runtime.Platform.run(Platform.java:395)</Frame>
          <Frame depth="21">org.eclipse.ui.internal.Workbench.openPreviousWorkbenchState(Workbench.java:509)</Frame>
          <Frame depth="22">org.eclipse.ui.internal.Workbench.openWindows(Workbench.java:559)</Frame>
          <Frame depth="23">org.eclipse.ui.internal.Workbench.init(Workbench.java:407)</Frame>
          <Frame depth="24">org.eclipse.ui.internal.Workbench.run(Workbench.java:702)</Frame>
          <Frame depth="25">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="26">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="27">java.lang.reflect.Method.invoke(Native Method)</Frame>
          <Frame depth="28">org.eclipse.core.launcher.Main.basicRun(Main.java:196)</Frame>
          <Frame depth="29">org.eclipse.core.launcher.Main.run(Main.java:555)</Frame>
          <Frame depth="30">org.eclipse.core.launcher.Main.main(Main.java:396)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="2">
      <Enumeration lines="6">
        <Lines>
          <Line>(1) where was the attached file located relative to the workspace/ install (ie.</Line>
          <Line>where did you find it when you were debugging ... in temp? in the install</Line>
          <Line>directory? in workspace .metadata subdirectory? other?)</Line>
          <Line>(2) what was the failure mode when "eclipse would fail to load certain classes"</Line>
          <Line>(wrong classes loaded? ClassDefNotFound?, other?)</Line>
          <Line>(3) did you specify any command line args when launching?</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="3">
        <Lines>
          <Line>1) The file was in the eclipse/install directory.</Line>
          <Line>2) See sample exception below</Line>
          <Line>3) I had a -vm and a -data</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Build 20020321

Michael had a self-hosting workspace running.  His machine crashed, and after 
rebooting the machine, eclipse would fail to load certain classes.  In 
particular, it could no longer load classes that belonged to the plugins he was 
self-hosting in his dev workspace.  It even failed to load the classes when he 
tried to run with a brand new workspace against the same build.

I tried this out on my machine, and narrowed it down to the platform.cfg file.  
If I deleted that file, everything worked fine.  I will attach this file... I 
assume it is in some weird state.  The entire workspace can be made available on 
request, but the rest of the workspace is just a plain 20020321 build.
Created attachment 522
The config file that causes the failure
Sorry, I just realized the summary doesn't match my description.  On Michael's 
machine, it failed to load certain classes. On my machine, Eclipse wouldn't 
start at all when this platform.cfg file was in place.

This looks like a Update issue. Moving to Update for comments.
Vlad, this looks like some config issue.
A few questions that may help me:

(1) where was the attached file located relative to the workspace/ install (ie. 
where did you find it when you were debugging ... in temp? in the install 
directory? in workspace .metadata subdirectory? other?)
(2) what was the failure mode when "eclipse would fail to load certain classes" 
(wrong classes loaded? ClassDefNotFound?, other?)
(3) did you specify any command line args when launching?

The platform.cfg is basically an explicit plugin-path file in 2.0 format, so I 
am not surprised things did not work when copied to a second machine (unless 
the setup is exactly same as the first machine).
1) The file was in the eclipse/install directory.
2) See sample exception below
3) I had a -vm and a -data

Log: Tue Mar 26 16:54:50 EST 2002
4 org.eclipse.core.runtime 2 Plug-in org.eclipse.team.cvs.ui was unable to load 
class org.eclipse.team.internal.ccvs.ui.CVSDecorator.
java.lang.ClassNotFoundException: org.eclipse.team.internal.ccvs.ui.CVSDecorator
	at org.eclipse.core.internal.boot.DelegatingURLClassLoader.loadClass
(DelegatingURLClassLoader.java:755)
	at java.lang.ClassLoader.loadClass(ClassLoader.java(Compiled Code))
	at 
org.eclipse.core.internal.plugins.PluginDescriptor.createExecutableExtension
(PluginDescriptor.java:128)
	at 
org.eclipse.core.internal.plugins.PluginDescriptor.createExecutableExtension
(PluginDescriptor.java:165)
	at 
org.eclipse.core.internal.plugins.ConfigurationElement.createExecutableExtension
(ConfigurationElement.java:96)
	at org.eclipse.ui.internal.WorkbenchPlugin$1.run
(WorkbenchPlugin.java:118)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)
	at org.eclipse.ui.internal.WorkbenchPlugin.createExtension
(WorkbenchPlugin.java:115)
	at org.eclipse.ui.internal.DecoratorDefinition.getDecorator
(DecoratorDefinition.java:85)
	at org.eclipse.ui.internal.DecoratorDefinition.setEnabled
(DecoratorDefinition.java:120)
	at org.eclipse.ui.internal.DecoratorManager.applyDecoratorsPreference
(DecoratorManager.java:427)
	at org.eclipse.ui.internal.DecoratorManager.restoreListeners
(DecoratorManager.java:58)
	at org.eclipse.ui.internal.WorkbenchPlugin.getDecoratorManager
(WorkbenchPlugin.java:481)
	at org.eclipse.ui.internal.DecoratorActionFactory.makeActions
(DecoratorActionFactory.java:28)
	at org.eclipse.ui.internal.WorkbenchActionBuilder.makeActions
(WorkbenchActionBuilder.java:649)
	at org.eclipse.ui.internal.WorkbenchActionBuilder.buildActions
(WorkbenchActionBuilder.java:137)
	at org.eclipse.ui.internal.WorkbenchWindow.&lt;init&gt;
(WorkbenchWindow.java:215)
	at org.eclipse.ui.internal.Workbench.restoreState(Workbench.java:678)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:524)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:817)
	at org.eclipse.core.runtime.Platform.run(Platform.java:395)
	at org.eclipse.ui.internal.Workbench.openPreviousWorkbenchState
(Workbench.java:509)
	at org.eclipse.ui.internal.Workbench.openWindows(Workbench.java:559)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:407)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:702)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at java.lang.reflect.Method.invoke(Native Method)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:196)
	at org.eclipse.core.launcher.Main.run(Main.java:555)
	at org.eclipse.core.launcher.Main.main(Main.java:396)
On the second machine, I first tried running in another location.  When that 
failed, I reproduced the same setup as Michael's machine (same paths for eclipse 
dev and workspace), but it still would not start.  I don't know what other 
variables between my machine and Michael's that would make any difference.
One other question ... how are you self-hosting. Are you using the PDE "Runtime 
Workbench" launcher, or do you have some custom setup (eg. using the startup 
Main launcher, some other).
I use the PDE runtime workbench and JUnit Core
I cannot tell from the supplied information what the problem was, and I could 
not recreate it. There are similar (but not identical) more recent reports of 
inability to restart (not necessarily after crash .... eg. 16215). Closing this 
defect. Will investigate the more recent reports.</WithStack>
    <WithOutStack>Build 20020321

Michael had a self-hosting workspace running.  His machine crashed, and after 
rebooting the machine, eclipse would fail to load certain classes.  In 
particular, it could no longer load classes that belonged to the plugins he was 
self-hosting in his dev workspace.  It even failed to load the classes when he 
tried to run with a brand new workspace against the same build.

I tried this out on my machine, and narrowed it down to the platform.cfg file.  
If I deleted that file, everything worked fine.  I will attach this file... I 
assume it is in some weird state.  The entire workspace can be made available on 
request, but the rest of the workspace is just a plain 20020321 build.
Created attachment 522
The config file that causes the failure
Sorry, I just realized the summary doesn't match my description.  On Michael's 
machine, it failed to load certain classes. On my machine, Eclipse wouldn't 
start at all when this platform.cfg file was in place.

This looks like a Update issue. Moving to Update for comments.
Vlad, this looks like some config issue.
A few questions that may help me:

(1) where was the attached file located relative to the workspace/ install (ie. 
where did you find it when you were debugging ... in temp? in the install 
directory? in workspace .metadata subdirectory? other?)
(2) what was the failure mode when "eclipse would fail to load certain classes" 
(wrong classes loaded? ClassDefNotFound?, other?)
(3) did you specify any command line args when launching?

The platform.cfg is basically an explicit plugin-path file in 2.0 format, so I 
am not surprised things did not work when copied to a second machine (unless 
the setup is exactly same as the first machine).
1) The file was in the eclipse/install directory.
2) See sample exception below
3) I had a -vm and a -data

Log: Tue Mar 26 16:54:50 EST 2002
4 org.eclipse.core.runtime 2 Plug-in org.eclipse.team.cvs.ui was unable to load 
class org.eclipse.team.internal.ccvs.ui.CVSDecorator.

On the second machine, I first tried running in another location.  When that 
failed, I reproduced the same setup as Michael's machine (same paths for eclipse 
dev and workspace), but it still would not start.  I don't know what other 
variables between my machine and Michael's that would make any difference.
One other question ... how are you self-hosting. Are you using the PDE "Runtime 
Workbench" launcher, or do you have some custom setup (eg. using the startup 
Main launcher, some other).
I use the PDE runtime workbench and JUnit Core
I cannot tell from the supplied information what the problem was, and I could 
not recreate it. There are similar (but not identical) more recent reports of 
inability to restart (not necessarily after crash .... eg. 16215). Closing this 
defect. Will investigate the more recent reports.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12326" />
    <CreationDate amount="2002-03-26 17:59:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="Other" />
    <op_sys amount="other" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Bad line number information returned from CompilationUnit with no trailing newline</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="12">
      <source_code type="class">
        <location start="174" end="245" />
        <code>public class Foo {
public static void main(String args[]) { int x= 3;}}</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="649" end="756" />
        <code>if (position &lt;= lineEndTable[low]) {
  // position illegal or before the first line delimiter
  return 1;
}</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="807" end="905" />
        <code>if (position &gt; lineEndTable[length - 1]) {
  // position beyond the end of last line
  return 1;
}</code>
      </source_code>
      <source_code type="multicomment">
        <location start="1068" end="1406" />
        <code>/**
 * Line end table. If &lt;code&gt;lineEndTable[i] == p&lt;/code&gt; then the
 * line number &lt;code&gt;i+1&lt;/code&gt; ends at character position 
 * &lt;code&gt;p&lt;/code&gt;. Except for the last line, the positions are that
 * of the last character of the line delimiter. 
 * For example, the source string &lt;code&gt;A\nB\nC&lt;/code&gt; has
 * line end table {1, 3, 4}.
 */</code>
      </source_code>
      <source_code type="assignment">
        <location start="1407" end="1447" />
        <code>private int[] lineEndTable = new int[0];</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="1495" end="1598" />
        <code>if (position &gt; lineEndTable[length - 1]) {
  // position beyond the end of last line
  return length;
}</code>
      </source_code>
      <source_code type="assignment">
        <location start="1672" end="1694" />
        <code>int hi = length - 1;</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="1733" end="1779" />
        <code>// position beyond the last line separator</code>
      </source_code>
      <source_code type="functiondef">
        <location start="1798" end="1904" />
        <code>getStartPosition() + getLength()) {
				// this is beyond the end of the source 
length
				return 1;
			}</code>
      </source_code>
      <source_code type="elsestatement">
        <location start="1900" end="1939" />
        <code>} else {
				return length + 1;
			}</code>
      </source_code>
      <source_code type="assignment">
        <location start="2067" end="2089" />
        <code>int hi = length - 1;</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="2090" end="2339" />
        <code>if (position &gt; lineEndTable[hi]) {
			// 
position beyond the last line separator
			if (position &gt;= getStartPosition() + 
getLength()) {
				// this is beyond the end of the source length
				return 1;
			} else 
{
				return length + 1;
			}
		}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Classfiles with no trailing newline seem to get bad linetables. This breaks
evaluation in all such types (VectorTest, for instance).

For example (with no trailing newline):
public class Foo {
public static void main(String args[]) { int x= 3;}}

The AST node (TypeDeclaration) for this class has start position 0 and length
71. We then try to get line number information from the corresponding
compilation unit
CompilationUnit.lineNumber(0) returns 1
CompilationUnit.lineNumber(70) returns 1

We've stepped into the lineNumber call and the CompilationUnit's line table only
has a single entry (18).
The call with lineNumber of 0 returns from here:
if (position &lt;= lineEndTable[low]) {
  // position illegal or before the first line delimiter
  return 1;
}
The call with lineNumber of 70 returns from here:
if (position &gt; lineEndTable[length - 1]) {
  // position beyond the end of last line
  return 1;
}

If the trailing newline is added to the file, it returns line numbers 1 and 2

Incidentally, the comment on the line table is confusing. Is the example correct?

/**
 * Line end table. If &lt;code&gt;lineEndTable[i] == p&lt;/code&gt; then the
 * line number &lt;code&gt;i+1&lt;/code&gt; ends at character position 
 * &lt;code&gt;p&lt;/code&gt;. Except for the last line, the positions are that
 * of the last character of the line delimiter. 
 * For example, the source string &lt;code&gt;A\nB\nC&lt;/code&gt; has
 * line end table {1, 3, 4}.
 */
private int[] lineEndTable = new int[0];
Indeed, the mapping is wrong, it should read:

if (position &gt; lineEndTable[length - 1]) {
  // position beyond the end of last line
  return length;
}

Also fixed comment.
Fixed
The fix doesn't work. I think we should have:
		int hi = length - 1;
		if (position &gt; 
lineEndTable[hi]) {
			// position beyond the last line separator
			if (position &gt; 
getStartPosition() + getLength()) {
				// this is beyond the end of the source 
length
				return 1;
			} else {
				return length + 1;
			}
		}

The line ends 
collection is zero-based, but the line numbers are 1-based. Then we need to add one.
My final proposal is:
		int hi = length - 1;
		if (position &gt; lineEndTable[hi]) {
			// 
position beyond the last line separator
			if (position &gt;= getStartPosition() + 
getLength()) {
				// this is beyond the end of the source length
				return 1;
			} else 
{
				return length + 1;
			}
		}

I misused a &gt; for a &gt;=. This fits to the specification of 
the method.
Regression tests added in the DOM tests (see test0314).
Fixed and released.</WithStack>
    <WithOutStack>Classfiles with no trailing newline seem to get bad linetables. This breaks
evaluation in all such types (VectorTest, for instance).

For example (with no trailing newline):
public class Foo {
public static void main(String args[]) { int x= 3;}}

The AST node (TypeDeclaration) for this class has start position 0 and length
71. We then try to get line number information from the corresponding
compilation unit
CompilationUnit.lineNumber(0) returns 1
CompilationUnit.lineNumber(70) returns 1

We've stepped into the lineNumber call and the CompilationUnit's line table only
has a single entry (18).
The call with lineNumber of 0 returns from here:
if (position &lt;= lineEndTable[low]) {
  // position illegal or before the first line delimiter
  return 1;
}
The call with lineNumber of 70 returns from here:
if (position &gt; lineEndTable[length - 1]) {
  // position beyond the end of last line
  return 1;
}

If the trailing newline is added to the file, it returns line numbers 1 and 2

Incidentally, the comment on the line table is confusing. Is the example correct?

/**
 * Line end table. If &lt;code&gt;lineEndTable[i] == p&lt;/code&gt; then the
 * line number &lt;code&gt;i+1&lt;/code&gt; ends at character position 
 * &lt;code&gt;p&lt;/code&gt;. Except for the last line, the positions are that
 * of the last character of the line delimiter. 
 * For example, the source string &lt;code&gt;A\nB\nC&lt;/code&gt; has
 * line end table {1, 3, 4}.
 */
private int[] lineEndTable = new int[0];
Indeed, the mapping is wrong, it should read:

if (position &gt; lineEndTable[length - 1]) {
  // position beyond the end of last line
  return length;
}

Also fixed comment.
Fixed
The fix doesn't work. I think we should have:
		int hi = length - 1;
		if (position &gt; 
lineEndTable[hi]) {
			// position beyond the last line separator
			if (position &gt; 
getStartPosition() + getLength()) {
				// this is beyond the end of the source 
length
				return 1;
			} else {
				return length + 1;
			}
		}

The line ends 
collection is zero-based, but the line numbers are 1-based. Then we need to add one.
My final proposal is:
		int hi = length - 1;
		if (position &gt; lineEndTable[hi]) {
			// 
position beyond the last line separator
			if (position &gt;= getStartPosition() + 
getLength()) {
				// this is beyond the end of the source length
				return 1;
			} else 
{
				return length + 1;
			}
		}

I misused a &gt; for a &gt;=. This fits to the specification of 
the method.
Regression tests added in the DOM tests (see test0314).
Fixed and released.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12327" />
    <CreationDate amount="2002-03-26 19:47:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="1.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="major" />
    <Summery>Running scrapbook evaluation reports 'debugger source lookup' problem</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="CLOSED" />
    <resolution amount="WONTFIX" />
    <WithStack>with Integration Build from 20020326 :

I create a scrapbook in my Java project and try to
evaluate (Ctrl-D) a simple expression (e.g. "Hello World")
THen a dialog pops up that states

 The source of the type
 'org.eclipse.jdt.internal.debug.ui.snippeteditor.ScrapbookMain1' could
 not be shown as the type was not found.
 [] Use default lookup path (project build path)
 [] Use custom lookup path
 ...
 [] Do not ask again

Even if 'do not ask again' is clicked the dialog shows
up the next time.
The dialog does not show up until the next time the scrapbook VM is re-started 
(as it is per debug session). Deferred.
This bug has been fixed in the 2.0 stream as part of other work.
Closing.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>with Integration Build from 20020326 :

I create a scrapbook in my Java project and try to
evaluate (Ctrl-D) a simple expression (e.g. "Hello World")
THen a dialog pops up that states

 The source of the type
 'org.eclipse.jdt.internal.debug.ui.snippeteditor.ScrapbookMain1' could
 not be shown as the type was not found.
 [] Use default lookup path (project build path)
 [] Use custom lookup path
 ...
 [] Do not ask again

Even if 'do not ask again' is clicked the dialog shows
up the next time.
The dialog does not show up until the next time the scrapbook VM is re-started 
(as it is per debug session). Deferred.
This bug has been fixed in the 2.0 stream as part of other work.
Closing.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12328" />
    <CreationDate amount="2002-03-27 02:12:00 -0500" />
    <DupId amount="12333" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Key delete and last editor</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>When I press key "delete", its action executed in last editor, even if I press 
it in first, second, etc.
W2k
integration build 20020326


*** This bug has been marked as a duplicate of 12333 ***</WithStack>
    <WithOutStack>When I press key "delete", its action executed in last editor, even if I press 
it in first, second, etc.
W2k
integration build 20020326


*** This bug has been marked as a duplicate of 12333 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12329" />
    <CreationDate amount="2002-03-27 02:16:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[Cell Editors] Request:ComboBoxCellEditor READ_ONLY style</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="CLOSED" />
    <resolution amount="FIXED" />
    <WithStack>Although CCombo accepts SWT.READ_ONLY style, there is no way to specify style 
when it is used in ComboBoxCellEditor.

How about adding createControl(Composite parent, int style) method to 
ComboBoxCellEditor class?
ComboBoxCellEditor is a JFace class.
*** Bug 24043 has been marked as a duplicate of this bug. ***
*** Bug 15923 has been marked as a duplicate of this bug. ***
Created attachment 2229
Style bits in cell editor constructors
Patch submitted
*** Bug 25356 has been marked as a duplicate of this bug. ***
*** Bug 25603 has been marked as a duplicate of this bug. ***
New constructer ComboBoxCellEditor(Composite parent, String[] items, int style) 
works fine. (Verified with 2.1.0)</WithStack>
    <WithOutStack>Although CCombo accepts SWT.READ_ONLY style, there is no way to specify style 
when it is used in ComboBoxCellEditor.

How about adding createControl(Composite parent, int style) method to 
ComboBoxCellEditor class?
ComboBoxCellEditor is a JFace class.
*** Bug 24043 has been marked as a duplicate of this bug. ***
*** Bug 15923 has been marked as a duplicate of this bug. ***
Created attachment 2229
Style bits in cell editor constructors
Patch submitted
*** Bug 25356 has been marked as a duplicate of this bug. ***
*** Bug 25603 has been marked as a duplicate of this bug. ***
New constructer ComboBoxCellEditor(Composite parent, String[] items, int style) 
works fine. (Verified with 2.1.0)</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12330" />
    <CreationDate amount="2002-03-27 02:57:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Feature Request - tidy fully qualified classes [code manipulation]</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="functiondef">
        <location start="1248" end="1879" />
        <code>private javax.swing.JPanel getJFrameContentPane() {
        if (ivjJFrameContentPane == null) {
            ivjJFrameContentPane = new javax.swing.JPanel();
            java.awt.BorderLayout layBorderLayout_3 = new java.awt.BorderLayout();
            ivjJFrameContentPane.setLayout(layBorderLayout_3);
            ivjJFrameContentPane.add(getIvjJToolBar(),
                    java.awt.BorderLayout.NORTH);
            ivjJFrameContentPane.add(getIvjJPanel(),
                    java.awt.BorderLayout.CENTER);
            ivjJFrameContentPane.setName("JFrameContentPane");
        }
        return ivjJFrameContentPane;
    }</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>When tidying import statements the tool could also parse the class, remove any 
fully qualified types and add the appropriate import statement, unless this is 
not possible (for example if java.util.Date and java.sql.Date are both being 
used).
would be useful in some circumstances, but when using the JDT tool you will 
typically not end-up with this kind of code, e.g., code assist and organize 
import help to avoid qualified type references. Deferred for after 2.0
[code manipulation]

This could be an option if we do organize imports for packages / projects. 
There it isn't disruptive to show a dialog since the action takes a while 
anyway.
*** Bug 19920 has been marked as a duplicate of this bug. ***
Chaning state from assigned later to resolved later. Assigned later got 
introduced by the last bug conversion and is not a supported Eclipse bug state.
*** Bug 37512 has been marked as a duplicate of this bug. ***
Is anyone working in this bug?

I think this functionality is useful to cleanup machine-generated code, like in VE.

In case of duplicated class names, it should display a dialog asking what class
will be imported, like in organize imports.

The following code snippet was generated by "MoreSwingComponents" VE example:

    private javax.swing.JPanel getJFrameContentPane() {
        if (ivjJFrameContentPane == null) {
            ivjJFrameContentPane = new javax.swing.JPanel();
            java.awt.BorderLayout layBorderLayout_3 = new java.awt.BorderLayout();
            ivjJFrameContentPane.setLayout(layBorderLayout_3);
            ivjJFrameContentPane.add(getIvjJToolBar(),
                    java.awt.BorderLayout.NORTH);
            ivjJFrameContentPane.add(getIvjJPanel(),
                    java.awt.BorderLayout.CENTER);
            ivjJFrameContentPane.setName("JFrameContentPane");
        }
        return ivjJFrameContentPane;
    }


As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>When tidying import statements the tool could also parse the class, remove any 
fully qualified types and add the appropriate import statement, unless this is 
not possible (for example if java.util.Date and java.sql.Date are both being 
used).
would be useful in some circumstances, but when using the JDT tool you will 
typically not end-up with this kind of code, e.g., code assist and organize 
import help to avoid qualified type references. Deferred for after 2.0
[code manipulation]

This could be an option if we do organize imports for packages / projects. 
There it isn't disruptive to show a dialog since the action takes a while 
anyway.
*** Bug 19920 has been marked as a duplicate of this bug. ***
Chaning state from assigned later to resolved later. Assigned later got 
introduced by the last bug conversion and is not a supported Eclipse bug state.
*** Bug 37512 has been marked as a duplicate of this bug. ***
Is anyone working in this bug?

I think this functionality is useful to cleanup machine-generated code, like in VE.

In case of duplicated class names, it should display a dialog asking what class
will be imported, like in organize imports.

The following code snippet was generated by "MoreSwingComponents" VE example:

    private javax.swing.JPanel getJFrameContentPane() {
        if (ivjJFrameContentPane == null) {
            ivjJFrameContentPane = new javax.swing.JPanel();
            java.awt.BorderLayout layBorderLayout_3 = new java.awt.BorderLayout();
            ivjJFrameContentPane.setLayout(layBorderLayout_3);
            ivjJFrameContentPane.add(getIvjJToolBar(),
                    java.awt.BorderLayout.NORTH);
            ivjJFrameContentPane.add(getIvjJPanel(),
                    java.awt.BorderLayout.CENTER);
            ivjJFrameContentPane.setName("JFrameContentPane");
        }
        return ivjJFrameContentPane;
    }


As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12331" />
    <CreationDate amount="2002-03-27 03:42:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="1.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Perspective opens in new Window</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Build 20020321:

It's not possible to open the same type of Perspective more than once
in the same Window. Eclipse is always opening the new Perspective in a new
Window.
In Build 20020214 it was possible to have the same Perspective more
than once in one Window. (e.g. to have a different focus)

Is it a bug or a feature ? :-)

Yours,
Ralf
Perspectives now open in the same window, unless they have a different input 
(e.g. a hierarchy perspective).
If you want a different window, use Window / New Window.

Ralf asks:

I wonder how you managed to open the same perspective
in the same window more than once.
If the perspective is already open it is switched to the existing 
one but not a new one opened. ( Build 20020416 )

I tried:
-&gt; Window -&gt; Open Perspective -&gt; "MyPerpective"

The dot in front of the current Perspective indicates that you 
removed the feature for opening the same perspective twice.

So maybe the "Bug" is a feature, but surely not a "RESOLVED WORKSFORME" ...

Your original complaint said that it always opened in a new window.  It no 
longer does that, which is why I marked it as WORKSFORME.
But this does not address the complaint about not being able to have more than 
one perspective of the same kind in the same window.

In 1.0, opening a perspective opened a whole new "page" with different views 
and editors.  In 2.0, they are now shared across all perspectives in the same 
window.  So it does not make a great deal of sense to allow multiple 
perspectives of the same kind in the same window.

The current behaviour is a deliberate redesign since people found it very 
confusing to have multiple sets of editors.

If you still want to open multiple perspectives of the same kind in the same 
window, e.g. because you have different preferred layouts, you can save a 
perspective under a different name using Window / Save Perspective As...

Changing status to more accurately reflect reality.
I would prefer to open the same perspective 
with the same layout but with a different focus.

If I got it right, this is no longer possible.

What a pity. I liked the possibility to have a few
perspectives open with different input (i.e. go into
a Project or a package or filter for different workingsets)
in the same Window. I'm getting used to it now that I have
to switch between my perspectives in a different way now
but it get's more and more crowded in my Taskbar... :-(

The only thing that was confusing before, was that it
was almost impossible to see wich perspective is wich one.
But there is not much difference now. It's not easier to
differentiate between the windows...

Thank you very much for your patience.

Yours,
Ralf
Yes, with this change we lost the ability to have perspectives with different 
inputs in the same window.  Generally using a different input reflects a 
different working context, and we felt it was clearer to separate these into 
multiple windows.  We also didn't know how to provide both sharing across 
perspectives and separate inputs in the same window, without seriously 
confusing the user.

However, using different windows, the current input should be shown in the 
titlebar, and would be visible in the task tray or when using Alt+Tab.
Does this not work for you?

unfortunately it only shows the type of
the perspective and last part of the packagename.

I have the problem of working in differnt Projects
at the same time where the last part of the package 
if often identical in different projects to have a
consistent organisation. At the moment I have 4 windows
with the title 

common - MyJava - Eclipse Projekt SDK

:-(
I've filed bug 15118 for the title problem.</WithStack>
    <WithOutStack>Build 20020321:

It's not possible to open the same type of Perspective more than once
in the same Window. Eclipse is always opening the new Perspective in a new
Window.
In Build 20020214 it was possible to have the same Perspective more
than once in one Window. (e.g. to have a different focus)

Is it a bug or a feature ? :-)

Yours,
Ralf
Perspectives now open in the same window, unless they have a different input 
(e.g. a hierarchy perspective).
If you want a different window, use Window / New Window.

Ralf asks:

I wonder how you managed to open the same perspective
in the same window more than once.
If the perspective is already open it is switched to the existing 
one but not a new one opened. ( Build 20020416 )

I tried:
-&gt; Window -&gt; Open Perspective -&gt; "MyPerpective"

The dot in front of the current Perspective indicates that you 
removed the feature for opening the same perspective twice.

So maybe the "Bug" is a feature, but surely not a "RESOLVED WORKSFORME" ...

Your original complaint said that it always opened in a new window.  It no 
longer does that, which is why I marked it as WORKSFORME.
But this does not address the complaint about not being able to have more than 
one perspective of the same kind in the same window.

In 1.0, opening a perspective opened a whole new "page" with different views 
and editors.  In 2.0, they are now shared across all perspectives in the same 
window.  So it does not make a great deal of sense to allow multiple 
perspectives of the same kind in the same window.

The current behaviour is a deliberate redesign since people found it very 
confusing to have multiple sets of editors.

If you still want to open multiple perspectives of the same kind in the same 
window, e.g. because you have different preferred layouts, you can save a 
perspective under a different name using Window / Save Perspective As...

Changing status to more accurately reflect reality.
I would prefer to open the same perspective 
with the same layout but with a different focus.

If I got it right, this is no longer possible.

What a pity. I liked the possibility to have a few
perspectives open with different input (i.e. go into
a Project or a package or filter for different workingsets)
in the same Window. I'm getting used to it now that I have
to switch between my perspectives in a different way now
but it get's more and more crowded in my Taskbar... :-(

The only thing that was confusing before, was that it
was almost impossible to see wich perspective is wich one.
But there is not much difference now. It's not easier to
differentiate between the windows...

Thank you very much for your patience.

Yours,
Ralf
Yes, with this change we lost the ability to have perspectives with different 
inputs in the same window.  Generally using a different input reflects a 
different working context, and we felt it was clearer to separate these into 
multiple windows.  We also didn't know how to provide both sharing across 
perspectives and separate inputs in the same window, without seriously 
confusing the user.

However, using different windows, the current input should be shown in the 
titlebar, and would be visible in the task tray or when using Alt+Tab.
Does this not work for you?

unfortunately it only shows the type of
the perspective and last part of the packagename.

I have the problem of working in differnt Projects
at the same time where the last part of the package 
if often identical in different projects to have a
consistent organisation. At the moment I have 4 windows
with the title 

common - MyJava - Eclipse Projekt SDK

:-(
I've filed bug 15118 for the title problem.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12332" />
    <CreationDate amount="2002-03-27 03:59:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Surround with try-catch fails if just one line is selected</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="3">
      <source_code type="assignment">
        <location start="27" end="82" />
        <code>Icon i = new ImageIcon(ResourceUtil.resourceUrl(name));</code>
      </source_code>
      <source_code type="assignment">
        <location start="120" end="175" />
        <code>Icon i = new ImageIcon(ResourceUtil.resourceUrl(name));</code>
      </source_code>
      <source_code type="functiondef">
        <location start="182" end="208" />
        <code>} catch(IOException e) {
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>this throws a IOException

Icon i = new ImageIcon(ResourceUtil.resourceUrl(name));

Surround with try/catch results in

Icon i = new ImageIcon(ResourceUtil.resourceUrl(name));
try {
} catch(IOException e) {
}

If i do the same with a least 2 lines all works fine.
version 20020321
Now it works again with just one line.
Will report if i see it again.
I've observed the same problem in 0321, but it is not always reproduceable. 

The problem is that the exception is thrown in an initializer of a declaration. 
It has nothing to do if you select one line.
Fixed in build &gt; I20020425</WithStack>
    <WithOutStack>this throws a IOException

Icon i = new ImageIcon(ResourceUtil.resourceUrl(name));

Surround with try/catch results in

Icon i = new ImageIcon(ResourceUtil.resourceUrl(name));
try {
} catch(IOException e) {
}

If i do the same with a least 2 lines all works fine.
version 20020321
Now it works again with just one line.
Will report if i see it again.
I've observed the same problem in 0321, but it is not always reproduceable. 

The problem is that the exception is thrown in an initializer of a declaration. 
It has nothing to do if you select one line.
Fixed in build &gt; I20020425</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12333" />
    <CreationDate amount="2002-03-27 04:14:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="critical" />
    <Summery>Java Editor sends delete key event to the last tabbed pane instead of active one</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Java Editor sends delete key event to the last tabbed pane instead of active one
Maybe the same happens also to the Tab-key
*** Bug 12328 has been marked as a duplicate of this bug. ***
Problem in the implementation of AcceleratorScope. Moved to Workbench UI.
Which build are you using? 
This is already fixed and should be in the 20020404 build.

Yes, this bug was already fixed.
Closing this report.</WithStack>
    <WithOutStack>Java Editor sends delete key event to the last tabbed pane instead of active one
Maybe the same happens also to the Tab-key
*** Bug 12328 has been marked as a duplicate of this bug. ***
Problem in the implementation of AcceleratorScope. Moved to Workbench UI.
Which build are you using? 
This is already fixed and should be in the 20020404 build.

Yes, this bug was already fixed.
Closing this report.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12334" />
    <CreationDate amount="2002-03-27 04:35:00 -0500" />
    <DupId amount="21417" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Open Type Hierarchy should allow multiple selection</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>For some code to browse it is good to be able to open the type hierarchy on more
than one project (or more than one package).
not for 2.0. Problem is to gine this selection a name so it could be presented 
in the history. 
dup of bug 21417


*** This bug has been marked as a duplicate of 21417 ***</WithStack>
    <WithOutStack>For some code to browse it is good to be able to open the type hierarchy on more
than one project (or more than one package).
not for 2.0. Problem is to gine this selection a name so it could be presented 
in the history. 
dup of bug 21417


*** This bug has been marked as a duplicate of 21417 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12335" />
    <CreationDate amount="2002-03-27 04:37:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Tab key does not work</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Build I2002-03-26, Windows XP, German KB layout

The tab key does not work for me anymore ...
That makes two of us:

Same build, Windows NT SP 6a, US keyboard layout


or me

Same build, Windows 2000, US keyboard layout


suspect that the keybinding support is the culprit. Moving to Platform UI.
Tod, please check this in the latest builds to confirm that this bug is indeed 
fixed.
Tabs work in build 20020501</WithStack>
    <WithOutStack>Build I2002-03-26, Windows XP, German KB layout

The tab key does not work for me anymore ...
That makes two of us:

Same build, Windows NT SP 6a, US keyboard layout


or me

Same build, Windows 2000, US keyboard layout


suspect that the keybinding support is the culprit. Moving to Platform UI.
Tod, please check this in the latest builds to confirm that this bug is indeed 
fixed.
Tabs work in build 20020501</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12336" />
    <CreationDate amount="2002-03-27 04:42:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P1" />
    <bug_severity amount="normal" />
    <Summery>Java Browsing views get cleared in combination with type hierarchy</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="functiondef">
        <location start="305" end="494" />
        <code>SelectionProviderMediator.propagateFocusChanged(Viewer viewer) {
  if (viewer != fViewerInFocus) { // Ok to compare by idendity
    fViewerInFocus= viewer;
    fireSelectionChanged();
  }
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="6">
        <Lines>
          <Line>1. Add Type Hierarchy view to Java Browsing perspective</Line>
          <Line>2. Select a type in the type hierarchy</Line>
          <Line>==&gt; Java Browsing views show correct state</Line>
          <Line>3. Click on a Java Browsing view "Types" or "Packages"</Line>
          <Line>==&gt; Java Browsing views get cleared.</Line>
          <Line>Investigated. This is a bug in the type hierarchy when losing focus:</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>1. Add Type Hierarchy view to Java Browsing perspective
2. Select a type in the type hierarchy
   ==&gt; Java Browsing views show correct state
3. Click on a Java Browsing view "Types" or "Packages"
   ==&gt; Java Browsing views get cleared.
Investigated. This is a bug in the type hierarchy when losing focus:
SelectionProviderMediator.propagateFocusChanged(Viewer viewer) {
  if (viewer != fViewerInFocus) { // Ok to compare by idendity
    fViewerInFocus= viewer;
    fireSelectionChanged();
  }
}
calls fireSelectionChanged() and there a "null" selection is fired because the
fViewerInFocus is null. This clears the Java Browsing views.

Moving to MA.



fixed &gt; 20020328</WithStack>
    <WithOutStack>1. Add Type Hierarchy view to Java Browsing perspective
2. Select a type in the type hierarchy
   ==&gt; Java Browsing views show correct state
3. Click on a Java Browsing view "Types" or "Packages"
   ==&gt; Java Browsing views get cleared.
Investigated. This is a bug in the type hierarchy when losing focus:
SelectionProviderMediator.propagateFocusChanged(Viewer viewer) {
  if (viewer != fViewerInFocus) { // Ok to compare by idendity
    fViewerInFocus= viewer;
    fireSelectionChanged();
  }
}
calls fireSelectionChanged() and there a "null" selection is fired because the
fViewerInFocus is null. This clears the Java Browsing views.

Moving to MA.



fixed &gt; 20020328</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12337" />
    <CreationDate amount="2002-03-27 05:02:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="blocker" />
    <Summery>Edit menu items remain disabled after viewpart activation</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="5">
        <Lines>
          <Line>1) open a CU</Line>
          <Line>2) change focus to outline</Line>
          <Line>3) verify that most edit menu items are disabled</Line>
          <Line>4) change focus back to editor</Line>
          <Line>5) observe that the edit menu items remain disabled</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>20020326-1324-I on Linux-Motif

  1) open a CU
  2) change focus to outline
  3) verify that most edit menu items are disabled
  4) change focus back to editor
  5) observe that the edit menu items remain disabled

I replaced the org.eclipse.ui plugin with an old one (20020321) and the problem 
is gone.
seems to be the case for w2k as well.
Fixed in EditorMenuManager</WithStack>
    <WithOutStack>20020326-1324-I on Linux-Motif

  1) open a CU
  2) change focus to outline
  3) verify that most edit menu items are disabled
  4) change focus back to editor
  5) observe that the edit menu items remain disabled

I replaced the org.eclipse.ui plugin with an old one (20020321) and the problem 
is gone.
seems to be the case for w2k as well.
Fixed in EditorMenuManager</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12338" />
    <CreationDate amount="2002-03-27 05:15:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Unnecessary recompilation when adding packages</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Build 20020214

From EC:

Every time I add a new Package, Eclipse starts compiling all the Java Source
files. I have over twenty packages with over 300 Classes. It takes a long
time for me to add a new package due to these unnecessary compilations.
Waiting for a reproducable test case from Siddharth &lt;gurkhabahadur@hotmail.com&gt;.
Closing. Received no answer from Siddharth.

Will reopen if I get a reproducable case.</WithStack>
    <WithOutStack>Build 20020214

From EC:

Every time I add a new Package, Eclipse starts compiling all the Java Source
files. I have over twenty packages with over 300 Classes. It takes a long
time for me to add a new package due to these unnecessary compilations.
Waiting for a reproducable test case from Siddharth &lt;gurkhabahadur@hotmail.com&gt;.
Closing. Received no answer from Siddharth.

Will reopen if I get a reproducable case.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12339" />
    <CreationDate amount="2002-03-27 05:32:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P1" />
    <bug_severity amount="critical" />
    <Summery>NPE when i switch to debug perspective</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437330633964">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.debug.internal.ui.views.VariablesView.setInitialContent(VariablesView.java:446)</Frame>
          <Frame depth="1">org.eclipse.debug.internal.ui.views.VariablesView.createActions(VariablesView.java:507)</Frame>
          <Frame depth="2">org.eclipse.debug.ui.AbstractDebugView.createPartControl(AbstractDebugView.java:234)</Frame>
          <Frame depth="3">org.eclipse.ui.internal.PartPane$1.run(PartPane.java:53)</Frame>
          <Frame depth="4">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:817)</Frame>
          <Frame depth="5">org.eclipse.core.runtime.Platform.run(Platform.java:395)</Frame>
          <Frame depth="6">org.eclipse.ui.internal.PartPane.createChildControl(PartPane.java:51)</Frame>
          <Frame depth="7">org.eclipse.ui.internal.PartPane.createControl(PartPane.java:93)</Frame>
          <Frame depth="8">org.eclipse.ui.internal.ViewPane.createControl(ViewPane.java:177)</Frame>
          <Frame depth="9">org.eclipse.ui.internal.PartTabFolder.createPartTab(PartTabFolder.java:245)</Frame>
          <Frame depth="10">org.eclipse.ui.internal.PartTabFolder.createControl(PartTabFolder.java:217)</Frame>
          <Frame depth="11">org.eclipse.ui.internal.PartSashContainer.createControl(PartSashContainer.java:177)</Frame>
          <Frame depth="12">org.eclipse.ui.internal.PerspectivePresentation.activate(PerspectivePresentation.java:88)</Frame>
          <Frame depth="13">org.eclipse.ui.internal.Perspective.onActivate(Perspective.java:558)</Frame>
          <Frame depth="14">org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:1746)</Frame>
          <Frame depth="15">org.eclipse.ui.internal.WorkbenchPage.busySetPerspective(WorkbenchPage.java:286)</Frame>
          <Frame depth="16">org.eclipse.ui.internal.WorkbenchPage.access$10(WorkbenchPage.java:270)</Frame>
          <Frame depth="17">org.eclipse.ui.internal.WorkbenchPage$7.run(WorkbenchPage.java:1788)</Frame>
          <Frame depth="18">org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)</Frame>
          <Frame depth="19">org.eclipse.ui.internal.WorkbenchPage.setPerspective(WorkbenchPage.java:1786)</Frame>
          <Frame depth="20">org.eclipse.ui.internal.SetPagePerspectiveAction.run(SetPagePerspectiveAction.java:66)</Frame>
          <Frame depth="21">org.eclipse.jface.action.Action.runWithEvent(Action.java:590)</Frame>
          <Frame depth="22">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:407)</Frame>
          <Frame depth="23">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:361)</Frame>
          <Frame depth="24">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:352)</Frame>
          <Frame depth="25">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:47)</Frame>
          <Frame depth="26">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)</Frame>
          <Frame depth="27">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)</Frame>
          <Frame depth="28">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)</Frame>
          <Frame depth="29">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)</Frame>
          <Frame depth="30">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)</Frame>
          <Frame depth="31">org.eclipse.ui.internal.Workbench.run(Workbench.java:738)</Frame>
          <Frame depth="32">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="33">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="34">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="35">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="36">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="37">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="38">org.eclipse.core.launcher.Main.basicRun(Main.java:196)</Frame>
          <Frame depth="39">org.eclipse.core.launcher.Main.run(Main.java:555)</Frame>
          <Frame depth="40">org.eclipse.core.launcher.UIMain.main(UIMain.java:52)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="5">
        <Lines>
          <Line>1) a java perspective and a debug perspective are open. (views are not at their</Line>
          <Line>default location)</Line>
          <Line>2) switch to the java perspective.</Line>
          <Line>3) shutdown and restart eclipse.</Line>
          <Line>4) switch to the debug perspective.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>in build 20020326
1) a java perspective and a debug perspective are open. (views are not at their 
default location)
2) switch to the java perspective.
3) shutdown and restart eclipse.
4) switch to the debug perspective.

variable view is broken and i have the following stacktrace in log file

java.lang.NullPointerException
	at org.eclipse.debug.internal.ui.views.VariablesView.setInitialContent
(VariablesView.java:446)
	at org.eclipse.debug.internal.ui.views.VariablesView.createActions
(VariablesView.java:507)
	at org.eclipse.debug.ui.AbstractDebugView.createPartControl
(AbstractDebugView.java:234)
	at org.eclipse.ui.internal.PartPane$1.run(PartPane.java:53)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:817)
	at org.eclipse.core.runtime.Platform.run(Platform.java:395)
	at org.eclipse.ui.internal.PartPane.createChildControl(PartPane.java:51)
	at org.eclipse.ui.internal.PartPane.createControl(PartPane.java:93)
	at org.eclipse.ui.internal.ViewPane.createControl(ViewPane.java:177)
	at org.eclipse.ui.internal.PartTabFolder.createPartTab
(PartTabFolder.java:245)
	at org.eclipse.ui.internal.PartTabFolder.createControl
(PartTabFolder.java:217)
	at org.eclipse.ui.internal.PartSashContainer.createControl
(PartSashContainer.java:177)
	at org.eclipse.ui.internal.PerspectivePresentation.activate
(PerspectivePresentation.java:88)
	at org.eclipse.ui.internal.Perspective.onActivate(Perspective.java:558)
	at org.eclipse.ui.internal.WorkbenchPage.setPerspective
(WorkbenchPage.java:1746)
	at org.eclipse.ui.internal.WorkbenchPage.busySetPerspective
(WorkbenchPage.java:286)
	at org.eclipse.ui.internal.WorkbenchPage.access$10
(WorkbenchPage.java:270)
	at org.eclipse.ui.internal.WorkbenchPage$7.run(WorkbenchPage.java:1788)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)
	at org.eclipse.ui.internal.WorkbenchPage.setPerspective
(WorkbenchPage.java:1786)
	at org.eclipse.ui.internal.SetPagePerspectiveAction.run
(SetPagePerspectiveAction.java:66)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:590)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:407)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:361)
	at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:352)
	at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:47)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:738)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:196)
	at org.eclipse.core.launcher.Main.run(Main.java:555)
	at org.eclipse.core.launcher.UIMain.main(UIMain.java:52)
Fixed in VariablesView#setInitialContent - javadoc states that getSelection can 
return null.
Please verify.
*** Bug 12197 has been marked as a duplicate of this bug. ***
Verified (with small change).</WithStack>
    <WithOutStack>in build 20020326
1) a java perspective and a debug perspective are open. (views are not at their 
default location)
2) switch to the java perspective.
3) shutdown and restart eclipse.
4) switch to the debug perspective.

variable view is broken and i have the following stacktrace in log file


Fixed in VariablesView#setInitialContent - javadoc states that getSelection can 
return null.
Please verify.
*** Bug 12197 has been marked as a duplicate of this bug. ***
Verified (with small change).</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12340" />
    <CreationDate amount="2002-03-27 06:07:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>type hierarchy member view misses sorter</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>everybody else has one
we descided to not offer one. the unsoretd 'show inherited members' view is not 
helpful.</WithStack>
    <WithOutStack>everybody else has one
we descided to not offer one. the unsoretd 'show inherited members' view is not 
helpful.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12341" />
    <CreationDate amount="2002-03-27 08:02:00 -0500" />
    <DupId amount="6983" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="blocker" />
    <Summery>FileBrowser when creating project does not respond</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="8">
        <Lines>
          <Line>1.  Start eclipse using -ws gtk1x option</Line>
          <Line>2.  Select File, New, Project</Line>
          <Line>3.  Select Java, Java Project, Next</Line>
          <Line>4.  Type in Project Name</Line>
          <Line>5.  Unselect Use Default (for project contents directory)</Line>
          <Line>6.  Select Browse (for project contents directory)</Line>
          <Line>7.  At this point the file browser opens, but is unresponsive to any mouse or</Line>
          <Line>keyboard input...I must kill eclipse.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="CLOSED" />
    <resolution amount="DUPLICATE" />
    <WithStack>On Linux GTK, using Stable Build: 20020321, downloaded file 
eclipse-SDK-20020321-linux-gtk1x.zip...

1.  Start eclipse using -ws gtk1x option
2.  Select File, New, Project
3.  Select Java, Java Project, Next
4.  Type in Project Name
5.  Unselect Use Default (for project contents directory)
6.  Select Browse (for project contents directory)
7.  At this point the file browser opens, but is unresponsive to any mouse or
keyboard input...I must kill eclipse.

This is reproducable.

My Linux version is RedHat 7.2.
My GTK+ version is gtk+-1.2.10-ximian.21
Moving to SWT


*** This bug has been marked as a duplicate of 6983 ***
Fixed.  The fix is also backported to the 1.2 stream.</WithStack>
    <WithOutStack>On Linux GTK, using Stable Build: 20020321, downloaded file 
eclipse-SDK-20020321-linux-gtk1x.zip...

1.  Start eclipse using -ws gtk1x option
2.  Select File, New, Project
3.  Select Java, Java Project, Next
4.  Type in Project Name
5.  Unselect Use Default (for project contents directory)
6.  Select Browse (for project contents directory)
7.  At this point the file browser opens, but is unresponsive to any mouse or
keyboard input...I must kill eclipse.

This is reproducable.

My Linux version is RedHat 7.2.
My GTK+ version is gtk+-1.2.10-ximian.21
Moving to SWT


*** This bug has been marked as a duplicate of 6983 ***
Fixed.  The fix is also backported to the 1.2 stream.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12342" />
    <CreationDate amount="2002-03-27 09:11:00 -0500" />
    <DupId amount="20957" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="All" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>[Preferences] ..Workbench .. Appearance Restore Defaults Fails</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="7">
        <Lines>
          <Line>1) Goto Workbench &gt; Preferences .. Workbench .. Appearance</Line>
          <Line>2) Default is Editors = Top; Views = Bottom</Line>
          <Line>Change to Editors = Bottom; Views = Top</Line>
          <Line>3) Click Apply and OK</Line>
          <Line>4) Goto Workbench &gt; Preferences .. Workbench .. Appearance</Line>
          <Line>5) Click Restore Defailts and OK</Line>
          <Line>6) Goto Workbench &gt; Preferences .. Workbench .. Appearance</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>If the user selects Workbench &gt; Prefrerences
Workbench .. Appearance and changes the values of The Editors/View
Menu boxes, and applies the change, the change is persistent, but
if they then select "Apply Default" the change is not persisted 
when the window is brought up again.  It takes a mouse action to
select the item to make the value change.

Test Case:
1) Goto Workbench &gt; Preferences .. Workbench .. Appearance
2) Default is Editors = Top; Views = Bottom
   Change to Editors = Bottom; Views = Top
3) Click Apply and OK
4) Goto Workbench &gt; Preferences .. Workbench .. Appearance
5) Click Restore Defailts and OK
6) Goto Workbench &gt; Preferences .. Workbench .. Appearance

Notice that the values do not match the default, but match the last
change.
Could not recreate in latest. 
I'm still seeing this in the current Eclipse 2.0 release.

The menu option is now Window-&gt;Preferences.

If the setting is "Bottom" and you hit "Restore Defaults", it switches to "Top",
then hit OK.  When you go back into the Preferences, the setting is back to
"Bottom".



*** This bug has been marked as a duplicate of 20957 ***</WithStack>
    <WithOutStack>If the user selects Workbench &gt; Prefrerences
Workbench .. Appearance and changes the values of The Editors/View
Menu boxes, and applies the change, the change is persistent, but
if they then select "Apply Default" the change is not persisted 
when the window is brought up again.  It takes a mouse action to
select the item to make the value change.

Test Case:
1) Goto Workbench &gt; Preferences .. Workbench .. Appearance
2) Default is Editors = Top; Views = Bottom
   Change to Editors = Bottom; Views = Top
3) Click Apply and OK
4) Goto Workbench &gt; Preferences .. Workbench .. Appearance
5) Click Restore Defailts and OK
6) Goto Workbench &gt; Preferences .. Workbench .. Appearance

Notice that the values do not match the default, but match the last
change.
Could not recreate in latest. 
I'm still seeing this in the current Eclipse 2.0 release.

The menu option is now Window-&gt;Preferences.

If the setting is "Bottom" and you hit "Restore Defaults", it switches to "Top",
then hit OK.  When you go back into the Preferences, the setting is back to
"Bottom".



*** This bug has been marked as a duplicate of 20957 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12343" />
    <CreationDate amount="2002-03-27 09:18:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="All" />
    <op_sys amount="Windows 2000" />
    <priority amount="P4" />
    <bug_severity amount="normal" />
    <Summery>Preferences .. Workbench Restore Defaults problems</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="4">
        <Lines>
          <Line>1) Select Workbench &gt; Preferences .. Workbench</Line>
          <Line>2) Unclick the "Perform build automatically on resource modification"</Line>
          <Line>3) Click Apply</Line>
          <Line>4) Click Restore Defaults</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>In the Workbench &gt; Preferences ... Workbench window,
the Restore Defaults is not restoring the default values
for the "Perform build automatically on resource modification"
button.

Test Case:
1) Select Workbench &gt; Preferences .. Workbench
2) Unclick the "Perform build automatically on resource modification"
3) Click Apply
4) Click Restore Defaults

The check box is not correctly reset
Works in latest</WithStack>
    <WithOutStack>In the Workbench &gt; Preferences ... Workbench window,
the Restore Defaults is not restoring the default values
for the "Perform build automatically on resource modification"
button.

Test Case:
1) Select Workbench &gt; Preferences .. Workbench
2) Unclick the "Perform build automatically on resource modification"
3) Click Apply
4) Click Restore Defaults

The check box is not correctly reset
Works in latest</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12344" />
    <CreationDate amount="2002-03-27 09:45:00 -0500" />
    <DupId amount="11375" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Compare" />
    <Version amount="2.0" />
    <rep_platform amount="Other" />
    <op_sys amount="Windows 98" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Strange behaviour with "copy current change"</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="3">
      <source_code type="functioncall">
        <location start="630" end="653" />
        <code>root.accept(visitor);</code>
      </source_code>
      <source_code type="functiondef">
        <location start="664" end="694" />
        <code>ropublic void testMove() {
}</code>
      </source_code>
      <source_code type="functioncall">
        <location start="693" end="713" />
        <code>}ot.accept(visitor);</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="2">
      <Enumeration lines="7">
        <Lines>
          <Line>- I made changes to a java file and then popped up the context menu and</Line>
          <Line>chose "Synchonize with stream".</Line>
          <Line>- the file was in conflict and it was a java file so it automatically brought</Line>
          <Line>up the structure compare</Line>
          <Line>- the version in the repository had added a bunch of methods, so I did a bunch</Line>
          <Line>of "copy current change from right to left"</Line>
          <Line>- but it put the methods in weird places</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="5">
        <Lines>
          <Line>- one method declaration was put before the package declaration</Line>
          <Line>- another method was put in the middle of another method, in the middle of a</Line>
          <Line>variable name</Line>
          <Line>e.g.</Line>
          <Line>old code:</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>build 2002-03-21 on Win98.

Sorry, I don't have exact reproducable steps for this.

- I made changes to a java file and then popped up the context menu and 
chose "Synchonize with stream".
- the file was in conflict and it was a java file so it automatically brought 
up the structure compare
- the version in the repository had added a bunch of methods, so I did a bunch 
of "copy current change from right to left"
- but it put the methods in weird places

- one method declaration was put before the package declaration
- another method was put in the middle of another method, in the middle of a 
variable name
e.g.
old code:
  root.accept(visitor);
new code:
  ropublic void testMove() {
}ot.accept(visitor);


*** This bug has been marked as a duplicate of 11375 ***</WithStack>
    <WithOutStack>build 2002-03-21 on Win98.

Sorry, I don't have exact reproducable steps for this.

- I made changes to a java file and then popped up the context menu and 
chose "Synchonize with stream".
- the file was in conflict and it was a java file so it automatically brought 
up the structure compare
- the version in the repository had added a bunch of methods, so I did a bunch 
of "copy current change from right to left"
- but it put the methods in weird places

- one method declaration was put before the package declaration
- another method was put in the middle of another method, in the middle of a 
variable name
e.g.
old code:
  root.accept(visitor);
new code:
  ropublic void testMove() {
}ot.accept(visitor);


*** This bug has been marked as a duplicate of 11375 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12345" />
    <CreationDate amount="2002-03-27 09:48:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[CVS Core] Do not allow adding of resources named ignoring case "cvs"</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="functioncall">
        <location start="778" end="823" />
        <code>document.getElementById("telno","a","b","c");</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>A user can run into many problems if they create a resource of that name. It
would be best to have the add command (scan arguments for "cvs" resources) and
have the command fail.

In addition, when setting the sync info on a folder and it fails then folder
must be unmanaged. This could happen when adding a folder that *contains* a CVS
subdir already. The add of the folder will fail but the sync info has already
been set in the cache.
*** Bug 50143 has been marked as a duplicate of this bug. ***
Post 3.0
The use of "cvs" is only a problem on some platforms. Given that we fail gracefully enough, there's is nothing more we plan to do.
Created attachment 124354
allergy asthma
JS editor syntax validate for function call
worng parameter can not report error.

for example :
document.getElementById("telno","a","b","c");


do not report syntax error.


Created attachment 145989
qwerty

aew
Created attachment 145990
qwert
Created attachment 150899
Bug 12345

ahmed
The content of attachment 150899 has been deleted by
    Denis Roy &lt;denis.roy@eclipse.org&gt;
who provided the following reason:

Probably junk

The token used to delete this attachment was generated at 2010-01-18 16:21:23 EST.
The content of attachment 124354 has been deleted by
    Denis Roy &lt;denis.roy@eclipse.org&gt;
who provided the following reason:

Junk

The token used to delete this attachment was generated at 2010-01-18 16:23:14 EST.</WithStack>
    <WithOutStack>A user can run into many problems if they create a resource of that name. It
would be best to have the add command (scan arguments for "cvs" resources) and
have the command fail.

In addition, when setting the sync info on a folder and it fails then folder
must be unmanaged. This could happen when adding a folder that *contains* a CVS
subdir already. The add of the folder will fail but the sync info has already
been set in the cache.
*** Bug 50143 has been marked as a duplicate of this bug. ***
Post 3.0
The use of "cvs" is only a problem on some platforms. Given that we fail gracefully enough, there's is nothing more we plan to do.
Created attachment 124354
allergy asthma
JS editor syntax validate for function call
worng parameter can not report error.

for example :
document.getElementById("telno","a","b","c");


do not report syntax error.


Created attachment 145989
qwerty

aew
Created attachment 145990
qwert
Created attachment 150899
Bug 12345

ahmed
The content of attachment 150899 has been deleted by
    Denis Roy &lt;denis.roy@eclipse.org&gt;
who provided the following reason:

Probably junk

The token used to delete this attachment was generated at 2010-01-18 16:21:23 EST.
The content of attachment 124354 has been deleted by
    Denis Roy &lt;denis.roy@eclipse.org&gt;
who provided the following reason:

Junk

The token used to delete this attachment was generated at 2010-01-18 16:23:14 EST.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12346" />
    <CreationDate amount="2002-03-27 09:51:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Leaking closed buffers</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build 20020326

IBuffer implementations other than the default one (Buffer) are never removed 
from the buffer cache when closed. This is due to the fact that the buffer 
change event doesn't drive the removal, but only the internal Buffer#close 
implementation.
Fixed</WithStack>
    <WithOutStack>Build 20020326

IBuffer implementations other than the default one (Buffer) are never removed 
from the buffer cache when closed. This is due to the fact that the buffer 
change event doesn't drive the removal, but only the internal Buffer#close 
implementation.
Fixed</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12347" />
    <CreationDate amount="2002-03-27 09:52:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P4" />
    <bug_severity amount="normal" />
    <Summery>Usability: Conflicts turn into outgoing changes, disappear from incomming view</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>20020321 M4, Win2K
This team stuff is a bit of a black art for me, but I just ran into a scenario I 
find really weird. You decide if it is a defect, or working as designed. From my 
point of view it is a defect.

* synch project with repo, get lots of incomming, conflicts, outgoing
* have the sunch editor in "incomming mode" ... shows incomming and conflicts
* Update from repo for all incomming without conflicts
* select java file in conflict
* start reconfiling ...
* select specific change on the repo side, copy change to workspace side
* save workspace side

This is where thing go funny ...

* the entire file disappears from my incomming list, although there were more 
changes I needed to reconcile
* the file now appears on my outgoing list, with the inverse of the changes 
marked as outgoing changes (eg. additions in repo are now deletions from 
workspace)

Seems like the "save" somehow implied I was done with reconciling and assumed 
the diffs were outgoing. The version state in workspace was also updated to the 
same version as in repo.

This is not intuitive and has turned reconciliation into a much more diufficult 
task. Perhaps "save" should have warned me. Or something else (not "save") 
should indicate I was done.
This is the way its supposed to work but I can see from your description how it 
can confuse.

To resolve conflicts you need to merge in the changes from the repository 
revision.  This makes your change outgoing, because its now based on the 
repository revision (as well as your edits).  Thus we also update the base 
information to reflect this.  You are now in the same state *as if you had 
loaded the latest from the repository then modified it*.

However, the fact it disappeared from your incomming view is although logical 
perhaps unhelpful.

I guess from your point of view its still a conflict, just one that's been 
resolved.

I will keep the PR open, maybe we can think of something better.

Note: I've reworded the title and modified the severity to reflect my comments.


OK, thanks for the explanation. Just one final comment from me ... the fact 
this happened quietly is dangerous. If I had not noticed this, I would have 
simply assumed my file was now reconciled. Had I released my code, I would 
have "undone" (in the repository) all the incomming changes. [Maybe this is a 
feature ... repository undo  ;-) ]. I think if I was warned when saving 
(eg. "There are more incomming changes to be reconciled, are you sure you are 
done?") then I would have responded "No, I am not done".
Files are no longer automatically removed from the sync view.</WithStack>
    <WithOutStack>20020321 M4, Win2K
This team stuff is a bit of a black art for me, but I just ran into a scenario I 
find really weird. You decide if it is a defect, or working as designed. From my 
point of view it is a defect.

* synch project with repo, get lots of incomming, conflicts, outgoing
* have the sunch editor in "incomming mode" ... shows incomming and conflicts
* Update from repo for all incomming without conflicts
* select java file in conflict
* start reconfiling ...
* select specific change on the repo side, copy change to workspace side
* save workspace side

This is where thing go funny ...

* the entire file disappears from my incomming list, although there were more 
changes I needed to reconcile
* the file now appears on my outgoing list, with the inverse of the changes 
marked as outgoing changes (eg. additions in repo are now deletions from 
workspace)

Seems like the "save" somehow implied I was done with reconciling and assumed 
the diffs were outgoing. The version state in workspace was also updated to the 
same version as in repo.

This is not intuitive and has turned reconciliation into a much more diufficult 
task. Perhaps "save" should have warned me. Or something else (not "save") 
should indicate I was done.
This is the way its supposed to work but I can see from your description how it 
can confuse.

To resolve conflicts you need to merge in the changes from the repository 
revision.  This makes your change outgoing, because its now based on the 
repository revision (as well as your edits).  Thus we also update the base 
information to reflect this.  You are now in the same state *as if you had 
loaded the latest from the repository then modified it*.

However, the fact it disappeared from your incomming view is although logical 
perhaps unhelpful.

I guess from your point of view its still a conflict, just one that's been 
resolved.

I will keep the PR open, maybe we can think of something better.

Note: I've reworded the title and modified the severity to reflect my comments.


OK, thanks for the explanation. Just one final comment from me ... the fact 
this happened quietly is dangerous. If I had not noticed this, I would have 
simply assumed my file was now reconciled. Had I released my code, I would 
have "undone" (in the repository) all the incomming changes. [Maybe this is a 
feature ... repository undo  ;-) ]. I think if I was warned when saving 
(eg. "There are more incomming changes to be reconciled, are you sure you are 
done?") then I would have responded "No, I am not done".
Files are no longer automatically removed from the sync view.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12348" />
    <CreationDate amount="2002-03-27 09:56:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="major" />
    <Summery>Action set part associations: how to enable an action set for a specific outliner</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Build 20020323

I want to enable the JDT-navigate action set only if the outliner is active and 
if the outliner "belongs" to a compilation unit editor or class file editor. 
How do I do this ?
Why not associate the action set with the editor?
If we support what you are asking, the action set will be added/removed as you 
click between the editor and outline. We are trying to avoid such flash.
You are absolutely right. PR can be closed.
closed</WithStack>
    <WithOutStack>Build 20020323

I want to enable the JDT-navigate action set only if the outliner is active and 
if the outliner "belongs" to a compilation unit editor or class file editor. 
How do I do this ?
Why not associate the action set with the editor?
If we support what you are asking, the action set will be added/removed as you 
click between the editor and outline. We are trying to avoid such flash.
You are absolutely right. PR can be closed.
closed</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12349" />
    <CreationDate amount="2002-03-27 10:14:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Java Browsing: Members view for class file does not reveal if opened by search</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Interesting Bug: if a class file is opened via Search view then the Members view
selection is not revealed in the editor. If the file is closed and opened via
other view (e.g. Packages) then it works.
This seems to be an editor bug using == instead of equals(...).

Fixed in the Java editor</WithStack>
    <WithOutStack>Interesting Bug: if a class file is opened via Search view then the Members view
selection is not revealed in the editor. If the file is closed and opened via
other view (e.g. Packages) then it works.
This seems to be an editor bug using == instead of equals(...).

Fixed in the Java editor</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12350" />
    <CreationDate amount="2002-03-27 10:23:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Class header javadoc in eval ast classes</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="multicomment">
        <location start="67" end="103" />
        <code>/**
 * @version 	1.0
 * @author
 */</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>The following Javadoc should be removed from the eval ast classes;

/**
 * @version 	1.0
 * @author
 */
Done (ugh).
Please verify.
Verified.</WithStack>
    <WithOutStack>The following Javadoc should be removed from the eval ast classes;

/**
 * @version 	1.0
 * @author
 */
Done (ugh).
Please verify.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12351" />
    <CreationDate amount="2002-03-27 10:38:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Update  (deprecated - use RT&gt;Equinox&gt;p2)" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="blocker" />
    <Summery>[Blocker] Unconfigured feature do not show</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Install RedDot 1
Restart
Unconfigure RedDot 1
Restart
The unconfigure button is not present. 

Lookign at the code, who is caling
LocalSiteView#isUpdatable(IActionBars) which seems to add the button to teh
toolbar ?

Blocker for Sniff Test and Test Suites
Blocker next integration build, sorry ;-(
Something strange happened - the method 'isUpdatable' is probably a side-effect 
from some refactoring pass, because the original name of the method 
was 'fillActionBars'. The superclass implementation does nothing, subclasses 
are supposed to use it to contribute. 

Renamed it back and the button returned. It seems to work now.</WithStack>
    <WithOutStack>Install RedDot 1
Restart
Unconfigure RedDot 1
Restart
The unconfigure button is not present. 

Lookign at the code, who is caling
LocalSiteView#isUpdatable(IActionBars) which seems to add the button to teh
toolbar ?

Blocker for Sniff Test and Test Suites
Blocker next integration build, sorry ;-(
Something strange happened - the method 'isUpdatable' is probably a side-effect 
from some refactoring pass, because the original name of the method 
was 'fillActionBars'. The superclass implementation does nothing, subclasses 
are supposed to use it to contribute. 

Renamed it back and the button returned. It seems to work now.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12352" />
    <CreationDate amount="2002-03-27 10:42:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Text" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Text editor doesn't fire selection changes when caret moves</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Build 20020323
This would cause major performance issues because of continuous action updating 
on every single key stroke.
I am trying to add support for the Tabbed Properties in the JavaEditor (bug 154781).  This bug is preventing the PropertySheet class from updating when the cursor moves in a TextEditor.  PropertySheet is an ISelectionListener on the IWorkbenchPage and no selectionChanged event is fired when a mouse selection occurs.

There are other text based editors that properly support the PropertySheet such as the XSD editor and XML editors.  I noticed that the XSD editor allows you to type and then only fires the selectionChanged event after you are done typing.  Couldn't the text editor do this?
&gt;Couldn't the text editor do this?
This is already there - it is called post selection listener.</WithStack>
    <WithOutStack>Build 20020323
This would cause major performance issues because of continuous action updating 
on every single key stroke.
I am trying to add support for the Tabbed Properties in the JavaEditor (bug 154781).  This bug is preventing the PropertySheet class from updating when the cursor moves in a TextEditor.  PropertySheet is an ISelectionListener on the IWorkbenchPage and no selectionChanged event is fired when a mouse selection occurs.

There are other text based editors that properly support the PropertySheet such as the XSD editor and XML editors.  I noticed that the XSD editor allows you to type and then only fires the selectionChanged event after you are done typing.  Couldn't the text editor do this?
&gt;Couldn't the text editor do this?
This is already there - it is called post selection listener.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12353" />
    <CreationDate amount="2002-03-27 10:47:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P1" />
    <bug_severity amount="normal" />
    <Summery>DocumentAdapter can never be closed</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437330633980">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.removeBufferChangedListener(DocumentAdapter.java:167)</Frame>
          <Frame depth="1">org.eclipse.jdt.internal.core.Openable.closeBuffer(Openable.java:83)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.core.Openable.closing(Openable.java:91)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.core.JavaElement.close(JavaElement.java:106)</Frame>
          <Frame depth="4">org.eclipse.jdt.internal.core.WorkingCopy.destroy(WorkingCopy.java:80)</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.disposeElementInfo(CompilationUnitDocumentProvider.java:224)</Frame>
          <Frame depth="6">org.eclipse.ui.texteditor.AbstractDocumentProvider.disconnect(AbstractDocumentProvider.java:273)</Frame>
          <Frame depth="7">org.eclipse.ui.texteditor.AbstractTextEditor.dispose(AbstractTextEditor.java:1422)</Frame>
          <Frame depth="8">org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose(CompilationUnitEditor.java:933)</Frame>
          <Frame depth="9">org.eclipse.ui.internal.WorkbenchPage.closeEditor(WorkbenchPage.java:422)</Frame>
          <Frame depth="10">org.eclipse.ui.internal.EditorPane.doHide(EditorPane.java:76)</Frame>
          <Frame depth="11">org.eclipse.ui.internal.EditorWorkbook$1.itemClosed(EditorWorkbook.java:122)</Frame>
          <Frame depth="12">org.eclipse.swt.custom.CTabFolder.closeNotify(CTabFolder.java:303)</Frame>
          <Frame depth="13">org.eclipse.swt.custom.CTabFolder.access$12(CTabFolder.java:293)</Frame>
          <Frame depth="14">org.eclipse.swt.custom.CTabFolder$4.handleEvent(CTabFolder.java:424)</Frame>
          <Frame depth="15">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)</Frame>
          <Frame depth="16">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)</Frame>
          <Frame depth="18">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)</Frame>
          <Frame depth="19">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:722)</Frame>
          <Frame depth="20">org.eclipse.ui.internal.Workbench.run(Workbench.java:705)</Frame>
          <Frame depth="21">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="22">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="23">EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build 20020326

The implementation of DocumentAdapter#close() prevents it from ever being 
closed (logic on null check against fDocument is wrong).

Therefore, such buffers will leak in the JavaModel buffer manager.
Another problem behind this one is that #close is nullifying the listeners 
slot, and therefore IBuffer#removeBufferChangedListener cannot be called
from thereon by the infrastructure when noticing the buffer being closed (this 
is a recent change post 20020326).

java.lang.NullPointerException
	at 
org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.removeBufferChangedListen
er(DocumentAdapter.java:167)
	at org.eclipse.jdt.internal.core.Openable.closeBuffer(Openable.java:83)
	at org.eclipse.jdt.internal.core.Openable.closing(Openable.java:91)
	at org.eclipse.jdt.internal.core.JavaElement.close(JavaElement.java:106)
	at org.eclipse.jdt.internal.core.WorkingCopy.destroy
(WorkingCopy.java:80)
	at 
org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.disposeEl
ementInfo(CompilationUnitDocumentProvider.java:224)
	at org.eclipse.ui.texteditor.AbstractDocumentProvider.disconnect
(AbstractDocumentProvider.java:273)
	at org.eclipse.ui.texteditor.AbstractTextEditor.dispose
(AbstractTextEditor.java:1422)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.dispose
(CompilationUnitEditor.java:933)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditor
(WorkbenchPage.java:422)
	at org.eclipse.ui.internal.EditorPane.doHide(EditorPane.java:76)
	at org.eclipse.ui.internal.EditorWorkbook$1.itemClosed
(EditorWorkbook.java:122)
	at org.eclipse.swt.custom.CTabFolder.closeNotify(CTabFolder.java:303)
	at org.eclipse.swt.custom.CTabFolder.access$12(CTabFolder.java:293)
	at org.eclipse.swt.custom.CTabFolder$4.handleEvent(CTabFolder.java:424)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:722)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:705)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)
Unhandled exception caught in event loop.
Reason:
java.lang.NullPointerException
Fixed bug in implementation of close. Don't set listeners list to null in order 
to allow post-close listener operations. This is different from the java doc of 
close. Pls specify which methods can be called  after close and what happens if 
one of the other methods is called. Moving to JDT core.
Running with "closable" buffers, I see the following problem when hovering over 
identifiers. The problem seems that the buffer has been closed, but the calling 
code does not check this.  Rolling back the change for stability.

Thread [main] (Suspended (exception java.lang.NullPointerException))
	org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.getLength() 
line: 233
	org.eclipse.jdt.internal.core.WorkingCopy
(org.eclipse.jdt.internal.core.Openable).codeSelect
(org.eclipse.jdt.internal.compiler.env.ICompilationUnit, int, int, 
org.eclipse.jdt.internal.codeassist.ISelectionRequestor) line: 132
	org.eclipse.jdt.internal.core.WorkingCopy
(org.eclipse.jdt.internal.core.Openable).codeSelect
(org.eclipse.jdt.internal.compiler.env.ICompilationUnit, int, int) line: 121
	org.eclipse.jdt.internal.core.WorkingCopy
(org.eclipse.jdt.internal.core.CompilationUnit).codeSelect(int, int) line: 100
	org.eclipse.jdt.internal.ui.text.java.hover.JavaTypeHover.getHoverInfo
(org.eclipse.jface.text.ITextViewer, org.eclipse.jface.text.IRegion) line: 93
	org.eclipse.jdt.internal.ui.text.java.hover.JavaTextHover.getHoverInfo
(org.eclipse.jface.text.ITextViewer, org.eclipse.jface.text.IRegion) line: 300
	org.eclipse.jface.text.TextViewerHoverManager.computeInformation() 
line: 56
	org.eclipse.jface.text.TextViewerHoverManager
(org.eclipse.jface.text.AbstractInformationControlManager).showInformation() 
line: 536
	org.eclipse.jface.text.AbstractHoverInformationControlManager$MouseTrack
er.mouseHover(org.eclipse.swt.events.MouseEvent) line: 233
	org.eclipse.swt.widgets.TypedListener.handleEvent
(org.eclipse.swt.widgets.Event) line: 207
	org.eclipse.swt.widgets.EventTable.sendEvent
(org.eclipse.swt.widgets.Event) line: 75
	org.eclipse.swt.custom.StyledText
(org.eclipse.swt.widgets.Widget).notifyListeners(int, 
org.eclipse.swt.widgets.Event) line: 637
	org.eclipse.swt.widgets.Display.runDeferredEvents() line: 1420
	org.eclipse.swt.widgets.Display.readAndDispatch() line: 1208
	org.eclipse.ui.internal.Workbench.runEventLoop() line: 755
	org.eclipse.ui.internal.Workbench.run(java.lang.Object) line: 738
	org.eclipse.core.internal.boot.InternalBootLoader.run(java.lang.String, 
java.net.URL, java.lang.String, java.lang.String[]) line: 777
	org.eclipse.core.boot.BootLoader.run(java.lang.String, java.net.URL, 
java.lang.String, java.lang.String[]) line: 319
	EclipseRuntimeLauncher.main(java.lang.String[]) line: 14

How did this buffer get closed in the first place ?
Kai, do you know why the buffer was closed?
Didn't check.
Do you plan to check?
Moving to JDT/UI to get attention.
Closing is done by the buffer manager of JCore.
If the buffer doesn't have unsaved changes, then it is legite for it to be 
closed  by the buffer management (when needing space).

Note that we found an inconsistency in the buffer management which could have 
lead to requesting twice to close the same buffer. Please double check your 
behavior with integration build 20020416 where we will have released this fix.


We actually found an inconsistency in our buffer manager (could keep the buffer 
in, though it wanted to close it). From thereon, it would not have reopened the 
buffer, but rather reused closed one thus factory did not get involved.

Fixed</WithStack>
    <WithOutStack>Build 20020326

The implementation of DocumentAdapter#close() prevents it from ever being 
closed (logic on null check against fDocument is wrong).

Therefore, such buffers will leak in the JavaModel buffer manager.
Another problem behind this one is that #close is nullifying the listeners 
slot, and therefore IBuffer#removeBufferChangedListener cannot be called
from thereon by the infrastructure when noticing the buffer being closed (this 
is a recent change post 20020326).

Unhandled exception caught in event loop.
Reason:
java.lang.NullPointerException
Fixed bug in implementation of close. Don't set listeners list to null in order 
to allow post-close listener operations. This is different from the java doc of 
close. Pls specify which methods can be called  after close and what happens if 
one of the other methods is called. Moving to JDT core.
Running with "closable" buffers, I see the following problem when hovering over 
identifiers. The problem seems that the buffer has been closed, but the calling 
code does not check this.  Rolling back the change for stability.

Thread [main] (Suspended (exception java.lang.NullPointerException))
	org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.getLength() 
line: 233
	org.eclipse.jdt.internal.core.WorkingCopy
(org.eclipse.jdt.internal.core.Openable).codeSelect
(org.eclipse.jdt.internal.compiler.env.ICompilationUnit, int, int, 
org.eclipse.jdt.internal.codeassist.ISelectionRequestor) line: 132
	org.eclipse.jdt.internal.core.WorkingCopy
(org.eclipse.jdt.internal.core.Openable).codeSelect
(org.eclipse.jdt.internal.compiler.env.ICompilationUnit, int, int) line: 121
	org.eclipse.jdt.internal.core.WorkingCopy
(org.eclipse.jdt.internal.core.CompilationUnit).codeSelect(int, int) line: 100
	org.eclipse.jdt.internal.ui.text.java.hover.JavaTypeHover.getHoverInfo
(org.eclipse.jface.text.ITextViewer, org.eclipse.jface.text.IRegion) line: 93
	org.eclipse.jdt.internal.ui.text.java.hover.JavaTextHover.getHoverInfo
(org.eclipse.jface.text.ITextViewer, org.eclipse.jface.text.IRegion) line: 300
	org.eclipse.jface.text.TextViewerHoverManager.computeInformation() 
line: 56
	org.eclipse.jface.text.TextViewerHoverManager
(org.eclipse.jface.text.AbstractInformationControlManager).showInformation() 
line: 536
	org.eclipse.jface.text.AbstractHoverInformationControlManager$MouseTrack
er.mouseHover(org.eclipse.swt.events.MouseEvent) line: 233
	org.eclipse.swt.widgets.TypedListener.handleEvent
(org.eclipse.swt.widgets.Event) line: 207
	org.eclipse.swt.widgets.EventTable.sendEvent
(org.eclipse.swt.widgets.Event) line: 75
	org.eclipse.swt.custom.StyledText
(org.eclipse.swt.widgets.Widget).notifyListeners(int, 
org.eclipse.swt.widgets.Event) line: 637
	org.eclipse.swt.widgets.Display.runDeferredEvents() line: 1420
	org.eclipse.swt.widgets.Display.readAndDispatch() line: 1208
	org.eclipse.ui.internal.Workbench.runEventLoop() line: 755
	org.eclipse.ui.internal.Workbench.run(java.lang.Object) line: 738
	org.eclipse.core.internal.boot.InternalBootLoader.run(java.lang.String, 
java.net.URL, java.lang.String, java.lang.String[]) line: 777
	org.eclipse.core.boot.BootLoader.run(java.lang.String, java.net.URL, 
java.lang.String, java.lang.String[]) line: 319
	EclipseRuntimeLauncher.main(java.lang.String[]) line: 14

How did this buffer get closed in the first place ?
Kai, do you know why the buffer was closed?
Didn't check.
Do you plan to check?
Moving to JDT/UI to get attention.
Closing is done by the buffer manager of JCore.
If the buffer doesn't have unsaved changes, then it is legite for it to be 
closed  by the buffer management (when needing space).

Note that we found an inconsistency in the buffer management which could have 
lead to requesting twice to close the same buffer. Please double check your 
behavior with integration build 20020416 where we will have released this fix.


We actually found an inconsistency in our buffer manager (could keep the buffer 
in, though it wanted to close it). From thereon, it would not have reopened the 
buffer, but rather reused closed one thus factory did not get involved.

Fixed</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12354" />
    <CreationDate amount="2002-03-27 10:47:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="other" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Checking "Clear workspace data before launching" doesn't clear</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Checking "Clear workspace data before launching" doesn't clear the workspace.  
Seems to have no effect at all.
I am pretty sure I released the fix for this in 3/26. If you are using 3/21, it 
makes sense.
I apologize for not putting the build I was using.  I am on 20020321.
I will check with the next build.
A duplicate - fixed in 0326.</WithStack>
    <WithOutStack>Checking "Clear workspace data before launching" doesn't clear the workspace.  
Seems to have no effect at all.
I am pretty sure I released the fix for this in 3/26. If you are using 3/21, it 
makes sense.
I apologize for not putting the build I was using.  I am on 20020321.
I will check with the next build.
A duplicate - fixed in 0326.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12355" />
    <CreationDate amount="2002-03-27 10:53:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Doc" />
    <Version amount="2.0" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Documentation needed for plugin descriptions</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>I have found that there seem to be new plugin extension points that are not 
documented.  This should be addressed in release 2.0.  On the other side, I 
have also found extension points that seem to have been deprecated.  Thanks.
Closing this old doc bug - we did a pass through all extension points in 3.0 to
ensure there was documentation.  If documentation is missing for particular
extensions or extension points, please list them.</WithStack>
    <WithOutStack>I have found that there seem to be new plugin extension points that are not 
documented.  This should be addressed in release 2.0.  On the other side, I 
have also found extension points that seem to have been deprecated.  Thanks.
Closing this old doc bug - we did a pass through all extension points in 3.0 to
ensure there was documentation.  If documentation is missing for particular
extensions or extension points, please list them.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12356" />
    <CreationDate amount="2002-03-27 10:54:00 -0500" />
    <DupId amount="4805" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="major" />
    <Summery>Windows Only: moving Control doesn't cause expose to occcur</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="11">
      <source_code type="import">
        <location start="60" end="88" />
        <code>import org.eclipse.swt.SWT;</code>
      </source_code>
      <source_code type="import">
        <location start="89" end="126" />
        <code>import org.eclipse.swt.custom.CCombo;</code>
      </source_code>
      <source_code type="import">
        <location start="127" end="159" />
        <code>import org.eclipse.swt.events.*;</code>
      </source_code>
      <source_code type="import">
        <location start="160" end="201" />
        <code>import org.eclipse.swt.events.MouseEvent;</code>
      </source_code>
      <source_code type="import">
        <location start="202" end="250" />
        <code>import org.eclipse.swt.events.MouseMoveListener;</code>
      </source_code>
      <source_code type="import">
        <location start="251" end="296" />
        <code>import org.eclipse.swt.events.SelectionEvent;</code>
      </source_code>
      <source_code type="import">
        <location start="297" end="331" />
        <code>import org.eclipse.swt.graphics.*;</code>
      </source_code>
      <source_code type="import">
        <location start="332" end="370" />
        <code>import org.eclipse.swt.graphics.Color;</code>
      </source_code>
      <source_code type="import">
        <location start="371" end="404" />
        <code>import org.eclipse.swt.widgets.*;</code>
      </source_code>
      <source_code type="multicomment">
        <location start="405" end="465" />
        <code>/**
 * Click the upper left button to see painting bug.
 */</code>
      </source_code>
      <source_code type="class">
        <location start="466" end="1233" />
        <code>public class SetRedrawTest {

public static void main(String args[]){
	Display display = new Display();
	final Shell shell = new Shell(display);
	
	shell.setSize(600, 600);
	shell.setLocation(100,100);

	final Button button = new Button(shell, 0);
	button.setBounds(20, 20, 100, 60);

	final Button button2 = new Button(shell, 0);
	button2.setBounds(100, 100, 100, 60);

	button.addSelectionListener(new SelectionListener() {
		public void widgetSelected(SelectionEvent e) {
			button2.setRedraw(false);
			button2.setLocation(100, 150);
			button2.setRedraw(true);
		}

		public void widgetDefaultSelected(SelectionEvent e) {
		}

	}
);

	shell.open();
	while (!shell.isDisposed()) {
		if (!display.readAndDispatch()) 
			display.sleep();
	}
	display.dispose();
}

}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>The following test works on SWT-Motif and not on SWT win32.

import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.CCombo;
import org.eclipse.swt.events.*;
import org.eclipse.swt.events.MouseEvent;
import org.eclipse.swt.events.MouseMoveListener;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.*;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.widgets.*;

/**
 * Click the upper left button to see painting bug.
 */
public class SetRedrawTest {

public static void main(String args[]){
	Display display = new Display();
	final Shell shell = new Shell(display);
	
	shell.setSize(600, 600);
	shell.setLocation(100,100);

	final Button button = new Button(shell, 0);
	button.setBounds(20, 20, 100, 60);

	final Button button2 = new Button(shell, 0);
	button2.setBounds(100, 100, 100, 60);

	button.addSelectionListener(new SelectionListener() {
		public void widgetSelected(SelectionEvent e) {
			button2.setRedraw(false);
			button2.setLocation(100, 150);
			button2.setRedraw(true);
		}

		public void widgetDefaultSelected(SelectionEvent e) {
		}

	}
);

	shell.open();
	while (!shell.isDisposed()) {
		if (!display.readAndDispatch()) 
			display.sleep();
	}
	display.dispose();
}

}
When redraw is turned off, the results of moving and resizing a widget are 
undefined.  The difference between Motif and Windows is that on Motif, 
setRedraw is a hint for some widgets.
You could at least document that fact.  The current JavaDOC doesn't mention 
anything about the affects on the Control's parent, such as the expose "cheese" 
in this testcase.
reopening
Funny... my version of the same problem was "WONTFIX" :-)

*** This bug has been marked as a duplicate of 4805 ***
What?  Was this the problem you were seeing in draw2d.</WithStack>
    <WithOutStack>The following test works on SWT-Motif and not on SWT win32.

import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.CCombo;
import org.eclipse.swt.events.*;
import org.eclipse.swt.events.MouseEvent;
import org.eclipse.swt.events.MouseMoveListener;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.graphics.*;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.widgets.*;

/**
 * Click the upper left button to see painting bug.
 */
public class SetRedrawTest {

public static void main(String args[]){
	Display display = new Display();
	final Shell shell = new Shell(display);
	
	shell.setSize(600, 600);
	shell.setLocation(100,100);

	final Button button = new Button(shell, 0);
	button.setBounds(20, 20, 100, 60);

	final Button button2 = new Button(shell, 0);
	button2.setBounds(100, 100, 100, 60);

	button.addSelectionListener(new SelectionListener() {
		public void widgetSelected(SelectionEvent e) {
			button2.setRedraw(false);
			button2.setLocation(100, 150);
			button2.setRedraw(true);
		}

		public void widgetDefaultSelected(SelectionEvent e) {
		}

	}
);

	shell.open();
	while (!shell.isDisposed()) {
		if (!display.readAndDispatch()) 
			display.sleep();
	}
	display.dispose();
}

}
When redraw is turned off, the results of moving and resizing a widget are 
undefined.  The difference between Motif and Windows is that on Motif, 
setRedraw is a hint for some widgets.
You could at least document that fact.  The current JavaDOC doesn't mention 
anything about the affects on the Control's parent, such as the expose "cheese" 
in this testcase.
reopening
Funny... my version of the same problem was "WONTFIX" :-)

*** This bug has been marked as a duplicate of 4805 ***
What?  Was this the problem you were seeing in draw2d.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12357" />
    <CreationDate amount="2002-03-27 10:55:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>RemoteFile::getContents() needs to throw an exception</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Eating of exceptions they should instead be propagated.
Fixed</WithStack>
    <WithOutStack>Eating of exceptions they should instead be propagated.
Fixed</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12358" />
    <CreationDate amount="2002-03-27 10:58:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.0" />
    <rep_platform amount="Other" />
    <op_sys amount="other" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Investigate contribution of libraries to other platforms</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437330633980">
        <Exception>java.lang.UnsatisfiedLinkError</Exception>
        <Reason>GDK_EVENT_TYPE</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.internal.gtk.OS.GDK_EVENT_TYPE(Native Method)</Frame>
          <Frame depth="1">org.eclipse.swt.widgets.Display.eventProc(Display.java:1009)</Frame>
          <Frame depth="2">org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)</Frame>
          <Frame depth="3">org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:1315)</Frame>
          <Frame depth="4">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2741)</Frame>
          <Frame depth="5">org.eclipse.swt.widgets.Display.release(Display.java:2795)</Frame>
          <Frame depth="6">org.eclipse.swt.graphics.Device.dispose(Device.java:214)</Frame>
          <Frame depth="7">org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:121)</Frame>
          <Frame depth="8">org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)</Frame>
          <Frame depth="9">org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)</Frame>
          <Frame depth="10">org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:165)</Frame>
          <Frame depth="11">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="12">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="13">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="14">java.lang.reflect.Method.invoke(Method.java:585)</Frame>
          <Frame depth="15">org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)</Frame>
          <Frame depth="16">org.eclipse.core.launcher.Main.basicRun(Main.java:282)</Frame>
          <Frame depth="17">org.eclipse.core.launcher.Main.run(Main.java:977)</Frame>
          <Frame depth="18">org.eclipse.core.launcher.Main.main(Main.java:952)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="6">
      <Enumeration lines="7">
        <Lines>
          <Line>(1) setting the JNI include path to include two directories</Line>
          <Line>(I just used the quickest hack that worked)</Line>
          <Line>(2) Getting rid of the gld link option for the LIBNAME.</Line>
          <Line>(My gcc uses Sun's ld, not gld.)</Line>
          <Line>I don't like this change, but it doesn't prevent the .so</Line>
          <Line>from working.  Perhaps someone who knows gld can see</Line>
          <Line>what I should have done.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="16">
        <Lines>
          <Line>1) Select the fragment project in Navigator</Line>
          <Line>(org.eclipse.core.filesystem.linux.x86_64)</Line>
          <Line />
          <Line>2) Right click and choose Import/Export</Line>
          <Line>3) Select Export &gt; Plugin Development &gt; Deployable Plugins and Fragments</Line>
          <Line>4) Select the checkbox at the bottom, "Package plugins as individual JAR archives"</Line>
          <Line>5) Click finish.</Line>
          <Line>6) Copy the exported JAR into your install directory "eclipse/plugins".</Line>
          <Line>7) Restart with -clean argument: "eclipse -clean"</Line>
          <Line>8) Validate by creating a project and a file, and try setting the executable bit</Line>
          <Line>on the resource info property page.</Line>
          <Line>I have tested with nightly build from 11/14/2005 and the startup itself failed</Line>
          <Line>with the following error.  It looks like swt native library is not compiled</Line>
          <Line>properly.  let me know if there's any additional native libraries that requires</Line>
          <Line>recompilation for x86_64.  I'll try to take a look at other subprojects later,</Line>
          <Line>but i guess until this issue is resolved, i can't test filesystem jni calls.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="3">
        <Lines>
          <Line>- timestamp granularities are better</Line>
          <Line>- can make several calls to the OS and return all information at once</Line>
          <Line>- java.io.File.setReadOnly() does nothing</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="4">
        <Lines>
          <Line>- win32</Line>
          <Line>- linux</Line>
          <Line>- qnx</Line>
          <Line>- macosx</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="8">
        <Lines>
          <Line>- create new fragment project on eclipse.org (PMC request)</Line>
          <Line>- commit rights to project are Core committers plus person who is contributing</Line>
          <Line>and maintaining the code (webmaster request)</Line>
          <Line>- release the code to the repository</Line>
          <Line>- create new map file in org.eclipse.releng/maps</Line>
          <Line>- map file should contain the version of the project to include in the builds</Line>
          <Line>- commit rights to the map file should be the Core committers plus the code</Line>
          <Line>contributor (webmaster request)</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="3">
        <Lines>
          <Line>- fixing the bugs</Line>
          <Line>- keeping the version name of the core library up to speed</Line>
          <Line>- doing your own build submissions</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>If we don't have the library for a particular platform then we default the 
behaviour to java.io.File.

We provide platform-specific libraries for 3 reasons:
- timestamp granularities are better
- can make several calls to the OS and return all information at once
- java.io.File.setReadOnly() does nothing

We should look into compiling our libraries for other platforms now that more 
Eclipse ports are starting to become available.

Note that this also applies to ANT since we contribute the core libraries there.
Closing for now. If it becomes an issue we can look at this later but in a
perfect world we would like to not ship libraries if we don't have to.

Also note that Ant no longer contributes libraries as mentioned above.

*** Bug 31411 has been marked as a duplicate of this bug. ***
*** Bug 36315 has been marked as a duplicate of this bug. ***
Note that the Core Library is now contributed to the following platforms:
- win32
- linux
- qnx
- macosx

*** Bug 42405 has been marked as a duplicate of this bug. ***
I needed a place to put some notes so this is where I chose...
-----------------
In order to accept contributions of the Core library to other platforms, we need
the following to happen:

- create new fragment project on eclipse.org (PMC request)
- commit rights to project are Core committers plus person who is contributing
and maintaining the code (webmaster request)
- release the code to the repository
- create new map file in org.eclipse.releng/maps
- map file should contain the version of the project to include in the builds
- commit rights to the map file should be the Core committers plus the code
contributor (webmaster request)

As a person contributing a library you are responsible for:
- fixing the bugs
- keeping the version name of the core library up to speed
- doing your own build submissions

Sumit, I will send the request to the PMC to get the ball rolling for your HP-UX
contribution.
I forgot to add to the above list that we have to ensure that the project gets
added to the appropriate RelEng build files to ensure that it is included in the
build.
Sumit, the project has been created in the repository on eclipse.org.
  org.eclipse.core.resources.hpux
I believe the webmaster will contact you with login information.

I have released some initial files to the project. (fragment.xml, about.html, etc)

I have also created the map file to be used for including the project in the
build process:
  org.eclipse.releng/maps/core-hpux.map
This file should include the version tag to include in the build. (I used HEAD
for now)

*** Bug 65910 has been marked as a duplicate of this bug. ***
I originally posted bug 65910, which is about non-existent libcore for amd 64. 
since I am not running a non-supported OS, I don't know if this is really a 
new core lib that needs to be developed however.   
 
but my first thought on this is, i can understand why this probably won't be 
included in the release. 
 
having said that, i was able to use the existing core.resource.linux plugin to 
compile a shared object for amd 64 version.  i didn't look enough to figure 
out how to create a so for different architecture but same OS,  i would be 
happy to send the SO file to the owner of linux resource plugin owner. 
 
btw if i'm not mistaken, there seems to be a minor update that needs to be 
done to the make file.  it is assuming there's one jvm include dir while you 
need to include two different path. 
 
*** Bug 70686 has been marked as a duplicate of this bug. ***
For the record, I grabbed the source for
    org.eclipse.core.resources.linux
from dev.eclipse.org CVS server, and was able to create a libcore for Solaris
8/x86 with only minor changes to the Makefile. Putting this into a plugin solves
the CVS update problems I mentioned in Bug #70686.

The Makefile changes, which are not "clean" are two:
(1) setting the JNI include path to include two directories
    (I just used the quickest hack that worked)
(2) Getting rid of the gld link option for the LIBNAME.
    (My gcc uses Sun's ld, not gld.)
    I don't like this change, but it doesn't prevent the .so
    from working.  Perhaps someone who knows gld can see
    what I should have done.

The actual diff (which includes my own JDK_HOME) are:

retrieving revision 1.4
diff -c -r1.4 Makefile
*** Makefile    23 Feb 2004 22:59:22 -0000      1.4
--- Makefile    23 Jul 2004 14:52:29 -0000
***************
*** 8,13 ****
--- 8,14 ----
  #
  # makefile for libcore.so
  
+ JDK_INCLUDE = /opt/j2sdk1.4.2/include -I /opt/j2sdk1.4.2/include/solaris
  CORE.C = core.c
  CORE.O = core.o
  LIB_NAME = libcore.so
***************
*** 15,21 ****
  
  core :
        gcc -fPIC -g -c -I$(JDK_INCLUDE) $(CORE.C) -o $(CORE.O)
!       gcc -g -shared -Wl,-soname,$(LIB_NAME) -o $(LIB_NAME_FULL) $(CORE.O) -lc
  
  clean :
        rm *.o
--- 16,22 ----
  
  core :
        gcc -fPIC -g -c -I$(JDK_INCLUDE) $(CORE.C) -o $(CORE.O)
!       gcc -g -shared -o $(LIB_NAME_FULL) $(CORE.O) -lc
  
  clean :
        rm *.o
*** Bug 79020 has been marked as a duplicate of this bug. ***
I have a libcore.so for amd 64 compiled and have been using it for good 2-3 months now without a 
problem.  what's the best way to get them in the future release?

some explanation was given here as to how to submit a proposal for new project, but I don't think this 
is really a new project.  However if you do think this should be a new project, I guess you guys will have 
to decide how to handle the project naming convention since resource projects are just based on os 
right now.

Thanks
 
*** Bug 88711 has been marked as a duplicate of this bug. ***
I'm Sorry.
My searching was poor at and was not able to check.
I hope that is modified with the next release.
*** Bug 94488 has been marked as a duplicate of this bug. ***
*** Bug 97502 has been marked as a duplicate of this bug. ***
Note for those CCed on this bug: the native code from org.eclipse.core.resources
has been moved into a new plugin in Eclipse 3.2.  There is a separate bug report
for recompiling these natives in the new project: bug 111243.  I do not yet have
compiled libraries for Linux x86_64, qnx, or HPUX (ia64_32 and PA_RISC)...
volunteers to recompile on those platforms (and other supported eclipse
platforms) greatly appreciated; my ported Linux natives should compile without
further changes on all *nix platforms.
Created attachment 29583
Compiled on amd64 2.6.10-1.766_FC3

John

I am attaching the compiled filesystem library for amd64/x86_64.
It's compiled under fedora core 3 (2.6.10-1 kernel).

CPU: AMD Athlon(tm) 64 Processor 3200+
GCC: gcc version 3.4.3 20050227 (Red Hat 3.4.3-22.fc3)

Compiled with no problem but i haven't had a chance to test it.
I was trying to copy my custom built
org.eclipse.core.filesystem.linux.x86_64_1.0.0.jar which includs the compiled
file to 3.2 m3 but it doesn't seem to pick it up.  i must not have built the
jar correctly.	any suggestion on how to test this without having to rebuilt
the entire eclipse?
Created attachment 29584
localfile.o

localfile.o
Hello, I have released your contributed library, so if you cannot test manually
you can wait for the next build and test it then. Here are the steps to test
manually.

1) Select the fragment project in Navigator
(org.eclipse.core.filesystem.linux.x86_64)

2) Right click and choose Import/Export
3) Select Export &gt; Plugin Development &gt; Deployable Plugins and Fragments
4) Select the checkbox at the bottom, "Package plugins as individual JAR archives"
5) Click finish.
6) Copy the exported JAR into your install directory "eclipse/plugins".
7) Restart with -clean argument: "eclipse -clean"
8) Validate by creating a project and a file, and try setting the executable bit
on the resource info property page.
I have tested with nightly build from 11/14/2005 and the startup itself failed
with the following error.  It looks like swt native library is not compiled
properly.  let me know if there's any additional native libraries that requires
recompilation for x86_64.  I'll try to take a look at other subprojects later,
but i guess until this issue is resolved, i can't test filesystem jni calls.


!SESSION 2005-11-14 16:28:02.781 -----------------------------------------------
eclipse.buildId=N20051114-0010
java.version=1.5.0_05
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.osgi 2005-11-14 16:28:05.963
!MESSAGE Application error
!STACK 1
java.lang.UnsatisfiedLinkError: GDK_EVENT_TYPE
        at org.eclipse.swt.internal.gtk.OS.GDK_EVENT_TYPE(Native Method)
        at org.eclipse.swt.widgets.Display.eventProc(Display.java:1009)
        at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)
        at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:1315)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2741)
        at org.eclipse.swt.widgets.Display.release(Display.java:2795)
        at org.eclipse.swt.graphics.Device.dispose(Device.java:214)
        at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:121)
        at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)
        at
org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
        at
org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:165)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:282)
        at org.eclipse.core.launcher.Main.run(Main.java:977)
        at org.eclipse.core.launcher.Main.main(Main.java:952)
Nightly builds are sometimes unstable.  If you get a failure like this in the
next integration build (due tomorrow), then please enter a bug report against
Platform SWT.
Test went successfully.  I verified both read-only and executable bits get set
and stick.  I also compared to the file system permission and they were set
correctly.
Let me know if there's anything else I can help with.
Thanks Yujin, that's great to hear.
*** Bug 141008 has been marked as a duplicate of this bug. ***
*** Bug 167403 has been marked as a duplicate of this bug. ***
*** Bug 176470 has been marked as a duplicate of this bug. ***
(In reply to comment #25)
Yujin, you may be interested in hearing that I compiled an updated liblocalfile for x86_64 in order to support symbolic links. I compiled it on Redhat Enterprise Linux 5, and attached it on bug 184433. It was released for Eclipse 3.3M7.

If you still have your old system available (based on Fedora Core 3), it would be interesting to hear if the newer lib works on your system; and if not, if you could contribute a build on the old system.

Thanks!
Also see the references on bug 184534 comment 1 for newer updates of the native code for liblocalfile.
[LATER-&gt;WONTFIX] The "LATER" bugzilla resolution is being removed so reopening to mark as WONTFIX.
[LATER-&gt;WONTFIX] The "LATER" bugzilla resolution is being removed so reopening to mark as WONTFIX.</WithStack>
    <WithOutStack>If we don't have the library for a particular platform then we default the 
behaviour to java.io.File.

We provide platform-specific libraries for 3 reasons:
- timestamp granularities are better
- can make several calls to the OS and return all information at once
- java.io.File.setReadOnly() does nothing

We should look into compiling our libraries for other platforms now that more 
Eclipse ports are starting to become available.

Note that this also applies to ANT since we contribute the core libraries there.
Closing for now. If it becomes an issue we can look at this later but in a
perfect world we would like to not ship libraries if we don't have to.

Also note that Ant no longer contributes libraries as mentioned above.

*** Bug 31411 has been marked as a duplicate of this bug. ***
*** Bug 36315 has been marked as a duplicate of this bug. ***
Note that the Core Library is now contributed to the following platforms:
- win32
- linux
- qnx
- macosx

*** Bug 42405 has been marked as a duplicate of this bug. ***
I needed a place to put some notes so this is where I chose...
-----------------
In order to accept contributions of the Core library to other platforms, we need
the following to happen:

- create new fragment project on eclipse.org (PMC request)
- commit rights to project are Core committers plus person who is contributing
and maintaining the code (webmaster request)
- release the code to the repository
- create new map file in org.eclipse.releng/maps
- map file should contain the version of the project to include in the builds
- commit rights to the map file should be the Core committers plus the code
contributor (webmaster request)

As a person contributing a library you are responsible for:
- fixing the bugs
- keeping the version name of the core library up to speed
- doing your own build submissions

Sumit, I will send the request to the PMC to get the ball rolling for your HP-UX
contribution.
I forgot to add to the above list that we have to ensure that the project gets
added to the appropriate RelEng build files to ensure that it is included in the
build.
Sumit, the project has been created in the repository on eclipse.org.
  org.eclipse.core.resources.hpux
I believe the webmaster will contact you with login information.

I have released some initial files to the project. (fragment.xml, about.html, etc)

I have also created the map file to be used for including the project in the
build process:
  org.eclipse.releng/maps/core-hpux.map
This file should include the version tag to include in the build. (I used HEAD
for now)

*** Bug 65910 has been marked as a duplicate of this bug. ***
I originally posted bug 65910, which is about non-existent libcore for amd 64. 
since I am not running a non-supported OS, I don't know if this is really a 
new core lib that needs to be developed however.   
 
but my first thought on this is, i can understand why this probably won't be 
included in the release. 
 
having said that, i was able to use the existing core.resource.linux plugin to 
compile a shared object for amd 64 version.  i didn't look enough to figure 
out how to create a so for different architecture but same OS,  i would be 
happy to send the SO file to the owner of linux resource plugin owner. 
 
btw if i'm not mistaken, there seems to be a minor update that needs to be 
done to the make file.  it is assuming there's one jvm include dir while you 
need to include two different path. 
 
*** Bug 70686 has been marked as a duplicate of this bug. ***
For the record, I grabbed the source for
    org.eclipse.core.resources.linux
from dev.eclipse.org CVS server, and was able to create a libcore for Solaris
8/x86 with only minor changes to the Makefile. Putting this into a plugin solves
the CVS update problems I mentioned in Bug #70686.

The Makefile changes, which are not "clean" are two:
(1) setting the JNI include path to include two directories
    (I just used the quickest hack that worked)
(2) Getting rid of the gld link option for the LIBNAME.
    (My gcc uses Sun's ld, not gld.)
    I don't like this change, but it doesn't prevent the .so
    from working.  Perhaps someone who knows gld can see
    what I should have done.

The actual diff (which includes my own JDK_HOME) are:

retrieving revision 1.4
diff -c -r1.4 Makefile
*** Makefile    23 Feb 2004 22:59:22 -0000      1.4
--- Makefile    23 Jul 2004 14:52:29 -0000
***************
*** 8,13 ****
--- 8,14 ----
  #
  # makefile for libcore.so
  
+ JDK_INCLUDE = /opt/j2sdk1.4.2/include -I /opt/j2sdk1.4.2/include/solaris
  CORE.C = core.c
  CORE.O = core.o
  LIB_NAME = libcore.so
***************
*** 15,21 ****
  
  core :
        gcc -fPIC -g -c -I$(JDK_INCLUDE) $(CORE.C) -o $(CORE.O)
!       gcc -g -shared -Wl,-soname,$(LIB_NAME) -o $(LIB_NAME_FULL) $(CORE.O) -lc
  
  clean :
        rm *.o
--- 16,22 ----
  
  core :
        gcc -fPIC -g -c -I$(JDK_INCLUDE) $(CORE.C) -o $(CORE.O)
!       gcc -g -shared -o $(LIB_NAME_FULL) $(CORE.O) -lc
  
  clean :
        rm *.o
*** Bug 79020 has been marked as a duplicate of this bug. ***
I have a libcore.so for amd 64 compiled and have been using it for good 2-3 months now without a 
problem.  what's the best way to get them in the future release?

some explanation was given here as to how to submit a proposal for new project, but I don't think this 
is really a new project.  However if you do think this should be a new project, I guess you guys will have 
to decide how to handle the project naming convention since resource projects are just based on os 
right now.

Thanks
 
*** Bug 88711 has been marked as a duplicate of this bug. ***
I'm Sorry.
My searching was poor at and was not able to check.
I hope that is modified with the next release.
*** Bug 94488 has been marked as a duplicate of this bug. ***
*** Bug 97502 has been marked as a duplicate of this bug. ***
Note for those CCed on this bug: the native code from org.eclipse.core.resources
has been moved into a new plugin in Eclipse 3.2.  There is a separate bug report
for recompiling these natives in the new project: bug 111243.  I do not yet have
compiled libraries for Linux x86_64, qnx, or HPUX (ia64_32 and PA_RISC)...
volunteers to recompile on those platforms (and other supported eclipse
platforms) greatly appreciated; my ported Linux natives should compile without
further changes on all *nix platforms.
Created attachment 29583
Compiled on amd64 2.6.10-1.766_FC3

John

I am attaching the compiled filesystem library for amd64/x86_64.
It's compiled under fedora core 3 (2.6.10-1 kernel).

CPU: AMD Athlon(tm) 64 Processor 3200+
GCC: gcc version 3.4.3 20050227 (Red Hat 3.4.3-22.fc3)

Compiled with no problem but i haven't had a chance to test it.
I was trying to copy my custom built
org.eclipse.core.filesystem.linux.x86_64_1.0.0.jar which includs the compiled
file to 3.2 m3 but it doesn't seem to pick it up.  i must not have built the
jar correctly.	any suggestion on how to test this without having to rebuilt
the entire eclipse?
Created attachment 29584
localfile.o

localfile.o
Hello, I have released your contributed library, so if you cannot test manually
you can wait for the next build and test it then. Here are the steps to test
manually.

1) Select the fragment project in Navigator
(org.eclipse.core.filesystem.linux.x86_64)

2) Right click and choose Import/Export
3) Select Export &gt; Plugin Development &gt; Deployable Plugins and Fragments
4) Select the checkbox at the bottom, "Package plugins as individual JAR archives"
5) Click finish.
6) Copy the exported JAR into your install directory "eclipse/plugins".
7) Restart with -clean argument: "eclipse -clean"
8) Validate by creating a project and a file, and try setting the executable bit
on the resource info property page.
I have tested with nightly build from 11/14/2005 and the startup itself failed
with the following error.  It looks like swt native library is not compiled
properly.  let me know if there's any additional native libraries that requires
recompilation for x86_64.  I'll try to take a look at other subprojects later,
but i guess until this issue is resolved, i can't test filesystem jni calls.


!SESSION 2005-11-14 16:28:02.781 -----------------------------------------------
eclipse.buildId=N20051114-0010
java.version=1.5.0_05
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Command-line arguments:  -os linux -ws gtk -arch x86_64

!ENTRY org.eclipse.osgi 2005-11-14 16:28:05.963
!MESSAGE Application error
!STACK 1

Nightly builds are sometimes unstable.  If you get a failure like this in the
next integration build (due tomorrow), then please enter a bug report against
Platform SWT.
Test went successfully.  I verified both read-only and executable bits get set
and stick.  I also compared to the file system permission and they were set
correctly.
Let me know if there's anything else I can help with.
Thanks Yujin, that's great to hear.
*** Bug 141008 has been marked as a duplicate of this bug. ***
*** Bug 167403 has been marked as a duplicate of this bug. ***
*** Bug 176470 has been marked as a duplicate of this bug. ***
(In reply to comment #25)
Yujin, you may be interested in hearing that I compiled an updated liblocalfile for x86_64 in order to support symbolic links. I compiled it on Redhat Enterprise Linux 5, and attached it on bug 184433. It was released for Eclipse 3.3M7.

If you still have your old system available (based on Fedora Core 3), it would be interesting to hear if the newer lib works on your system; and if not, if you could contribute a build on the old system.

Thanks!
Also see the references on bug 184534 comment 1 for newer updates of the native code for liblocalfile.
[LATER-&gt;WONTFIX] The "LATER" bugzilla resolution is being removed so reopening to mark as WONTFIX.
[LATER-&gt;WONTFIX] The "LATER" bugzilla resolution is being removed so reopening to mark as WONTFIX.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12359" />
    <CreationDate amount="2002-03-27 11:00:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.0" />
    <rep_platform amount="Other" />
    <op_sys amount="other" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[resources] Tests and the libraries</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="ifstatement">
        <location start="1474" end="1571" />
        <code>if (CoreFileSystemLibrary.usingNatives()) {
      // run the tests which use #setReadOnly
   }</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>We need to ensure that our test suites run both with and without the core 
libraries present.

Specifically, there are tests which set the readonly flag on a file which will 
fail if using java.io.File. This failure should be expected if the library is 
not present so we need to do a check beforehand to see if we are using a 
library or default java behaviour.
Created attachment 4146
patch for core.tests.resources

Adds a guard before test cases that use IResource#setReadOnly or
CoreFileSystemLibray#setReadOnly. The guard will avoid running these tests when
there is no support for unsetting the read-only attribute of a file/directory
(i.e. there is no natives). No tests fail in the absence of natives on Windows
(will check on Linux).

There is still no-op tests that could be enabled if we added checks for natives
presence and the OS we are running on (see ...resources.regression.IFileTest).

Due to bug 34840, in order to run the tests without natives using PDE JUnit
plug-in, one must disable the natives from the Eclipse instance as well (or
from the fragment project in the workspace, if present).
Released the attached patch except for:
  FileSystemStoreTest.testCopyFile

In this test method we should not be skipping the whole method if we are not 
running with the natives, we should only skip the particular part of the test 
where we need to be read-only. So rather than:
   if (!CoreFileSystemLibrary.usingNatives())
      return;
we should be using:
   if (CoreFileSystemLibrary.usingNatives()) {
      // run the tests which use #setReadOnly
   }

Please append a patch based on HEAD for the above listed change.
Thanks.
Created attachment 4155
patch for core.tests.resources

Contains DJ's proposal and some changes to the commentary that precedes tests
that need to set resources as read-only.

Tests with no-natives also run on Linux.
Created attachment 4171
patch for org.eclipse.core.tests.resources

Sorry, wrong file...
Released to HEAD.</WithStack>
    <WithOutStack>We need to ensure that our test suites run both with and without the core 
libraries present.

Specifically, there are tests which set the readonly flag on a file which will 
fail if using java.io.File. This failure should be expected if the library is 
not present so we need to do a check beforehand to see if we are using a 
library or default java behaviour.
Created attachment 4146
patch for core.tests.resources

Adds a guard before test cases that use IResource#setReadOnly or
CoreFileSystemLibray#setReadOnly. The guard will avoid running these tests when
there is no support for unsetting the read-only attribute of a file/directory
(i.e. there is no natives). No tests fail in the absence of natives on Windows
(will check on Linux).

There is still no-op tests that could be enabled if we added checks for natives
presence and the OS we are running on (see ...resources.regression.IFileTest).

Due to bug 34840, in order to run the tests without natives using PDE JUnit
plug-in, one must disable the natives from the Eclipse instance as well (or
from the fragment project in the workspace, if present).
Released the attached patch except for:
  FileSystemStoreTest.testCopyFile

In this test method we should not be skipping the whole method if we are not 
running with the natives, we should only skip the particular part of the test 
where we need to be read-only. So rather than:
   if (!CoreFileSystemLibrary.usingNatives())
      return;
we should be using:
   if (CoreFileSystemLibrary.usingNatives()) {
      // run the tests which use #setReadOnly
   }

Please append a patch based on HEAD for the above listed change.
Thanks.
Created attachment 4155
patch for core.tests.resources

Contains DJ's proposal and some changes to the commentary that precedes tests
that need to set resources as read-only.

Tests with no-natives also run on Linux.
Created attachment 4171
patch for org.eclipse.core.tests.resources

Sorry, wrong file...
Released to HEAD.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12360" />
    <CreationDate amount="2002-03-27 11:06:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-Motif" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>TraverseEvent e.doit doesn't turn off on TabFolder</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="5">
      <source_code type="import">
        <location start="660" end="694" />
        <code>import org.eclipse.swt.widgets.*;</code>
      </source_code>
      <source_code type="import">
        <location start="695" end="720" />
        <code>import org.eclipse.swt.*;</code>
      </source_code>
      <source_code type="import">
        <location start="721" end="753" />
        <code>import org.eclipse.swt.layout.*;</code>
      </source_code>
      <source_code type="import">
        <location start="754" end="786" />
        <code>import org.eclipse.swt.events.*;</code>
      </source_code>
      <source_code type="class">
        <location start="788" end="1699" />
        <code>public class DoitBug {
	
	public static void main(String[] args) {
		final Display display = new Display();
		final Shell shell = new Shell(display);
		shell.setLayout(new FillLayout());
		
		TabFolder tabFolder = new TabFolder (shell, SWT.NULL);
		tabFolder.setLayout (new GridLayout ());
	
		Combo marginRight = new Combo (tabFolder, SWT.NONE);
		marginRight.addTraverseListener (new TraverseListener () {
			public void keyTraversed (TraverseEvent event) {
				if (event.detail == SWT.TRAVERSE_RETURN) {
					event.doit = false;
				}
			}
		});

		Button add = new Button (tabFolder, SWT.PUSH);
		add.setText ("Add");
		add.addSelectionListener(new SelectionAdapter () {
			public void widgetSelected(SelectionEvent e) {
				System.out.println ("Hit me");
			}
		});
		
		shell.setSize (200,200);
		shell.open();
		while (! shell.isDisposed()) {
			if (! display.readAndDispatch()) display.sleep();
		}
	}
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="5">
        <Lines>
          <Line>1. Run the following sample code.</Line>
          <Line>2. Click on the "Add" button. "Hit me" will be printed to the console.</Line>
          <Line>3. Click on the combo.</Line>
          <Line>4. Hit enter on the keyboard.</Line>
          <Line>5. On Windows, nothing will happen. On Motif, "Hit me" will be printed.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build: 20020321

Description: When hooking a TraverseListener onto a control on a TabFolder, 
setting e.doit = false turns off the default behaviour on Windows, but not on 
Linux. 

This behaviour is found only when there is a TabFolder as a recursive parent of 
the control. If the same controls are built on a Composite or directly on a 
shell, setting e.doit = false will turn off the default behaviour.

To see the behaviour:
1. Run the following sample code.
2. Click on the "Add" button. "Hit me" will be printed to the console.
3. Click on the combo.
4. Hit enter on the keyboard.
5. On Windows, nothing will happen. On Motif, "Hit me" will be printed.

import org.eclipse.swt.widgets.*;
import org.eclipse.swt.*;
import org.eclipse.swt.layout.*;
import org.eclipse.swt.events.*;

public class DoitBug {
	
	public static void main(String[] args) {
		final Display display = new Display();
		final Shell shell = new Shell(display);
		shell.setLayout(new FillLayout());
		
		TabFolder tabFolder = new TabFolder (shell, SWT.NULL);
		tabFolder.setLayout (new GridLayout ());
	
		Combo marginRight = new Combo (tabFolder, SWT.NONE);
		marginRight.addTraverseListener (new TraverseListener () {
			public void keyTraversed (TraverseEvent event) {
				if (event.detail == SWT.TRAVERSE_RETURN) {
					event.doit = false;
				}
			}
		});

		Button add = new Button (tabFolder, SWT.PUSH);
		add.setText ("Add");
		add.addSelectionListener(new SelectionAdapter () {
			public void widgetSelected(SelectionEvent e) {
				System.out.println ("Hit me");
			}
		});
		
		shell.setSize (200,200);
		shell.open();
		while (! shell.isDisposed()) {
			if (! display.readAndDispatch()) display.sleep();
		}
	}
}
*** Bug 8849 has been marked as a duplicate of this bug. ***
Fixed &gt; 20020503</WithStack>
    <WithOutStack>Build: 20020321

Description: When hooking a TraverseListener onto a control on a TabFolder, 
setting e.doit = false turns off the default behaviour on Windows, but not on 
Linux. 

This behaviour is found only when there is a TabFolder as a recursive parent of 
the control. If the same controls are built on a Composite or directly on a 
shell, setting e.doit = false will turn off the default behaviour.

To see the behaviour:
1. Run the following sample code.
2. Click on the "Add" button. "Hit me" will be printed to the console.
3. Click on the combo.
4. Hit enter on the keyboard.
5. On Windows, nothing will happen. On Motif, "Hit me" will be printed.

import org.eclipse.swt.widgets.*;
import org.eclipse.swt.*;
import org.eclipse.swt.layout.*;
import org.eclipse.swt.events.*;

public class DoitBug {
	
	public static void main(String[] args) {
		final Display display = new Display();
		final Shell shell = new Shell(display);
		shell.setLayout(new FillLayout());
		
		TabFolder tabFolder = new TabFolder (shell, SWT.NULL);
		tabFolder.setLayout (new GridLayout ());
	
		Combo marginRight = new Combo (tabFolder, SWT.NONE);
		marginRight.addTraverseListener (new TraverseListener () {
			public void keyTraversed (TraverseEvent event) {
				if (event.detail == SWT.TRAVERSE_RETURN) {
					event.doit = false;
				}
			}
		});

		Button add = new Button (tabFolder, SWT.PUSH);
		add.setText ("Add");
		add.addSelectionListener(new SelectionAdapter () {
			public void widgetSelected(SelectionEvent e) {
				System.out.println ("Hit me");
			}
		});
		
		shell.setSize (200,200);
		shell.open();
		while (! shell.isDisposed()) {
			if (! display.readAndDispatch()) display.sleep();
		}
	}
}
*** Bug 8849 has been marked as a duplicate of this bug. ***
Fixed &gt; 20020503</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12361" />
    <CreationDate amount="2002-03-27 11:10:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="Build" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>JDTCompiler adapter should be deprecated</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>We should investigate using the compiler adapter provided by jdt.core and 
remove the one from pde.core.
When deprecating the compiler adapter we need to change the reference from the 
pde build script generation as well.
The compiler adapter has been deprecated. Should remove before M6.

The JDTCompiler adapter has been removed. The one provided by JDT Core should 
be used instead. The new compiler adapter is called 
org.eclipse.jdt.core.JDTCompilerAdapter .
Fixed.</WithStack>
    <WithOutStack>We should investigate using the compiler adapter provided by jdt.core and 
remove the one from pde.core.
When deprecating the compiler adapter we need to change the reference from the 
pde build script generation as well.
The compiler adapter has been deprecated. Should remove before M6.

The JDTCompiler adapter has been removed. The one provided by JDT Core should 
be used instead. The new compiler adapter is called 
org.eclipse.jdt.core.JDTCompilerAdapter .
Fixed.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12362" />
    <CreationDate amount="2002-03-27 11:14:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Default keyword substitution mode for text files should be -ko not -kkv</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>Agree
Fixed.  Default ksubst for text files changed to -ko.</WithStack>
    <WithOutStack>Agree
Fixed.  Default ksubst for text files changed to -ko.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12363" />
    <CreationDate amount="2002-03-27 11:18:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Better integration of the batch compiler with ant javac task option -extdirs</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>The option -extdirs is not supported by the batch compiler. This option is used to specify a list of 
directories that contains jar files that need to be included in the classpath for the 
compilation. This is a way to significantly reduce the size of the classpath in case multiple 
libraries are used. It would be nice if the batch compiler supports all options for the javac ant 
task. That way the ant support inside eclipse would be improved.
This is a link to the 
documentation of the javac ant 
task:
http://jakarta.apache.org/ant/manual/CoreTasks/javac.html
I'm not convinced the extdirs is made for that use but I could be wrong. The 
following could solve the problem without having to change the batch compiler 
(I haven't tested though).

    &lt;classpath&gt;
      &lt;pathelement path="${classpath}"/&gt;
      &lt;fileset dir="lib"&gt;
        &lt;include name="**/*.jar"/&gt;
      &lt;/fileset&gt;
      &lt;pathelement location="classes"/&gt;
    &lt;/classpath&gt;
According to the discussion on EC, -extdirs is used to target directories that 
contain jar files for the libraries used by the code you want to compile. It is 
a good alternative to significantly reduce the size of classpaths.
For the doc of the javac ant task, I can read:
          extdirs location of installed extensions.

I don't think it is a big problem to add this in the batch compiler.
I understand your point. I was just affraid that it could be just a side 
effect. The sun javac compiler seems to define a -extdirs command line and its 
usage says:

" -extdirs &lt;dirs&gt;           Override location of installed extensions"

I am just not convinced that "installed extensions" means "put here the 
library jars you want included to your classpath". But I can be wrong.
BTW, the example above does not work (but maybe there's an alternative way).
Should be addressed when acquiring the javac ant adapter.
When do we get it?

If you're talking about the compiler adapter provided by PDE Build, anytime. 
Just let me know.
I have a prototype that needs to be more intensively tested. Need to discuss how to integrate it 
inside JDT/Core. This adapter needs the ant.jar in order to be compiled and we need to provide a jar 
with only this adapter inside.


I have added a jdtCompilerAdapter.jar file inside the org.eclipse.jdt.core plugin. The 
jdt/core plugin adds an extension point for the compiler adapter. A script has been added in the 
scripts folder. You might want to update the rt.jar file in the classpath property. Then simply 
run that script to generate the jdtCompilerAdapter.jar file from the source contained in the 
antadapter folder.
The build script refers to dependant jars needed to compile the adapter 
source.
Rodrigo, could you please check with me if everything is fine with the new extension point? If this 
is the case, I will close this PR as FIXED.
Thanks.
Fixed and released in HEAD.</WithStack>
    <WithOutStack>The option -extdirs is not supported by the batch compiler. This option is used to specify a list of 
directories that contains jar files that need to be included in the classpath for the 
compilation. This is a way to significantly reduce the size of the classpath in case multiple 
libraries are used. It would be nice if the batch compiler supports all options for the javac ant 
task. That way the ant support inside eclipse would be improved.
This is a link to the 
documentation of the javac ant 
task:
http://jakarta.apache.org/ant/manual/CoreTasks/javac.html
I'm not convinced the extdirs is made for that use but I could be wrong. The 
following could solve the problem without having to change the batch compiler 
(I haven't tested though).

    &lt;classpath&gt;
      &lt;pathelement path="${classpath}"/&gt;
      &lt;fileset dir="lib"&gt;
        &lt;include name="**/*.jar"/&gt;
      &lt;/fileset&gt;
      &lt;pathelement location="classes"/&gt;
    &lt;/classpath&gt;
According to the discussion on EC, -extdirs is used to target directories that 
contain jar files for the libraries used by the code you want to compile. It is 
a good alternative to significantly reduce the size of classpaths.
For the doc of the javac ant task, I can read:
          extdirs location of installed extensions.

I don't think it is a big problem to add this in the batch compiler.
I understand your point. I was just affraid that it could be just a side 
effect. The sun javac compiler seems to define a -extdirs command line and its 
usage says:

" -extdirs &lt;dirs&gt;           Override location of installed extensions"

I am just not convinced that "installed extensions" means "put here the 
library jars you want included to your classpath". But I can be wrong.
BTW, the example above does not work (but maybe there's an alternative way).
Should be addressed when acquiring the javac ant adapter.
When do we get it?

If you're talking about the compiler adapter provided by PDE Build, anytime. 
Just let me know.
I have a prototype that needs to be more intensively tested. Need to discuss how to integrate it 
inside JDT/Core. This adapter needs the ant.jar in order to be compiled and we need to provide a jar 
with only this adapter inside.


I have added a jdtCompilerAdapter.jar file inside the org.eclipse.jdt.core plugin. The 
jdt/core plugin adds an extension point for the compiler adapter. A script has been added in the 
scripts folder. You might want to update the rt.jar file in the classpath property. Then simply 
run that script to generate the jdtCompilerAdapter.jar file from the source contained in the 
antadapter folder.
The build script refers to dependant jars needed to compile the adapter 
source.
Rodrigo, could you please check with me if everything is fine with the new extension point? If this 
is the case, I will close this PR as FIXED.
Thanks.
Fixed and released in HEAD.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12364" />
    <CreationDate amount="2002-03-27 11:21:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.0" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>RegistryCacheReader needn't examine lastmod's</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>In 2.0 we will no longer have a separate fragments and plugins directory.  All 
fragments will appear under the plugins directory.  As a result, the 
RegistryCacheReader will be able to rely fully on the PluginsChangeStamp to 
determine if the registry cache is out-of-date.  The private method 
readAndCheckLastModified should no longer be necessary.
Private method readAndCheckLastModified has been remove along with all 
references to it.  All data relating to last modified timestamps that were 
written to the registry cache have also been removed.  Note that this caused 
the registry cache version to be incremented from 4 to 5.</WithStack>
    <WithOutStack>In 2.0 we will no longer have a separate fragments and plugins directory.  All 
fragments will appear under the plugins directory.  As a result, the 
RegistryCacheReader will be able to rely fully on the PluginsChangeStamp to 
determine if the registry cache is out-of-date.  The private method 
readAndCheckLastModified should no longer be necessary.
Private method readAndCheckLastModified has been remove along with all 
references to it.  All data relating to last modified timestamps that were 
written to the registry cache have also been removed.  Note that this caused 
the registry cache version to be incremented from 4 to 5.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12365" />
    <CreationDate amount="2002-03-27 11:30:00 -0500" />
    <DupId amount="12316" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="Other" />
    <op_sys amount="Windows 98" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Errors in log file</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437330633996">
        <Exception>org.xml.sax.SAXParseException</Exception>
        <Reason>The root element is required in a well-formed 
document.</Reason>
        <Frames>
          <Frame depth="0">org.apache.xerces.framework.XMLParser.reportError(XMLParser.java:1196)</Frame>
          <Frame depth="1">org.apache.xerces.framework.XMLDocumentScanner.reportFatalXMLError(XMLDocumentScanner.java:570)</Frame>
          <Frame depth="2">org.apache.xerces.framework.XMLDocumentScanner$XMLDeclDispatcher.endOfInput(XMLDocumentScanner.java:790)</Frame>
          <Frame depth="3">org.apache.xerces.framework.XMLDocumentScanner.endOfInput(XMLDocumentScanner.java:418)</Frame>
          <Frame depth="4">org.apache.xerces.validators.common.XMLValidator.sendEndOfInputNotifications(XMLValidator.java:694)</Frame>
          <Frame depth="5">org.apache.xerces.readers.DefaultEntityHandler.changeReaders(DefaultEntityHandler.java:1026)</Frame>
          <Frame depth="6">org.apache.xerces.readers.XMLEntityReader.changeReaders(XMLEntityReader.java:168)</Frame>
          <Frame depth="7">org.apache.xerces.readers.AbstractCharReader.changeReaders(AbstractCharReader.java:150)</Frame>
          <Frame depth="8">org.apache.xerces.readers.AbstractCharReader.lookingAtChar(AbstractCharReader.java(Compiled Code))</Frame>
          <Frame depth="9">org.apache.xerces.framework.XMLDocumentScanner$XMLDeclDispatcher.dispatch(XMLDocumentScanner.java:686)</Frame>
          <Frame depth="10">org.apache.xerces.framework.XMLDocumentScanner.parseSome(XMLDocumentScanner.java:381)</Frame>
          <Frame depth="11">org.apache.xerces.framework.XMLParser.parse(XMLParser.java:1081)</Frame>
          <Frame depth="12">org.apache.xerces.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:195)</Frame>
          <Frame depth="13">org.eclipse.debug.internal.core.LaunchConfiguration.&lt;init&gt;(LaunchConfiguration.java:84)</Frame>
          <Frame depth="14">org.eclipse.debug.internal.core.LaunchManager.getLaunchConfiguration(LaunchManager.java:919)</Frame>
          <Frame depth="15">org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationDialog.open(LaunchConfigurationDialog.java:384)</Frame>
          <Frame depth="16">org.eclipse.debug.internal.ui.actions.OpenLaunchConfigurationsAction.run(OpenLaunchConfigurationsAction.java:87)</Frame>
          <Frame depth="17">org.eclipse.jface.action.Action.runWithEvent(Action.java:473)</Frame>
          <Frame depth="18">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:407)</Frame>
          <Frame depth="19">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:361)</Frame>
          <Frame depth="20">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:352)</Frame>
          <Frame depth="21">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:47)</Frame>
          <Frame depth="22">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java(Compiled Code))</Frame>
          <Frame depth="23">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java(Compiled Code))</Frame>
          <Frame depth="24">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))</Frame>
          <Frame depth="25">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java(Compiled Code))</Frame>
          <Frame depth="26">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java(Compiled Code))</Frame>
          <Frame depth="27">org.eclipse.ui.internal.Workbench.run(Workbench.java:705)</Frame>
          <Frame depth="28">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="29">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="30">java.lang.reflect.Method.invoke(Native Method)</Frame>
          <Frame depth="31">org.eclipse.core.launcher.Main.basicRun(Main.java:196)</Frame>
          <Frame depth="32">org.eclipse.core.launcher.Main.run(Main.java:555)</Frame>
          <Frame depth="33">org.eclipse.core.launcher.UIMain.main(UIMain.java:52)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>build 2002-03-21 on Win98

Sorry, don't have reproducable steps for this. I run with Eclipse maximized and 
just noticed now that the log file wasn't empty, and there was no dialog 
telling me there was an error.

If it helps, I don't normally use Launch Configurations, but switched to them 
today (via the Preferences page), but I'm not sure if it was before or after 
the errors.

The more I write, the more vague I realize this bug report is...:-)

Log: Wed Mar 27 07:34:17 EST 2002
1 org.eclipse.core.resources 4 Unable to restore mru list - no input factory ID.
Log: Wed Mar 27 07:58:31 EST 2002
4 org.eclipse.debug.core 5013 Exception occurred parsing memento.
org.xml.sax.SAXParseException: The root element is required in a well-formed 
document.
	at org.apache.xerces.framework.XMLParser.reportError
(XMLParser.java:1196)
	at org.apache.xerces.framework.XMLDocumentScanner.reportFatalXMLError
(XMLDocumentScanner.java:570)
	at 
org.apache.xerces.framework.XMLDocumentScanner$XMLDeclDispatcher.endOfInput
(XMLDocumentScanner.java:790)
	at org.apache.xerces.framework.XMLDocumentScanner.endOfInput
(XMLDocumentScanner.java:418)
	at 
org.apache.xerces.validators.common.XMLValidator.sendEndOfInputNotifications
(XMLValidator.java:694)
	at org.apache.xerces.readers.DefaultEntityHandler.changeReaders
(DefaultEntityHandler.java:1026)
	at org.apache.xerces.readers.XMLEntityReader.changeReaders
(XMLEntityReader.java:168)
	at org.apache.xerces.readers.AbstractCharReader.changeReaders
(AbstractCharReader.java:150)
	at org.apache.xerces.readers.AbstractCharReader.lookingAtChar
(AbstractCharReader.java(Compiled Code))
	at 
org.apache.xerces.framework.XMLDocumentScanner$XMLDeclDispatcher.dispatch
(XMLDocumentScanner.java:686)
	at org.apache.xerces.framework.XMLDocumentScanner.parseSome
(XMLDocumentScanner.java:381)
	at org.apache.xerces.framework.XMLParser.parse(XMLParser.java:1081)
	at org.apache.xerces.jaxp.DocumentBuilderImpl.parse
(DocumentBuilderImpl.java:195)
	at org.eclipse.debug.internal.core.LaunchConfiguration.&lt;init&gt;
(LaunchConfiguration.java:84)
	at org.eclipse.debug.internal.core.LaunchManager.getLaunchConfiguration
(LaunchManager.java:919)
	at 
org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationDialog.ope
n(LaunchConfigurationDialog.java:384)
	at 
org.eclipse.debug.internal.ui.actions.OpenLaunchConfigurationsAction.run
(OpenLaunchConfigurationsAction.java:87)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:407)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:361)
	at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:352)
	at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:47)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java
(Compiled Code))
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java(Compiled 
Code))
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java
(Compiled Code))
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java
(Compiled Code))
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java
(Compiled Code))
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:705)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at java.lang.reflect.Method.invoke(Native Method)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:196)
	at org.eclipse.core.launcher.Main.run(Main.java:555)
	at org.eclipse.core.launcher.UIMain.main(UIMain.java:52)


*** This bug has been marked as a duplicate of 12316 ***</WithStack>
    <WithOutStack>build 2002-03-21 on Win98

Sorry, don't have reproducable steps for this. I run with Eclipse maximized and 
just noticed now that the log file wasn't empty, and there was no dialog 
telling me there was an error.

If it helps, I don't normally use Launch Configurations, but switched to them 
today (via the Preferences page), but I'm not sure if it was before or after 
the errors.

The more I write, the more vague I realize this bug report is...:-)

Log: Wed Mar 27 07:34:17 EST 2002
1 org.eclipse.core.resources 4 Unable to restore mru list - no input factory ID.
Log: Wed Mar 27 07:58:31 EST 2002
4 org.eclipse.debug.core 5013 Exception occurred parsing memento.



*** This bug has been marked as a duplicate of 12316 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12366" />
    <CreationDate amount="2002-03-27 11:30:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Decorator cache consistency problems after deleting / reloading a project</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Turn the decorators on.
Checkout a project on a branch.
Notice the branch name is shown in the decorated label text.
Delete the project from the filesystem.
Checkout the same project from HEAD.
Notice the old branch name is still shown (should be blank).
Can't reproduce with current build: 20020321 with latest team code from HEAD.

Is this still a problem? The delete should clear the deco cache.
Seen it on 20020321, but not with latest from HEAD.

closing assumed fixed</WithStack>
    <WithOutStack>Turn the decorators on.
Checkout a project on a branch.
Notice the branch name is shown in the decorated label text.
Delete the project from the filesystem.
Checkout the same project from HEAD.
Notice the old branch name is still shown (should be blank).
Can't reproduce with current build: 20020321 with latest team code from HEAD.

Is this still a problem? The delete should clear the deco cache.
Seen it on 20020321, but not with latest from HEAD.

closing assumed fixed</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12367" />
    <CreationDate amount="2002-03-27 11:34:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="minor" />
    <Summery>[CVS Repo View] "Define Branch Tag" confusing?</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>In the CVS repo view.
I am concerned people will think its doing more than it is.

Perhaps, "Add Branch Tag", since all you are doing is adding it to the view?
There is now an Add to Branch on a root remote folder.</WithStack>
    <WithOutStack>In the CVS repo view.
I am concerned people will think its doing more than it is.

Perhaps, "Add Branch Tag", since all you are doing is adding it to the view?
There is now an Add to Branch on a root remote folder.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12368" />
    <CreationDate amount="2002-03-27 11:57:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>-D vm parameter does not get passed to JUnit.</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>I specifiy a vm parameter and run my program as 'JUnit', using the JUnit 
pluging supplied. The test program does not get access to the vm parameter.

If I run as an 'application' my application can access the vm parameters.

I am using build 321, with JDK 1.3 (sun), on windows 2k pro.

cheers.
JP.
VM parameters are supported in the new launch configuration support in 0321.
Pls try again using launch configurations (see Preferences&gt;Debug) and reopen 
the bug when the problem still exists with launch configurations.</WithStack>
    <WithOutStack>I specifiy a vm parameter and run my program as 'JUnit', using the JUnit 
pluging supplied. The test program does not get access to the vm parameter.

If I run as an 'application' my application can access the vm parameters.

I am using build 321, with JDK 1.3 (sun), on windows 2k pro.

cheers.
JP.
VM parameters are supported in the new launch configuration support in 0321.
Pls try again using launch configurations (see Preferences&gt;Debug) and reopen 
the bug when the problem still exists with launch configurations.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12369" />
    <CreationDate amount="2002-03-27 12:58:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>"Error setting nature org.eclipse.team.cvs.core.cvsnature"</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="2">
      <Enumeration lines="6">
        <Lines>
          <Line>a) The CVS server's URL is:</Line>
          <Line />
          <Line>:pserver:anoncvs@cvs.apache.org:/home/cvspublic</Line>
          <Line />
          <Line>b) The username &amp; password are both "anoncvs" (this account is for</Line>
          <Line>anonymous connections).</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="31">
        <Lines>
          <Line>1) Create a java project. I'll name it "xmlc" in this report.</Line>
          <Line />
          <Line>2) Create a new CVS repository connection, pointing to apache's CVS server.</Line>
          <Line />
          <Line>a) The CVS server's URL is:</Line>
          <Line />
          <Line>:pserver:anoncvs@cvs.apache.org:/home/cvspublic</Line>
          <Line />
          <Line>b) The username &amp; password are both "anoncvs" (this account is for</Line>
          <Line>anonymous connections).</Line>
          <Line />
          <Line>3) Expand the connection in the "CVS Repositories" view.</Line>
          <Line />
          <Line>4) Expand "HEAD".</Line>
          <Line />
          <Line>5) Expand "xml-commons".</Line>
          <Line />
          <Line>6) Expand "java".</Line>
          <Line />
          <Line>7) Expand "external".</Line>
          <Line />
          <Line>8) Right-click on "src". Choose "Check out as...". Type "xmlc" in the edit-box.</Line>
          <Line />
          <Line>9) Click "OK" in the message-box that warns you about overwriting.</Line>
          <Line />
          <Line>10) Wait. The message will be displayed after all sources have been checked out.</Line>
          <Line>Peter Burka got this yesterday when I was in his office. It happened on two</Line>
          <Line>successive projects that he was trying to "Share Project" on, but it didn't</Line>
          <Line>happen on the third.</Line>
          <Line>I can't see the site in question from behind our firewall, but attempting</Line>
          <Line>similar steps on M4 seems ok.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>Using the 20020326 integration build.
Message is displayed when checking out a project into an existing java project.

Steps to re-create:

1) Create a java project. I'll name it "xmlc" in this report.

2) Create a new CVS repository connection, pointing to apache's CVS server.

   a) The CVS server's URL is:

      :pserver:anoncvs@cvs.apache.org:/home/cvspublic

   b) The username &amp; password are both "anoncvs" (this account is for
      anonymous connections).

3) Expand the connection in the "CVS Repositories" view.

4) Expand "HEAD".

5) Expand "xml-commons".

6) Expand "java".

7) Expand "external".

8) Right-click on "src". Choose "Check out as...". Type "xmlc" in the edit-box.

9) Click "OK" in the message-box that warns you about overwriting.

10) Wait. The message will be displayed after all sources have been checked out.
Peter Burka got this yesterday when I was in his office. It happened on two
successive projects that he was trying to "Share Project" on, but it didn't
happen on the third.
I can't see the site in question from behind our firewall, but attempting 
similar steps on M4 seems ok.

The curious item is the fact that the project was created locally first, then 
the repo location was created in the Repo view and a "checkout as" was 
performed from there over the existing project.  This sequence should work, but 
we don't usually do/test.
This will happen when checking out any project that doesn't have a .project file
in it. In setProjectDescription(), core checks if the .project file exists. If
it doesn't, they throw an exception. I'll talk to John about this.
I think Core decided they were going to just write it to the log instead of 
throwing an exception.
*** Bug 11580 has been marked as a duplicate of this bug. ***
Exception still being thrown as of I20020404
Fixed
Verified.</WithStack>
    <WithOutStack>Using the 20020326 integration build.
Message is displayed when checking out a project into an existing java project.

Steps to re-create:

1) Create a java project. I'll name it "xmlc" in this report.

2) Create a new CVS repository connection, pointing to apache's CVS server.

   a) The CVS server's URL is:

      :pserver:anoncvs@cvs.apache.org:/home/cvspublic

   b) The username &amp; password are both "anoncvs" (this account is for
      anonymous connections).

3) Expand the connection in the "CVS Repositories" view.

4) Expand "HEAD".

5) Expand "xml-commons".

6) Expand "java".

7) Expand "external".

8) Right-click on "src". Choose "Check out as...". Type "xmlc" in the edit-box.

9) Click "OK" in the message-box that warns you about overwriting.

10) Wait. The message will be displayed after all sources have been checked out.
Peter Burka got this yesterday when I was in his office. It happened on two
successive projects that he was trying to "Share Project" on, but it didn't
happen on the third.
I can't see the site in question from behind our firewall, but attempting 
similar steps on M4 seems ok.

The curious item is the fact that the project was created locally first, then 
the repo location was created in the Repo view and a "checkout as" was 
performed from there over the existing project.  This sequence should work, but 
we don't usually do/test.
This will happen when checking out any project that doesn't have a .project file
in it. In setProjectDescription(), core checks if the .project file exists. If
it doesn't, they throw an exception. I'll talk to John about this.
I think Core decided they were going to just write it to the log instead of 
throwing an exception.
*** Bug 11580 has been marked as a duplicate of this bug. ***
Exception still being thrown as of I20020404
Fixed
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12370" />
    <CreationDate amount="2002-03-27 13:03:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Update  (deprecated - use RT&gt;Equinox&gt;p2)" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Inconsistent verification prompts</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="9">
        <Lines>
          <Line>1) distinguished: IVerificationResult.isFeatureVerification(boolean)</Line>
          <Line>2) Dialog: fixed based on #1</Line>
          <Line>3) resequence: fixed</Line>
          <Line>4) data archive: fixed. JarVerifier is now an instance variable of</Line>
          <Line>ContentProvider instead of beeing created all the time so the state is preserved</Line>
          <Line>(was a bug)</Line>
          <Line>5) other archive: fixed, the dialog didn't know about the new verification</Line>
          <Line>result: TYPE_ENTRY_UNRECOGNIZED. If this result occurs, the dialog will not</Line>
          <Line>prompt and we will install</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>20020321 M4, Win2K

When verifying a feature, the resulting prompts are still confusing and 
inconsistent. Am attaching a test site that includes &lt;data&gt; archives and use of 
install handler. Have noticed several areas we need to improve:

* need to distinguish verification prompts of the feature and the plugin/data 
entries. There is a difference to the user whether the whole thing (feature) has 
some problems with it, or just a piece of it (file)

* in the feature prompt, the text should be
----------------------------------------------------------
You are about to install an unsigned feature.

This feature has not been digitally signed.
The provider of this feature cannot be verified.
Installing this feature may corrupt your installation.
-----------------------------------------------------------
(also note punctuation)
The choices are OK (Install Feature/ Cancel Feature Installation)

* in the plugin/data file prompt, the text should be
----------------------------------------------------------
The feature contains an unsigned file.

This feature file has not been digitally signed.
The provider of this file cannot be verified.
Continuing to install this feature may corrupt your installation.
-----------------------------------------------------------

The choices should be
o Continue Installing Feature
o Cancel Feature Installation)

* same treatment needs to happen for the other possible verification results. 
Need to distinguish between the feature and its component files.

* resequence the standard info block
Feature Name: &lt;--- from feature.xml
Feature Identifier: &lt;--- from feature.xml
File Identifier: &lt;--- file being verified
File Provider: &lt;--- certificate information (not provider from feature.xml)

If you think it is useful, we can also have
Feature Provider: &lt;--- from feature.xml
(shown after Feature Identifier)

* when installing a &lt;data&gt; archive, the install handler calls the verifier 
supplied by the feature content provider. I get an "unsigned file" prompt aven 
though the same prompt for the &lt;plugin&gt; archive was suppressed. We need to make 
this work for verification triggered by the install handler as well.

* when attempting to verify a non-jar file by calling the verifier provided by 
the feature content consumer, I get a prompt that is missing all the text
Created attachment 524
Test Red Dot site with install handler
Note: the attachment is a .jar file. Unzip it into a new site directory.

CORRECTION: ******************************************
The comment above about Feature Provider/ File Provider is bogus. The 
resequenced block should be:


Feature Name: &lt;--- from feature.xml
Feature Identifier: &lt;--- from feature.xml
Feature Provider: &lt;--- from feature.xml
File Identifier: &lt;--- file being verified

(ie. file contained within feature, so show it that way (file last)).

The certificate information is handled as additional fields when a feature or 
one of its plugin/data entries are signed
1) distinguished: IVerificationResult.isFeatureVerification(boolean)
2) Dialog: fixed based on #1
3) resequence: fixed
4) data archive: fixed. JarVerifier is now an instance variable of
ContentProvider instead of beeing created all the time so the state is preserved
(was a bug)
5) other archive: fixed, the dialog didn't know about the new verification
result: TYPE_ENTRY_UNRECOGNIZED. If this result occurs, the dialog will not
prompt and we will install</WithStack>
    <WithOutStack>20020321 M4, Win2K

When verifying a feature, the resulting prompts are still confusing and 
inconsistent. Am attaching a test site that includes &lt;data&gt; archives and use of 
install handler. Have noticed several areas we need to improve:

* need to distinguish verification prompts of the feature and the plugin/data 
entries. There is a difference to the user whether the whole thing (feature) has 
some problems with it, or just a piece of it (file)

* in the feature prompt, the text should be
----------------------------------------------------------
You are about to install an unsigned feature.

This feature has not been digitally signed.
The provider of this feature cannot be verified.
Installing this feature may corrupt your installation.
-----------------------------------------------------------
(also note punctuation)
The choices are OK (Install Feature/ Cancel Feature Installation)

* in the plugin/data file prompt, the text should be
----------------------------------------------------------
The feature contains an unsigned file.

This feature file has not been digitally signed.
The provider of this file cannot be verified.
Continuing to install this feature may corrupt your installation.
-----------------------------------------------------------

The choices should be
o Continue Installing Feature
o Cancel Feature Installation)

* same treatment needs to happen for the other possible verification results. 
Need to distinguish between the feature and its component files.

* resequence the standard info block
Feature Name: &lt;--- from feature.xml
Feature Identifier: &lt;--- from feature.xml
File Identifier: &lt;--- file being verified
File Provider: &lt;--- certificate information (not provider from feature.xml)

If you think it is useful, we can also have
Feature Provider: &lt;--- from feature.xml
(shown after Feature Identifier)

* when installing a &lt;data&gt; archive, the install handler calls the verifier 
supplied by the feature content provider. I get an "unsigned file" prompt aven 
though the same prompt for the &lt;plugin&gt; archive was suppressed. We need to make 
this work for verification triggered by the install handler as well.

* when attempting to verify a non-jar file by calling the verifier provided by 
the feature content consumer, I get a prompt that is missing all the text
Created attachment 524
Test Red Dot site with install handler
Note: the attachment is a .jar file. Unzip it into a new site directory.

CORRECTION: ******************************************
The comment above about Feature Provider/ File Provider is bogus. The 
resequenced block should be:


Feature Name: &lt;--- from feature.xml
Feature Identifier: &lt;--- from feature.xml
Feature Provider: &lt;--- from feature.xml
File Identifier: &lt;--- file being verified

(ie. file contained within feature, so show it that way (file last)).

The certificate information is handled as additional fields when a feature or 
one of its plugin/data entries are signed
1) distinguished: IVerificationResult.isFeatureVerification(boolean)
2) Dialog: fixed based on #1
3) resequence: fixed
4) data archive: fixed. JarVerifier is now an instance variable of
ContentProvider instead of beeing created all the time so the state is preserved
(was a bug)
5) other archive: fixed, the dialog didn't know about the new verification
result: TYPE_ENTRY_UNRECOGNIZED. If this result occurs, the dialog will not
prompt and we will install</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12371" />
    <CreationDate amount="2002-03-27 13:21:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="minor" />
    <Summery>Ordering of CVS Team menu ops needs improvement</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>I find the ordering of the CVS Team menu ops on a project, folder and file to 
be a bit arbitrary.  Frequently selected items should be higher than infrequent 
ones, and the groupings aren't intuitive.

For files, the two groups seem a bit arbitrary:
- "Sync, Commit, Update" should probably be together perhaps in their own 
group.  Maybe "Create Patch" can go in there since its the non-commit-rights 
version of commit.

- "Add to .cvsignore" is in the first set but is infrequent and should appear 
at the end.  In fact, "Add to .cvsignore", "Add to Version Control", "Set 
Keyword" could be in one group at the bottom because they are infrequent.

- Don't know where we then put "Tag" and "Show in Resource History"

Synchronize with Repository
Commit
Update
Patch
--------------
Show in Resource History
Tag as Version
Branch (future)
Merge (future)
--------------
Add to Version Control
Add to .cvsignore
Set Keyword Substitution Mode


For Projects, perhaps:

Synchronize with Repository
Commit
Update
Patch
--------------
Tag as Version
Branch
Merge
--------------
Set Keyword Substitution Mode
--------------
Share Project
Disconnect


"Set Keyword Substitution Mode" looks kind of lonely in its own group, not sure 
where else to put it.
Done; I like the ordering much more now.</WithStack>
    <WithOutStack>I find the ordering of the CVS Team menu ops on a project, folder and file to 
be a bit arbitrary.  Frequently selected items should be higher than infrequent 
ones, and the groupings aren't intuitive.

For files, the two groups seem a bit arbitrary:
- "Sync, Commit, Update" should probably be together perhaps in their own 
group.  Maybe "Create Patch" can go in there since its the non-commit-rights 
version of commit.

- "Add to .cvsignore" is in the first set but is infrequent and should appear 
at the end.  In fact, "Add to .cvsignore", "Add to Version Control", "Set 
Keyword" could be in one group at the bottom because they are infrequent.

- Don't know where we then put "Tag" and "Show in Resource History"

Synchronize with Repository
Commit
Update
Patch
--------------
Show in Resource History
Tag as Version
Branch (future)
Merge (future)
--------------
Add to Version Control
Add to .cvsignore
Set Keyword Substitution Mode


For Projects, perhaps:

Synchronize with Repository
Commit
Update
Patch
--------------
Tag as Version
Branch
Merge
--------------
Set Keyword Substitution Mode
--------------
Share Project
Disconnect


"Set Keyword Substitution Mode" looks kind of lonely in its own group, not sure 
where else to put it.
Done; I like the ordering much more now.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12372" />
    <CreationDate amount="2002-03-27 13:26:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="Build" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>buildScriptGenerator forces to supply -dev parameter in the command line</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="8">
        <Lines>
          <Line>1. Create a simple plugin using the default code generator</Line>
          <Line>2. release it to a repository</Line>
          <Line>3. run eclipse headlessly from commandline to fetch the project from cvs,</Line>
          <Line>4. run eclipse headlessly to generate build scripts with a command like this:</Line>
          <Line>java -cp startup.jar org.eclipse.core.launcher.Main -data D:\eclipse0325</Line>
          <Line>\eclipse\workspace6 -application org.eclipse.pde.core.buildScript -elements</Line>
          <Line>plugin@com.ibm.ive.myPlugin -install D:\eclipse0325\eclipse\test -pluginpath</Line>
          <Line>file:/D:/eclipse0325/eclipse/test/plugins/</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>When running eclipse headlessly, buildScript application needs the "-dev " 
parameter inorder to generate scripts for a plugin. Otherwise a null pointer 
exception happens. 

STEPS :
1. Create a simple plugin using the default code generator
2. release it to a repository
3. run eclipse headlessly from commandline to fetch the project from cvs,
4. run eclipse headlessly to generate build scripts with a command like this: 
 java -cp startup.jar org.eclipse.core.launcher.Main -data D:\eclipse0325
\eclipse\workspace6 -application org.eclipse.pde.core.buildScript -elements 
plugin@com.ibm.ive.myPlugin -install D:\eclipse0325\eclipse\test -pluginpath 
file:/D:/eclipse0325/eclipse/test/plugins/

NOTICE: The build stops because of a null pointer exception in the class: 
org.eclipse.pde.internal.core.AbstractBuildScriptGenerator.setDevEntr
ies(AbstractBuildScriptGenerator.java:171)
If you supply a -dev parameter in the command for the build script generator, 
and even a bogus location, it will run.  

NOTES:
I am not sure if this is a bug. Am I missing something? Am I really supposed to 
add a -dev parameter to the command line? Shouldn't -pluginpath be sufficient 
for this case?
The code that produced the NPE does not exist anymore. The bug is now obsolete.
Closing.</WithStack>
    <WithOutStack>When running eclipse headlessly, buildScript application needs the "-dev " 
parameter inorder to generate scripts for a plugin. Otherwise a null pointer 
exception happens. 

STEPS :
1. Create a simple plugin using the default code generator
2. release it to a repository
3. run eclipse headlessly from commandline to fetch the project from cvs,
4. run eclipse headlessly to generate build scripts with a command like this: 
 java -cp startup.jar org.eclipse.core.launcher.Main -data D:\eclipse0325
\eclipse\workspace6 -application org.eclipse.pde.core.buildScript -elements 
plugin@com.ibm.ive.myPlugin -install D:\eclipse0325\eclipse\test -pluginpath 
file:/D:/eclipse0325/eclipse/test/plugins/

NOTICE: The build stops because of a null pointer exception in the class: 
org.eclipse.pde.internal.core.AbstractBuildScriptGenerator.setDevEntr
ies(AbstractBuildScriptGenerator.java:171)
If you supply a -dev parameter in the command for the build script generator, 
and even a bogus location, it will run.  

NOTES:
I am not sure if this is a bug. Am I missing something? Am I really supposed to 
add a -dev parameter to the command line? Shouldn't -pluginpath be sufficient 
for this case?
The code that produced the NPE does not exist anymore. The bug is now obsolete.
Closing.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12373" />
    <CreationDate amount="2002-03-27 13:30:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Assert$AssertionFailedException error while reconciling</Summery>
    <Patches amount="0" />
    <Stacktraces amount="2">
      <Stacktrace timestamp="1437330633996">
        <Exception>org.eclipse.swt.SWTException</Exception>
        <Reason>Failed to execute runnable 
(org.eclipse.jface.util.Assert$AssertionFailedException: assertion failed; )</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.SWT.error(SWT.java:1887)</Frame>
          <Frame depth="1">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:96)</Frame>
          <Frame depth="2">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1397)</Frame>
          <Frame depth="3">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1211)</Frame>
          <Frame depth="4">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)</Frame>
          <Frame depth="5">org.eclipse.ui.internal.Workbench.run(Workbench.java:738)</Frame>
          <Frame depth="6">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="7">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="8">EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437330633996">
        <Exception>org.eclipse.jface.util.Assert$AssertionFailedException</Exception>
        <Reason>assertion failed;</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.jface.util.Assert.isTrue(Assert.java:162)</Frame>
          <Frame depth="1">org.eclipse.jface.util.Assert.isTrue(Assert.java:148)</Frame>
          <Frame depth="2">org.eclipse.jface.text.Position.&lt;init&gt;(Position.java:52)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.ui.javaeditor.ProblemPosition.&lt;init&gt;(ProblemPosition.java:23)</Frame>
          <Frame depth="4">org.eclipse.jdt.internal.ui.javaeditor.ProblemPainter.setProblems(ProblemPainter.java:63)</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.ui.javaeditor.ProblemPainter.updateProblems(ProblemPainter.java:73)</Frame>
          <Frame depth="6">org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$3.run(CompilationUnitEditor.java:1245)</Frame>
          <Frame depth="7">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:29)</Frame>
          <Frame depth="8">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:93)</Frame>
          <Frame depth="9">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1397)</Frame>
          <Frame depth="10">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1211)</Frame>
          <Frame depth="11">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)</Frame>
          <Frame depth="12">org.eclipse.ui.internal.Workbench.run(Workbench.java:738)</Frame>
          <Frame depth="13">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="14">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="15">EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="3">
      <source_code type="package">
        <location start="402" end="413" />
        <code>package p5;</code>
      </source_code>
      <source_code type="import">
        <location start="414" end="427" />
        <code>import p3.Z;</code>
      </source_code>
      <source_code type="class">
        <location start="429" end="456" />
        <code>public class U extends {

}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build 20020326

Sorry no steps to reproduce.

org.eclipse.swt.SWTException: Failed to execute runnable 
(org.eclipse.jface.util.Assert$AssertionFailedException: assertion failed; )
	at org.eclipse.swt.SWT.error(SWT.java:1887)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:96)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1397)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1211)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:738)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)
*** Stack trace of contained exception ***
org.eclipse.jface.util.Assert$AssertionFailedException: assertion failed; 
	at org.eclipse.jface.util.Assert.isTrue(Assert.java:162)
	at org.eclipse.jface.util.Assert.isTrue(Assert.java:148)
	at org.eclipse.jface.text.Position.&lt;init&gt;(Position.java:52)
	at org.eclipse.jdt.internal.ui.javaeditor.ProblemPosition.&lt;init&gt;
(ProblemPosition.java:23)
	at org.eclipse.jdt.internal.ui.javaeditor.ProblemPainter.setProblems
(ProblemPainter.java:63)
	at org.eclipse.jdt.internal.ui.javaeditor.ProblemPainter.updateProblems
(ProblemPainter.java:73)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$3.run
(CompilationUnitEditor.java:1245)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:29)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:93)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1397)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1211)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:738)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)
The problem indicates that the core delivered an IProblem with a negative 
length. Introduced guard code that sets the length to 0 in this case. Moving to 
JDT core for investigation.
We have several hundred different problems, so will wait for a test case before 
taking further action. 
Found a test case:

[
package p5;

import p3.Z;

public class U extends {

}
]
Due to bug 12674, some extra problems were found, from the source type 
converter generated ASTs, where type reference source end could be incorrect.

Fixed both issues.</WithStack>
    <WithOutStack>Build 20020326

Sorry no steps to reproduce.


*** Stack trace of contained exception ***

The problem indicates that the core delivered an IProblem with a negative 
length. Introduced guard code that sets the length to 0 in this case. Moving to 
JDT core for investigation.
We have several hundred different problems, so will wait for a test case before 
taking further action. 
Found a test case:

[
package p5;

import p3.Z;

public class U extends {

}
]
Due to bug 12674, some extra problems were found, from the source type 
converter generated ASTs, where type reference source end could be incorrect.

Fixed both issues.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12374" />
    <CreationDate amount="2002-03-27 13:40:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>NPE in ResultCollector</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437330633996">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.jdt.internal.ui.text.java.ResultCollector.createMethodCompletion(ResultCollector.java:317)</Frame>
          <Frame depth="1">org.eclipse.jdt.internal.ui.text.java.ResultCollector.createMethodCallCompletion(ResultCollector.java:329)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.ui.text.java.ResultCollector.acceptMethod(ResultCollector.java:205)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.core.CompletionRequestorWrapper.acceptMethod(CompletionRequestorWrapper.java:178)</Frame>
          <Frame depth="4">org.eclipse.jdt.internal.codeassist.CompletionEngine.findLocalMethods(CompletionEngine.java:1675)</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.codeassist.CompletionEngine.findIntefacesMethods(CompletionEngine.java:1457)</Frame>
          <Frame depth="6">org.eclipse.jdt.internal.codeassist.CompletionEngine.findMethods(CompletionEngine.java:1898)</Frame>
          <Frame depth="7">org.eclipse.jdt.internal.codeassist.CompletionEngine.findFieldsAndMethods(CompletionEngine.java:1195)</Frame>
          <Frame depth="8">org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:352)</Frame>
          <Frame depth="9">org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:806)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:113)</Frame>
          <Frame depth="11">org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:84)</Frame>
          <Frame depth="12">org.eclipse.jdt.internal.ui.text.java.JavaCompletionProcessor.computeCompletionProposals(JavaCompletionProcessor.java:340)</Frame>
          <Frame depth="13">org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1197)</Frame>
          <Frame depth="14">org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:103)</Frame>
          <Frame depth="15">org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$3(CompletionProposalPopup.java:102)</Frame>
          <Frame depth="16">org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:71)</Frame>
          <Frame depth="17">org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)</Frame>
          <Frame depth="18">org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:66)</Frame>
          <Frame depth="19">org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1132)</Frame>
          <Frame depth="20">org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$InternalSourceViewer.doOperation(CompilationUnitEditor.java:152)</Frame>
          <Frame depth="21">org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:61)</Frame>
          <Frame depth="22">org.eclipse.ui.texteditor.RetargetTextEditorAction.run(RetargetTextEditorAction.java:103)</Frame>
          <Frame depth="23">org.eclipse.jface.action.Action.runWithEvent(Action.java:473)</Frame>
          <Frame depth="24">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:407)</Frame>
          <Frame depth="25">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java(Compiled Code))</Frame>
          <Frame depth="26">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java(Compiled Code))</Frame>
          <Frame depth="27">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java(Compiled Code))</Frame>
          <Frame depth="28">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java(Compiled Code))</Frame>
          <Frame depth="29">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java(Compiled Code))</Frame>
          <Frame depth="30">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))</Frame>
          <Frame depth="31">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java(Compiled Code))</Frame>
          <Frame depth="32">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java(Compiled Code))</Frame>
          <Frame depth="33">org.eclipse.ui.internal.Workbench.run(Workbench.java:705)</Frame>
          <Frame depth="34">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="35">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="36">java.lang.reflect.Method.invoke(Native Method)</Frame>
          <Frame depth="37">org.eclipse.core.launcher.Main.basicRun(Main.java:196)</Frame>
          <Frame depth="38">org.eclipse.core.launcher.Main.run(Main.java:555)</Frame>
          <Frame depth="39">org.eclipse.core.launcher.Main.main(Main.java:396)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>0321 Stable Win32

I was typing in the editor when an Internal Error pop-up appeared:
java.lang.NullPointerException
	at 
org.eclipse.jdt.internal.ui.text.java.ResultCollector.createMethodCompletion
(ResultCollector.java:317)
	at 
org.eclipse.jdt.internal.ui.text.java.ResultCollector.createMethodCallCompletio
n(ResultCollector.java:329)
	at org.eclipse.jdt.internal.ui.text.java.ResultCollector.acceptMethod
(ResultCollector.java:205)
	at 
org.eclipse.jdt.internal.core.CompletionRequestorWrapper.acceptMethod
(CompletionRequestorWrapper.java:178)
	at 
org.eclipse.jdt.internal.codeassist.CompletionEngine.findLocalMethods
(CompletionEngine.java:1675)
	at 
org.eclipse.jdt.internal.codeassist.CompletionEngine.findIntefacesMethods
(CompletionEngine.java:1457)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.findMethods
(CompletionEngine.java:1898)
	at 
org.eclipse.jdt.internal.codeassist.CompletionEngine.findFieldsAndMethods
(CompletionEngine.java:1195)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete
(CompletionEngine.java:352)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete
(CompletionEngine.java:806)
	at org.eclipse.jdt.internal.core.Openable.codeComplete
(Openable.java:113)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete
(CompilationUnit.java:84)
	at 
org.eclipse.jdt.internal.ui.text.java.JavaCompletionProcessor.computeCompletion
Proposals(JavaCompletionProcessor.java:340)
	at 
org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposal
s(ContentAssistant.java:1197)
	at 
org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals
(CompletionProposalPopup.java:103)
	at 
org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$3
(CompletionProposalPopup.java:102)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run
(CompletionProposalPopup.java:71)
	at org.eclipse.swt.custom.BusyIndicator.showWhile
(BusyIndicator.java:56)
	at 
org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals
(CompletionProposalPopup.java:66)
	at 
org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions
(ContentAssistant.java:1132)
	at 
org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$InternalSourceView
er.doOperation(CompilationUnitEditor.java:152)
	at org.eclipse.ui.texteditor.TextOperationAction.run
(TextOperationAction.java:61)
	at org.eclipse.ui.texteditor.RetargetTextEditorAction.run
(RetargetTextEditorAction.java:103)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at 
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:407)
	at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java(Compiled Code))
	at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java(Compiled Code))
	at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java(Compiled Code))
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java
(Compiled Code))
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java(Compiled 
Code))
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java
(Compiled Code))
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java
(Compiled Code))
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java
(Compiled Code))
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:705)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at java.lang.reflect.Method.invoke(Native Method)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:196)
	at org.eclipse.core.launcher.Main.run(Main.java:555)
	at org.eclipse.core.launcher.Main.main(Main.java:396)
not clear whether this in the code assist UI or whether we are getting an 
incorrect completion proposal.
Added guards to ResultCollector. However, the information passed into the 
result collector should not be null. Moving to JDT core.
Could be a #sourceName() from a type binding (problem one?) ?
method.returnType.qualifiedSourceName() inside 
CompletionEngine#findLocalMethods return null

I can not reproduce this problem and guards was added to ResultCollector.

Later.
The problem occur when the return type of a binary method is unresolved.
The bugs is in BinaryTypeBinding#availableMethods.
The correct code must be 'return availableMethods;' and not 'return methods;'

Fixed.</WithStack>
    <WithOutStack>0321 Stable Win32

I was typing in the editor when an Internal Error pop-up appeared:

not clear whether this in the code assist UI or whether we are getting an 
incorrect completion proposal.
Added guards to ResultCollector. However, the information passed into the 
result collector should not be null. Moving to JDT core.
Could be a #sourceName() from a type binding (problem one?) ?
method.returnType.qualifiedSourceName() inside 
CompletionEngine#findLocalMethods return null

I can not reproduce this problem and guards was added to ResultCollector.

Later.
The problem occur when the return type of a binary method is unresolved.
The bugs is in BinaryTypeBinding#availableMethods.
The correct code must be 'return availableMethods;' and not 'return methods;'

Fixed.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12375" />
    <CreationDate amount="2002-03-27 13:40:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>"." period fails to invoke delayed code assist</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="functioncall">
        <location start="566" end="598" />
        <code>control.getParent().getParent();</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>If you type ".", code assist gets invoked after a timeout.  However, if you 
have code assist open, and use "." to commit the highlighted choice, the 
timeout doesn't occur.
code assist already supports auto commit on "(" are you suggesting to add "." 
as a commit character as well. What is your scenario where this would be useful?
In 0321, "." still commits, only for some reason the caret gets inserted in 
front of the period.  This is new, I thought it used to leave the caret after 
the ".".

"." for commit is useful when one is chaining calls, for example 
control.getParent().getParent();
we intend surface the auto commit characters to the user as well.
Although desireable, no action for 2.0.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>If you type ".", code assist gets invoked after a timeout.  However, if you 
have code assist open, and use "." to commit the highlighted choice, the 
timeout doesn't occur.
code assist already supports auto commit on "(" are you suggesting to add "." 
as a commit character as well. What is your scenario where this would be useful?
In 0321, "." still commits, only for some reason the caret gets inserted in 
front of the period.  This is new, I thought it used to leave the caret after 
the ".".

"." for commit is useful when one is chaining calls, for example 
control.getParent().getParent();
we intend surface the auto commit characters to the user as well.
Although desireable, no action for 2.0.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12376" />
    <CreationDate amount="2002-03-27 13:41:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-Motif" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[Preferences] Workbench preferences page contains too much</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>integeration build 0326

The first page in the Preferences dialog has too much vertical to fit on my 
screen in Linux.  I'm running with a typical 1024 vertical resolution.

Motif widgets are big by nature, so this is why this problem probably doesn't 
occur elsewhere.  Perhaps some of this page's widgets can be grouped onto a 
separate sub-page?
The option for the new "configurable project" will be removed soon. Also, the 
option for "new project open perspective" will be removed soon (will be part of 
the new wizard dialog work).
Dup</WithStack>
    <WithOutStack>integeration build 0326

The first page in the Preferences dialog has too much vertical to fit on my 
screen in Linux.  I'm running with a typical 1024 vertical resolution.

Motif widgets are big by nature, so this is why this problem probably doesn't 
occur elsewhere.  Perhaps some of this page's widgets can be grouped onto a 
separate sub-page?
The option for the new "configurable project" will be removed soon. Also, the 
option for "new project open perspective" will be removed soon (will be part of 
the new wizard dialog work).
Dup</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12377" />
    <CreationDate amount="2002-03-27 14:25:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>gp - Core Dump when running Eclipse</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Win2k 5.00.2195, Service Pack 2, + some security fixes.  First core dump 
happened when running an inner Eclipse and attempting to switch perspectives.  
Dump below.  Shortly thereafter my outer eclipse died.

Will attach both dumps.
Created attachment 525
inner eclipse dump
Created attachment 526
outer eclipse dump
Additional info about what patches are installed.

----------------------------
wslkues (9.26.198.146)
----------------------------

        * WINDOWS 2000 SP2

        Patch NOT Found MS00-077        Q299796
        File \\wslkues\C$\Program Files\NetMeeting\callcont.dll has an
        invalid checksum and its file version is equal to or less than what
        is expected.

        Warning         MS00-079        Q276471
        File \\wslkues\C$\Program Files\Windows NT\htrn_jis.dll has a file
        version that is greater than what is expected. - File
        \\wslkues\C$\Program Files\Windows NT\hypertrm.exe has a file
        version that is greater than what is expected.

        Patch Found     MS01-007        Q285851

        Patch NOT Found MS01-013        Q285156
        The registry key **SOFTWARE\Microsoft\Updates\Windows
        2000\SP3\Q285156** does not exist.  It is required for this patch to
        be considered installed.

        Note            MS01-022        Q296441
        Please refer to Q306460 for a detailed explanation.

        Warning         MS01-025        Q296185
        File \\wslkues\C$\WINNT\system32\webhits.dll has a file version
        that is greater than what is expected.

        Patch Found     MS01-031        Q299553

        Patch Found     MS01-037        Q302755

        Warning         MS01-041        Q298012
        File \\wslkues\C$\WINNT\system32\com\comadmin.dll has a file
        version that is greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\msdtcprx.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\msdtctm.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\msdtcui.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\mtxclu.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\mtxdm.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\mtxoci.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\netdde.exe has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\ole32.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\rpcrt4.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\rpcss.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\txfaux.dll has a file version that is
        greater than what is expected.

        Patch Found     MS01-043        Q303984

        Patch Found     MS01-046        Q252795

        Patch Found     MS02-001        Q311401

        Patch NOT Found MS02-004        Q307298
        The registry key **SOFTWARE\Microsoft\Updates\Windows
        2000\SP3\Q307298** does not exist.  It is required for this patch to
        be considered installed.

        Patch Found     MS02-006        Q314147

        Patch Found     MS02-008        Q318202

        Warning         MS02-008        Q318203
        File \\wslkues\C$\WINNT\system32\msxml3.dll has a file version that
        is greater than what is expected.

        Patch Found     MS02-008        Q317244

        Patch Found     MS02-011        Q313450

        Patch Found     MS02-012        Q313450

        Patch Found     MS02-013        Q300845

        Patch Found     MS02-014        Q313829


        * INTERNET EXPLORER 6 GOLD

        Patch NOT Found MS01-051        Q306121
        The registry key **Software\Microsoft\Active Setup\Installed
        Components\{21B0D83A-E28E-4298-9EBA-DEC032CC4B13}** does not exist.
        It is required for this patch to be considered installed.

        Patch Found     MS01-055        Q312461

        Patch Found     MS01-058        Q313675

        Patch Found     MS02-005        Q316059

        Patch Found     MS02-009        Q318089
Could this have anything to do with CM's CoolBar changes?  Has the dll changed?
Can't recreate it.  Feel free to reopen this PR if it happens again.</WithStack>
    <WithOutStack>Win2k 5.00.2195, Service Pack 2, + some security fixes.  First core dump 
happened when running an inner Eclipse and attempting to switch perspectives.  
Dump below.  Shortly thereafter my outer eclipse died.

Will attach both dumps.
Created attachment 525
inner eclipse dump
Created attachment 526
outer eclipse dump
Additional info about what patches are installed.

----------------------------
wslkues (9.26.198.146)
----------------------------

        * WINDOWS 2000 SP2

        Patch NOT Found MS00-077        Q299796
        File \\wslkues\C$\Program Files\NetMeeting\callcont.dll has an
        invalid checksum and its file version is equal to or less than what
        is expected.

        Warning         MS00-079        Q276471
        File \\wslkues\C$\Program Files\Windows NT\htrn_jis.dll has a file
        version that is greater than what is expected. - File
        \\wslkues\C$\Program Files\Windows NT\hypertrm.exe has a file
        version that is greater than what is expected.

        Patch Found     MS01-007        Q285851

        Patch NOT Found MS01-013        Q285156
        The registry key **SOFTWARE\Microsoft\Updates\Windows
        2000\SP3\Q285156** does not exist.  It is required for this patch to
        be considered installed.

        Note            MS01-022        Q296441
        Please refer to Q306460 for a detailed explanation.

        Warning         MS01-025        Q296185
        File \\wslkues\C$\WINNT\system32\webhits.dll has a file version
        that is greater than what is expected.

        Patch Found     MS01-031        Q299553

        Patch Found     MS01-037        Q302755

        Warning         MS01-041        Q298012
        File \\wslkues\C$\WINNT\system32\com\comadmin.dll has a file
        version that is greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\msdtcprx.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\msdtctm.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\msdtcui.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\mtxclu.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\mtxdm.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\mtxoci.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\netdde.exe has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\ole32.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\rpcrt4.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\rpcss.dll has a file version that is
        greater than what is expected. - File
        \\wslkues\C$\WINNT\system32\txfaux.dll has a file version that is
        greater than what is expected.

        Patch Found     MS01-043        Q303984

        Patch Found     MS01-046        Q252795

        Patch Found     MS02-001        Q311401

        Patch NOT Found MS02-004        Q307298
        The registry key **SOFTWARE\Microsoft\Updates\Windows
        2000\SP3\Q307298** does not exist.  It is required for this patch to
        be considered installed.

        Patch Found     MS02-006        Q314147

        Patch Found     MS02-008        Q318202

        Warning         MS02-008        Q318203
        File \\wslkues\C$\WINNT\system32\msxml3.dll has a file version that
        is greater than what is expected.

        Patch Found     MS02-008        Q317244

        Patch Found     MS02-011        Q313450

        Patch Found     MS02-012        Q313450

        Patch Found     MS02-013        Q300845

        Patch Found     MS02-014        Q313829


        * INTERNET EXPLORER 6 GOLD

        Patch NOT Found MS01-051        Q306121
        The registry key **Software\Microsoft\Active Setup\Installed
        Components\{21B0D83A-E28E-4298-9EBA-DEC032CC4B13}** does not exist.
        It is required for this patch to be considered installed.

        Patch Found     MS01-055        Q312461

        Patch Found     MS01-058        Q313675

        Patch Found     MS02-005        Q316059

        Patch Found     MS02-009        Q318089
Could this have anything to do with CM's CoolBar changes?  Has the dll changed?
Can't recreate it.  Feel free to reopen this PR if it happens again.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12378" />
    <CreationDate amount="2002-03-27 14:33:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="Other" />
    <op_sys amount="other" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Running in a Runtime Workbench not kept in run history</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>build 2002-03-21 on Win98.

I ran some Java applications and they are in the run history but running a 
Runtime Workbench is not. Is this intentional? (yeah, I'm lazy and know that 
its only a couple of menu-clicks away)
This is not intentional - runs should show up in the history.
Running on 20020321++ I cannot duplicate this problem.  Can you still duplicate this problem DJ?  
If so, are there any more details on how to reproduce it?
I'm running a plain-Jane 0321 but will try it on a new build tomorrow.

All I did was load our projects from the repository and then select a file and 
say "Run with Runtime Workbench".

I hate to ask a dumb question, but "Run With Runtime Workbench" sounds like the launch 
configurations preference wasn't set.  Did you have the launching style preference set to 
launcher or configurations?
I have it set to Configuration-based in the Workbench -&gt; Preferences -&gt; Debug 
options.

I am running by choosing "drop down menu by the running man" -&gt; Run with -&gt; Run-
time workbench
OK, I think I may see what's happening here.  There was a period of time where even if you had the 
configurations pref set, you still saw the drop-down actions for running the old launchers.  The 
old launcher support was accessed through the "Run With--&gt;" cascading menu.  This has been fixed so 
that you now only see the options appropriate to the launch style pref setting.  The problem was 
that an old style launch won't show up in the history when the pref is set to configurations.  I 
thought this fix had made it into 0321, but maybe not.  I know for sure it's there now.  Please try this 
again when the latest build is available and let me know the results.
In build 2002-03-28 the run history is cleared when I switch from launcher-
based to configuration-based. I believe that this is the desired behaviour. If 
so, then ok to closed.
Yes, switching 'launching style' is supposed to clear the history.  Note this whole issue goes 
away as soon as we remove support for the old launcher-style launching.  Marking as 'WORKSFORME'.</WithStack>
    <WithOutStack>build 2002-03-21 on Win98.

I ran some Java applications and they are in the run history but running a 
Runtime Workbench is not. Is this intentional? (yeah, I'm lazy and know that 
its only a couple of menu-clicks away)
This is not intentional - runs should show up in the history.
Running on 20020321++ I cannot duplicate this problem.  Can you still duplicate this problem DJ?  
If so, are there any more details on how to reproduce it?
I'm running a plain-Jane 0321 but will try it on a new build tomorrow.

All I did was load our projects from the repository and then select a file and 
say "Run with Runtime Workbench".

I hate to ask a dumb question, but "Run With Runtime Workbench" sounds like the launch 
configurations preference wasn't set.  Did you have the launching style preference set to 
launcher or configurations?
I have it set to Configuration-based in the Workbench -&gt; Preferences -&gt; Debug 
options.

I am running by choosing "drop down menu by the running man" -&gt; Run with -&gt; Run-
time workbench
OK, I think I may see what's happening here.  There was a period of time where even if you had the 
configurations pref set, you still saw the drop-down actions for running the old launchers.  The 
old launcher support was accessed through the "Run With--&gt;" cascading menu.  This has been fixed so 
that you now only see the options appropriate to the launch style pref setting.  The problem was 
that an old style launch won't show up in the history when the pref is set to configurations.  I 
thought this fix had made it into 0321, but maybe not.  I know for sure it's there now.  Please try this 
again when the latest build is available and let me know the results.
In build 2002-03-28 the run history is cleared when I switch from launcher-
based to configuration-based. I believe that this is the desired behaviour. If 
so, then ok to closed.
Yes, switching 'launching style' is supposed to clear the history.  Note this whole issue goes 
away as soon as we remove support for the old launcher-style launching.  Marking as 'WORKSFORME'.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12379" />
    <CreationDate amount="2002-03-27 14:43:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>CoolBar does not behave properly with Combo as item</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="10">
      <source_code type="import">
        <location start="156" end="182" />
        <code>import org.eclipse.swt.*;</code>
      </source_code>
      <source_code type="import">
        <location start="183" end="216" />
        <code>import org.eclipse.swt.widgets.*;</code>
      </source_code>
      <source_code type="import">
        <location start="217" end="251" />
        <code>import org.eclipse.swt.graphics.*;</code>
      </source_code>
      <source_code type="import">
        <location start="252" end="284" />
        <code>import org.eclipse.swt.layout.*;</code>
      </source_code>
      <source_code type="class">
        <location start="286" end="1109" />
        <code>public class CoolBarTest {
public static void main (String [] args) {
    Display display = new Display ();
    Shell shell = new Shell (display);
    shell.setLayout(new GridLayout());
    final CoolBar coolBar = new CoolBar(shell, SWT.BORDER | SWT.FLAT);

    Combo combo = new Combo(coolBar, SWT.DROP_DOWN | SWT.READ_ONLY);
    combo.setItems(new String[] {"combo item 1", "combo item 2", "combo item 
3"});
    combo.setText("combo item 1");
    CoolItem coolItem = new CoolItem(coolBar, SWT.NULL);
    coolItem.setControl(combo);
    Point size = combo.computeSize(SWT.DEFAULT, SWT.DEFAULT);
    coolItem.setSize(coolItem.computeSize (size.x, size.y));

    shell.pack();
    shell.open ();
    while (!shell.isDisposed ()) {
        if (!display.readAndDispatch ()) display.sleep ();
    }
    display.dispose ();
}
}</code>
      </source_code>
      <source_code type="import">
        <location start="1521" end="1547" />
        <code>import org.eclipse.swt.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1548" end="1581" />
        <code>import org.eclipse.swt.widgets.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1582" end="1616" />
        <code>import org.eclipse.swt.graphics.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1617" end="1649" />
        <code>import org.eclipse.swt.layout.*;</code>
      </source_code>
      <source_code type="class">
        <location start="1651" end="2565" />
        <code>public class PR_12379 {
	
public static void main (String [] args) {
    Display display = new Display ();
    Shell shell = new Shell (display);
    shell.setLayout(new GridLayout());
    final CoolBar coolBar = new CoolBar(shell, SWT.BORDER | SWT.FLAT);

	Composite c = new Composite (coolBar, SWT.NONE);
	c.setLayout (new FillLayout ());
    Combo combo = new Combo(c, SWT.DROP_DOWN | SWT.READ_ONLY);
    combo.setItems(new String[] {"combo item 1", "combo item 2", "combo item 
3"});
    combo.setText("combo item 1");   
	c.pack ();
    
    CoolItem coolItem = new CoolItem(coolBar, SWT.NULL);
	coolItem.setControl(c);
    Point size = combo.computeSize(SWT.DEFAULT, SWT.DEFAULT);
    coolItem.setSize(coolItem.computeSize (size.x, size.y));

    shell.pack();
    shell.open ();
    while (!shell.isDisposed ()) {
        if (!display.readAndDispatch ()) display.sleep ();
    }
    display.dispose ();
}

}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>20020321, Win2K
Run the following code.
You cannot drop down the Combo (i.e. the drop down list does not show, even 
though the Combo obviously has focus).

import org.eclipse.swt.*;
import org.eclipse.swt.widgets.*;
import org.eclipse.swt.graphics.*;
import org.eclipse.swt.layout.*;

public class CoolBarTest {
public static void main (String [] args) {
    Display display = new Display ();
    Shell shell = new Shell (display);
    shell.setLayout(new GridLayout());
    final CoolBar coolBar = new CoolBar(shell, SWT.BORDER | SWT.FLAT);

    Combo combo = new Combo(coolBar, SWT.DROP_DOWN | SWT.READ_ONLY);
    combo.setItems(new String[] {"combo item 1", "combo item 2", "combo item 
3"});
    combo.setText("combo item 1");
    CoolItem coolItem = new CoolItem(coolBar, SWT.NULL);
    coolItem.setControl(combo);
    Point size = combo.computeSize(SWT.DEFAULT, SWT.DEFAULT);
    coolItem.setSize(coolItem.computeSize (size.x, size.y));

    shell.pack();
    shell.open ();
    while (!shell.isDisposed ()) {
        if (!display.readAndDispatch ()) display.sleep ();
    }
    display.dispose ();
}
}
CM to do initial investigation.
Still a problem in F1.
Reassigning to Felipe to look at.

The problem is deep in the implementation of the Windows cool bar.  It can be 
worked around by application code by inserting a composite in between the combo 
and the coolbar.  It's too late to try and work around this in SWT for 2.0.

I suggest the application code work around it for now.  Here is some example 
code:

import org.eclipse.swt.*;
import org.eclipse.swt.widgets.*;
import org.eclipse.swt.graphics.*;
import org.eclipse.swt.layout.*;

public class PR_12379 {
	
public static void main (String [] args) {
    Display display = new Display ();
    Shell shell = new Shell (display);
    shell.setLayout(new GridLayout());
    final CoolBar coolBar = new CoolBar(shell, SWT.BORDER | SWT.FLAT);

	Composite c = new Composite (coolBar, SWT.NONE);
	c.setLayout (new FillLayout ());
    Combo combo = new Combo(c, SWT.DROP_DOWN | SWT.READ_ONLY);
    combo.setItems(new String[] {"combo item 1", "combo item 2", "combo item 
3"});
    combo.setText("combo item 1");   
	c.pack ();
    
    CoolItem coolItem = new CoolItem(coolBar, SWT.NULL);
	coolItem.setControl(c);
    Point size = combo.computeSize(SWT.DEFAULT, SWT.DEFAULT);
    coolItem.setSize(coolItem.computeSize (size.x, size.y));

    shell.pack();
    shell.open ();
    while (!shell.isDisposed ()) {
        if (!display.readAndDispatch ()) display.sleep ();
    }
    display.dispose ();
}

}
Marking LATER to indicate no fix until post R2.0.

Post 2.0. Re-opening bug reports for review.
Verified.

Still a problem. Steve, do you recall what the details of the problem were?
I don't think I ever figured them out completely but I could try again.
I know what is going on.  Resizing a combo using the Windows call SetWindowPos
() also resized the drop down part.  We work around this in setBounds() in 
SWT.  The C code that implements the Windows cool bar is calls SetWindowPos() 
because it can't know about the SWT work around.  Hence, the bug.  It's 
actually a well known problem in Windows.

I am working on a fix.
Fixed &gt; 20041209</WithStack>
    <WithOutStack>20020321, Win2K
Run the following code.
You cannot drop down the Combo (i.e. the drop down list does not show, even 
though the Combo obviously has focus).

import org.eclipse.swt.*;
import org.eclipse.swt.widgets.*;
import org.eclipse.swt.graphics.*;
import org.eclipse.swt.layout.*;

public class CoolBarTest {
public static void main (String [] args) {
    Display display = new Display ();
    Shell shell = new Shell (display);
    shell.setLayout(new GridLayout());
    final CoolBar coolBar = new CoolBar(shell, SWT.BORDER | SWT.FLAT);

    Combo combo = new Combo(coolBar, SWT.DROP_DOWN | SWT.READ_ONLY);
    combo.setItems(new String[] {"combo item 1", "combo item 2", "combo item 
3"});
    combo.setText("combo item 1");
    CoolItem coolItem = new CoolItem(coolBar, SWT.NULL);
    coolItem.setControl(combo);
    Point size = combo.computeSize(SWT.DEFAULT, SWT.DEFAULT);
    coolItem.setSize(coolItem.computeSize (size.x, size.y));

    shell.pack();
    shell.open ();
    while (!shell.isDisposed ()) {
        if (!display.readAndDispatch ()) display.sleep ();
    }
    display.dispose ();
}
}
CM to do initial investigation.
Still a problem in F1.
Reassigning to Felipe to look at.

The problem is deep in the implementation of the Windows cool bar.  It can be 
worked around by application code by inserting a composite in between the combo 
and the coolbar.  It's too late to try and work around this in SWT for 2.0.

I suggest the application code work around it for now.  Here is some example 
code:

import org.eclipse.swt.*;
import org.eclipse.swt.widgets.*;
import org.eclipse.swt.graphics.*;
import org.eclipse.swt.layout.*;

public class PR_12379 {
	
public static void main (String [] args) {
    Display display = new Display ();
    Shell shell = new Shell (display);
    shell.setLayout(new GridLayout());
    final CoolBar coolBar = new CoolBar(shell, SWT.BORDER | SWT.FLAT);

	Composite c = new Composite (coolBar, SWT.NONE);
	c.setLayout (new FillLayout ());
    Combo combo = new Combo(c, SWT.DROP_DOWN | SWT.READ_ONLY);
    combo.setItems(new String[] {"combo item 1", "combo item 2", "combo item 
3"});
    combo.setText("combo item 1");   
	c.pack ();
    
    CoolItem coolItem = new CoolItem(coolBar, SWT.NULL);
	coolItem.setControl(c);
    Point size = combo.computeSize(SWT.DEFAULT, SWT.DEFAULT);
    coolItem.setSize(coolItem.computeSize (size.x, size.y));

    shell.pack();
    shell.open ();
    while (!shell.isDisposed ()) {
        if (!display.readAndDispatch ()) display.sleep ();
    }
    display.dispose ();
}

}
Marking LATER to indicate no fix until post R2.0.

Post 2.0. Re-opening bug reports for review.
Verified.

Still a problem. Steve, do you recall what the details of the problem were?
I don't think I ever figured them out completely but I could try again.
I know what is going on.  Resizing a combo using the Windows call SetWindowPos
() also resized the drop down part.  We work around this in setBounds() in 
SWT.  The C code that implements the Windows cool bar is calls SetWindowPos() 
because it can't know about the SWT work around.  Hence, the bug.  It's 
actually a well known problem in Windows.

I am working on a fix.
Fixed &gt; 20041209</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12380" />
    <CreationDate amount="2002-03-27 14:51:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="1.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>AST/DOM: resolveTypeBinding() on the second operand of a instanceof expression return null</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="class">
        <location start="132" end="217" />
        <code>class foo {
  boolean bar() {
    return "abc" instanceof java.io.Serializable;
  }
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>with the following code, the call of resolveTypeBinding() on the node Name which
correspond to "java.io.Serializable" return null.

class foo {
  boolean bar() {
    return "abc" instanceof java.io.Serializable;
  }
}
Reproduced. I am working on it.
Regression tests added.
Fixed and released in HEAD.</WithStack>
    <WithOutStack>with the following code, the call of resolveTypeBinding() on the node Name which
correspond to "java.io.Serializable" return null.

class foo {
  boolean bar() {
    return "abc" instanceof java.io.Serializable;
  }
}
Reproduced. I am working on it.
Regression tests added.
Fixed and released in HEAD.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12381" />
    <CreationDate amount="2002-03-27 14:57:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>"Open in both mode" preference missing</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>The preference for always opening the sync view in "both mode" wasn't brought 
forward from VCM 1.0 to Team 2.0.

Apparently Kent is the only one who uses it.
*** Bug 14625 has been marked as a duplicate of this bug. ***
There are a number of us in our office who have been waiting for this to return.
It's irritating to have to reset the mode everytime we synch.
Fixed</WithStack>
    <WithOutStack>The preference for always opening the sync view in "both mode" wasn't brought 
forward from VCM 1.0 to Team 2.0.

Apparently Kent is the only one who uses it.
*** Bug 14625 has been marked as a duplicate of this bug. ***
There are a number of us in our office who have been waiting for this to return.
It's irritating to have to reset the mode everytime we synch.
Fixed</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12382" />
    <CreationDate amount="2002-03-27 15:13:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Action set part association for the launch view?</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>The workbench has an extension point for action set part associations; an 
action set is added to a perspectie when a part is opened in the perspective.  
This seems like a good idea for the launch view and the debug action set.
Agreed. It's never too late for more features :-)
Fixed in DebugUI plugin.xml
Please verify.
Verified.</WithStack>
    <WithOutStack>The workbench has an extension point for action set part associations; an 
action set is added to a perspectie when a part is opened in the perspective.  
This seems like a good idea for the launch view and the debug action set.
Agreed. It's never too late for more features :-)
Fixed in DebugUI plugin.xml
Please verify.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12383" />
    <CreationDate amount="2002-03-27 15:26:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Relaunch last aborted with cryptic message when JRE moved</Summery>
    <Patches amount="0" />
    <Stacktraces amount="2">
      <Stacktrace timestamp="1437330634011">
        <Exception>org.eclipse.core.runtime.CoreException</Exception>
        <Reason>JRE 1017075029412 does not exist.</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.abort(AbstractJavaLaunchConfigurationDelegate.java:60)</Frame>
          <Frame depth="1">org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.verifyVMInstall(AbstractJavaLaunchConfigurationDelegate.java:171)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.launching.JavaLocalApplicationLaunchConfigurationDelegate.launch(JavaLocalApplicationLaunchConfigurationDelegate.java:48)</Frame>
          <Frame depth="3">org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:137)</Frame>
          <Frame depth="4">org.eclipse.debug.internal.ui.actions.RelaunchActionDelegate.relaunch(RelaunchActionDelegate.java:124)</Frame>
          <Frame depth="5">org.eclipse.debug.internal.ui.actions.RelaunchActionDelegate.relaunch(RelaunchActionDelegate.java:47)</Frame>
          <Frame depth="6">org.eclipse.debug.internal.ui.actions.RelaunchLastAction$1.run(RelaunchLastAction.java:57)</Frame>
          <Frame depth="7">org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)</Frame>
          <Frame depth="8">org.eclipse.debug.internal.ui.actions.RelaunchLastAction.run(RelaunchLastAction.java:55)</Frame>
          <Frame depth="9">org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:204)</Frame>
          <Frame depth="10">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:407)</Frame>
          <Frame depth="11">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:361)</Frame>
          <Frame depth="12">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:352)</Frame>
          <Frame depth="13">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:47)</Frame>
          <Frame depth="14">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)</Frame>
          <Frame depth="15">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)</Frame>
          <Frame depth="16">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)</Frame>
          <Frame depth="18">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)</Frame>
          <Frame depth="19">org.eclipse.ui.internal.Workbench.run(Workbench.java:738)</Frame>
          <Frame depth="20">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="21">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="22">EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437330634011">
        <Exception>org.eclipse.core.runtime.CoreException</Exception>
        <Reason>JRE 1017075029412 does not exist.</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.abort(AbstractJavaLaunchConfigurationDelegate.java:60)</Frame>
          <Frame depth="1">org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.verifyVMInstall(AbstractJavaLaunchConfigurationDelegate.java:171)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.launching.JavaLocalApplicationLaunchConfigurationDelegate.launch(JavaLocalApplicationLaunchConfigurationDelegate.java:48)</Frame>
          <Frame depth="3">org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:137)</Frame>
          <Frame depth="4">org.eclipse.debug.internal.ui.actions.RelaunchActionDelegate.relaunch(RelaunchActionDelegate.java:124)</Frame>
          <Frame depth="5">org.eclipse.debug.internal.ui.actions.RelaunchActionDelegate.relaunch(RelaunchActionDelegate.java:47)</Frame>
          <Frame depth="6">org.eclipse.debug.internal.ui.actions.RelaunchLastAction$1.run(RelaunchLastAction.java:57)</Frame>
          <Frame depth="7">org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)</Frame>
          <Frame depth="8">org.eclipse.debug.internal.ui.actions.RelaunchLastAction.run(RelaunchLastAction.java:55)</Frame>
          <Frame depth="9">org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:204)</Frame>
          <Frame depth="10">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:407)</Frame>
          <Frame depth="11">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:361)</Frame>
          <Frame depth="12">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:352)</Frame>
          <Frame depth="13">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:47)</Frame>
          <Frame depth="14">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)</Frame>
          <Frame depth="15">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)</Frame>
          <Frame depth="16">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)</Frame>
          <Frame depth="18">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)</Frame>
          <Frame depth="19">org.eclipse.ui.internal.Workbench.run(Workbench.java:738)</Frame>
          <Frame depth="20">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="21">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="22">EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>We need to at least improve our error reporting for this case...the reason is 
not that useful

Test Case
Have a successfully launch launch config
Exit Eclipse
Move the JRE referred to in the launch config
Restart Eclipse
Hit F9

Error Dialog
Launch Failed
An Exception occurred while launching
Reason:
JRE 1017075029412 does not exist.

In the log:
 org.eclipse.debug.ui 120 Error logged from Debug UI: 
org.eclipse.core.runtime.CoreException: JRE 1017075029412 does not exist.
	at 
org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.abort
(AbstractJavaLaunchConfigurationDelegate.java:60)
	at 
org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.verifyVMInstal
l(AbstractJavaLaunchConfigurationDelegate.java:171)
	at 
org.eclipse.jdt.internal.launching.JavaLocalApplicationLaunchConfigurationDelega
te.launch(JavaLocalApplicationLaunchConfigurationDelegate.java:48)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch
(LaunchConfiguration.java:137)
	at org.eclipse.debug.internal.ui.actions.RelaunchActionDelegate.relaunch
(RelaunchActionDelegate.java:124)
	at org.eclipse.debug.internal.ui.actions.RelaunchActionDelegate.relaunch
(RelaunchActionDelegate.java:47)
	at org.eclipse.debug.internal.ui.actions.RelaunchLastAction$1.run
(RelaunchLastAction.java:57)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)
	at org.eclipse.debug.internal.ui.actions.RelaunchLastAction.run
(RelaunchLastAction.java:55)
	at org.eclipse.ui.internal.PluginAction.runWithEvent
(PluginAction.java:204)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:407)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:361)
	at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:352)
	at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:47)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:738)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)Have a 
successfully launched launch config that points to JRE A
Exit eclipse
REstart eclipse
Hit F9

Error dialog
Launch Failed
An exception occurred while launching
Reason:
JRE 1017075029412 does not exist

In log:
4 org.eclipse.debug.ui 120 Error logged from Debug UI: 
org.eclipse.core.runtime.CoreException: JRE 1017075029412 does not exist.
	at 
org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.abort
(AbstractJavaLaunchConfigurationDelegate.java:60)
	at 
org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.verifyVMInstal
l(AbstractJavaLaunchConfigurationDelegate.java:171)
	at 
org.eclipse.jdt.internal.launching.JavaLocalApplicationLaunchConfigurationDelega
te.launch(JavaLocalApplicationLaunchConfigurationDelegate.java:48)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch
(LaunchConfiguration.java:137)
	at org.eclipse.debug.internal.ui.actions.RelaunchActionDelegate.relaunch
(RelaunchActionDelegate.java:124)
	at org.eclipse.debug.internal.ui.actions.RelaunchActionDelegate.relaunch
(RelaunchActionDelegate.java:47)
	at org.eclipse.debug.internal.ui.actions.RelaunchLastAction$1.run
(RelaunchLastAction.java:57)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)
	at org.eclipse.debug.internal.ui.actions.RelaunchLastAction.run
(RelaunchLastAction.java:55)
	at org.eclipse.ui.internal.PluginAction.runWithEvent
(PluginAction.java:204)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:407)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:361)
	at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:352)
	at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:47)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:755)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:738)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:14)
The error message should use the JRE name rather than ID.
There is no IVMInstall so we do not have a VM name.  Changed the message 
to: "The specified JRE installation does not exist".
Please verify in AbstractJavaLsaunchConfigurationDelegate#verifyVMInstall
Verified.</WithStack>
    <WithOutStack>We need to at least improve our error reporting for this case...the reason is 
not that useful

Test Case
Have a successfully launch launch config
Exit Eclipse
Move the JRE referred to in the launch config
Restart Eclipse
Hit F9

Error Dialog
Launch Failed
An Exception occurred while launching
Reason:
JRE 1017075029412 does not exist.

In the log:
 org.eclipse.debug.ui 120 Error logged from Debug UI: 
ave a 
successfully launched launch config that points to JRE A
Exit eclipse
REstart eclipse
Hit F9

Error dialog
Launch Failed
An exception occurred while launching
Reason:
JRE 1017075029412 does not exist

In log:
4 org.eclipse.debug.ui 120 Error logged from Debug UI: 

The error message should use the JRE name rather than ID.
There is no IVMInstall so we do not have a VM name.  Changed the message 
to: "The specified JRE installation does not exist".
Please verify in AbstractJavaLsaunchConfigurationDelegate#verifyVMInstall
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12384" />
    <CreationDate amount="2002-03-27 15:30:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>tab doesn't work in editor</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>I just installed build 20020326 and the tab key no longer works in the editor. 
I can highlight text and press tab and the lines will move, but if nothing is 
highlighted, pressing the tab key does not move the cursor.
Please try this in the latest 2.0 builds. There were problems in this build 
with the keybinding support.</WithStack>
    <WithOutStack>I just installed build 20020326 and the tab key no longer works in the editor. 
I can highlight text and press tab and the lines will move, but if nothing is 
highlighted, pressing the tab key does not move the cursor.
Please try this in the latest 2.0 builds. There were problems in this build 
with the keybinding support.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12385" />
    <CreationDate amount="2002-03-27 15:41:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Task view not updating</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="2">
      <source_code type="class">
        <location start="129" end="149" />
        <code>public class Foo {
}</code>
      </source_code>
      <source_code type="class">
        <location start="155" end="178" />
        <code>public class FooBar {
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="10">
        <Lines>
          <Line>1. Create a project</Line>
          <Line>2. Create a class Foo</Line>
          <Line>3. Change the name of the class in the editor ie. from:</Line>
          <Line />
          <Line />
          <Line>to:</Line>
          <Line />
          <Line />
          <Line>4. In the packages view rename the class (compilation unit) to FooBar to get rid</Line>
          <Line>of the error.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Eclipse drop: 20020321

STEPS:
1. Create a project
2. Create a class Foo
3. Change the name of the class in the editor ie. from:
public class Foo {
}

to:
public class FooBar {
}

4. In the packages view rename the class (compilation unit) to FooBar to get rid
of the error.

NOTE: The error task: "The public type FooBar must be defined in its own file"
for Foo.java still exists.
An alternate scenario for reproducing this bug (with drop 20020321) is:
1) Copy a readonly source file
2) Paste it into the same directory as the original file

The pasted file will be flagged readonly, and the automatic refactoring 
methods that attempt to rename the class will fail. At this point, you will 
have this same "must be defined in its own.." error in the task list which 
will not go away.
Pls try this case in the latest 2.0 builds. 
Works in build 20020501</WithStack>
    <WithOutStack>Eclipse drop: 20020321

STEPS:
1. Create a project
2. Create a class Foo
3. Change the name of the class in the editor ie. from:
public class Foo {
}

to:
public class FooBar {
}

4. In the packages view rename the class (compilation unit) to FooBar to get rid
of the error.

NOTE: The error task: "The public type FooBar must be defined in its own file"
for Foo.java still exists.
An alternate scenario for reproducing this bug (with drop 20020321) is:
1) Copy a readonly source file
2) Paste it into the same directory as the original file

The pasted file will be flagged readonly, and the automatic refactoring 
methods that attempt to rename the class will fail. At this point, you will 
have this same "must be defined in its own.." error in the task list which 
will not go away.
Pls try this case in the latest 2.0 builds. 
Works in build 20020501</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12386" />
    <CreationDate amount="2002-03-27 15:46:00 -0500" />
    <DupId amount="21128" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>CVS meta-folders appear in some cases</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="9">
        <Lines>
          <Line>1. A user has an existing CVS project outside of Eclipse. By creating the</Line>
          <Line>project in Eclipse to point to the existing location the project's contents will</Line>
          <Line>be brought into Eclipse and the CVS folders will be marlked as team-private but</Line>
          <Line>other delta listeners will not know this. As a result, the user will have to</Line>
          <Line>close views or restart the workbench to have the CVS folders filtered.</Line>
          <Line />
          <Line>2. A user performs CVS command line operations outside of Eclipse that results</Line>
          <Line>in new CVS folders. From Eclipse the refresh local will bring in the new folders</Line>
          <Line>and they will be marked as team-private. But as in 1, they may appear in the UI.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>As a result of the team-private flag not causing a delta when it is set, there
are some cases where setting folders as team private won't hide them from the UI
as the user would expect.

There are some common scenarios where a user may (depending on the order of
delta traversal) see this behavior:

1. A user has an existing CVS project outside of Eclipse. By creating the
project in Eclipse to point to the existing location the project's contents will
be brought into Eclipse and the CVS folders will be marlked as team-private but
other delta listeners will not know this. As a result, the user will have to
close views or restart the workbench to have the CVS folders filtered.

2. A user performs CVS command line operations outside of Eclipse that results
in new CVS folders. From Eclipse the refresh local will bring in the new folders
and they will be marked as team-private. But as in 1, they may appear in the UI.

There is no plan to be fix this.
Re 1: Should setting it to team-private result in a delta that on the surface 
appears to be a remove?

Re 2: I will discuss with JW. There is work underway to auto-refresh projects 
by looking for out of date files in a background process and doing a 
refreshFromLocal.  This would mean the user wouldn't even get a chance to do a 
special "Refresh CVS" operation.
later
Reopening


*** This bug has been marked as a duplicate of 21128 ***</WithStack>
    <WithOutStack>As a result of the team-private flag not causing a delta when it is set, there
are some cases where setting folders as team private won't hide them from the UI
as the user would expect.

There are some common scenarios where a user may (depending on the order of
delta traversal) see this behavior:

1. A user has an existing CVS project outside of Eclipse. By creating the
project in Eclipse to point to the existing location the project's contents will
be brought into Eclipse and the CVS folders will be marlked as team-private but
other delta listeners will not know this. As a result, the user will have to
close views or restart the workbench to have the CVS folders filtered.

2. A user performs CVS command line operations outside of Eclipse that results
in new CVS folders. From Eclipse the refresh local will bring in the new folders
and they will be marked as team-private. But as in 1, they may appear in the UI.

There is no plan to be fix this.
Re 1: Should setting it to team-private result in a delta that on the surface 
appears to be a remove?

Re 2: I will discuss with JW. There is work underway to auto-refresh projects 
by looking for out of date files in a background process and doing a 
refreshFromLocal.  This would mean the user wouldn't even get a chance to do a 
special "Refresh CVS" operation.
later
Reopening


*** This bug has been marked as a duplicate of 21128 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12387" />
    <CreationDate amount="2002-03-27 15:47:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Out Of Memory error importing file</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="120">
      <source_code type="multicomment">
        <location start="1113" end="1700" />
        <code>/* ************************************************************************
 * GJC attribution phase
 * by Martin Odersky
 *
 * Copyright (C) 1996-98 Martin Odersky. All rights reserved.
 * Permission is hereby granted to use and modify this software for evaluation
 * and research purposes. Modification and use for other purposes requires
 * prior written permission by the author. The software, or modifications
 * thereof may be given to third parties only with prior written permission
 * by the author.
 *************************************************************************/</code>
      </source_code>
      <source_code type="package">
        <location start="1702" end="1744" />
        <code>package edu.rice.cs.nextgen.compiler.comp;</code>
      </source_code>
      <source_code type="import">
        <location start="1745" end="1789" />
        <code>import edu.rice.cs.nextgen.compiler.util.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1790" end="1833" />
        <code>import edu.rice.cs.nextgen.compiler.code.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1834" end="1877" />
        <code>import edu.rice.cs.nextgen.compiler.tree.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1878" end="1895" />
        <code>import Symbol.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1896" end="1910" />
        <code>import Tree.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1911" end="1925" />
        <code>import Type.*;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2302" end="2318" />
        <code>this.log = log;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2319" end="2337" />
        <code>this.syms = syms;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2338" end="2352" />
        <code>this.rs = rs;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2353" end="2369" />
        <code>this.chk = chk;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2370" end="2390" />
        <code>this.infer = infer;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2391" end="2409" />
        <code>this.make = make;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2410" end="2430" />
        <code>this.enter = enter;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2431" end="2469" />
        <code>if (enter != null) enter.attr = this;</code>
      </source_code>
      <source_code type="assignment">
        <location start="2470" end="2511" />
        <code>this.cfolder = new ConstFold(log, syms);</code>
      </source_code>
      <source_code type="multicomment">
        <location start="2518" end="2798" />
        <code>/** check kind and type of given tree against prototype
     *  store resulting type to tree and return it.
     *  no checks are performed if the prototype is a method type.
     *  Its not necessary in this case since we know that kind and type
     *  are correct.
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="2799" end="3247" />
        <code>Type check(Tree tree, Type owntype, int ownkind, int pkind, Type pt) {
	if (owntype.tag != ERROR &amp;&amp; pt.tag != METHOD) {
	    if ((ownkind &amp; ~pkind) == 0) {
		if (pt.tag != NONE)
		    owntype = chk.checkType(tree.pos, owntype, pt);
	    } else {
		log.error(tree.pos,
			  Resolve.kindNames(pkind) + " required, but " +
			  Resolve.kindName(ownkind) + " found");
		owntype = Type.errType;
	    }
	}
	tree.type = owntype;
	return owntype;
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="3248" end="3365" />
        <code>/** is variable `v' assignable, i.e. in a scope where it may be assigned to
     *  even if it is final?
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="3366" end="3736" />
        <code>static boolean finalAssignable(VarSymbol v, Env&lt;AttrContext&gt; env) {
	Symbol owner = env.info.scope.owner;
	return
	    v.constValue == null
	    &amp;&amp;
	    (v.owner == owner
	     ||
	     ((owner.name == Names.init || (owner.flags() &amp; BLOCK) != 0)
	      &amp;&amp;
	      v.owner == owner.owner
	      &amp;&amp;
	      ((v.flags() &amp; STATIC) != 0) == (Resolve.isStatic(env))));
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="3737" end="3797" />
        <code>/** check that variable `v' can be assigned to.
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="3798" end="4116" />
        <code>void checkAssignable(int pos, VarSymbol v, Tree base, Env&lt;AttrContext&gt; env) 
{
	if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
	    !((base == null ||
	       (base.tag == Tree.IDENT &amp;&amp; TreeInfo.name(base) == Names._this)) 
&amp;&amp;
	      finalAssignable(v, env))) {
	    log.error(pos, "can't assign a value to final " + v);
	}
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="4117" end="4198" />
        <code>/** warn about deprecated symbol if not in currently ccompiled files
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="4199" end="4378" />
        <code>void warnDeprecated(int pos, Symbol sym) {
	if (!enter.compiled.contains(sym.enclClass().fullname))
	    log.warning(pos, sym + sym.location() + " has been deprecated");
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="4379" end="4421" />
        <code>/** the current `this' symbol
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="4422" end="4553" />
        <code>Symbol thisSym(Env&lt;AttrContext&gt; env) {
	return rs.resolveSelf(
	    Position.NOPOS, env, env.enclClass.sym, Names._this);
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="4554" end="4715" />
        <code>/** if `site' is an inner class, prepend outer instance to argtypes
     *  outer instance is taken to be `outer' if not null, is made up otherwise.
     */</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="4834" end="5278" />
        <code>if (site.outer().tag == CLASS) {
	    if (outer == null) {
		Symbol outerthis = rs.resolveSelf(
		    pos, env, site.outer().tsym, Names._this);
		if (outerthis.kind == VAR) {
/*//todo: revise this
		    if (env.info.isSelfCall &amp;&amp;
			outerthis.owner == env.enclClass.sym)
			chk.earlyRefError(pos, outerthis);
 */
		    outer = outerthis.owner.type;
		} else {
		    outer = Type.errType;
		}
	    }
	    argtypes = argtypes.prepend(outer);
	}</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="5276" end="5435" />
        <code>} else if (outer != null &amp;&amp; outer.tag == CLASS &amp;&amp; site.tag != ERROR) {
	    log.error(pos,
		"illegal qualifier; " + site.tsym + " is not an inner class");
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="5461" end="5719" />
        <code>Type attribTerm(Tree tree, Env&lt;AttrContext&gt; env, int pkind, Type pt) {
	try {
	    env.info.pkind = pkind;
	    env.info.pt = pt;
	    return tree.visit(this, env);
	} catch (CompletionFailure ex) {
	    return chk.completionError(tree.pos, ex);
	}
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="5722" end="5831" />
        <code>Type attribExpr(Tree tree, Env&lt;AttrContext&gt; env, Type pt) {
	return attribTerm(tree, env, VAL, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="5833" end="5937" />
        <code>Type attribExpr(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribExpr(tree, env, Type.noType);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="5939" end="6048" />
        <code>Type attribType(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribTerm(tree, env, TYP, Type.noType);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6050" end="6159" />
        <code>Type attribStat(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribTerm(tree, env, NIL, Type.noType);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6161" end="6411" />
        <code>List&lt;Type&gt; attribExprs(List&lt;Tree&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
	ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = trees; l.nonEmpty(); l = l.tail)
	    ts.append(attribExpr(l.head, env, pt));
	return ts.toList();
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6413" end="6576" />
        <code>&lt;T extends Tree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
	for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
	    attribStat(l.head, env);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6578" end="6865" />
        <code>List&lt;Type&gt; attribArgs(List&lt;Tree&gt; trees, Env&lt;AttrContext&gt; env) {
	ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = trees; l.nonEmpty(); l = l.tail)
	    argtypes.append(chk.checkNonVoid(
		l.head.pos, attribExpr(l.head, env)));
	return argtypes.toList();
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="6866" end="6931" />
        <code>/** attribute extended or implemented type reference
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6932" end="7338" />
        <code>Type attribBase(Tree tree, Env&lt;AttrContext&gt; env, int interfaceFlag) {
	Type t = chk.checkClassType(tree.pos, attribType(tree, env));
	if ((t.tsym.flags() &amp; INTERFACE) != interfaceFlag) {
	    log.error(tree.pos,
		(interfaceFlag == 0 ? "no " : "") + "interface expected here");
	}
	if ((t.tsym.flags() &amp; FINAL) != 0) {
	    log.error(tree.pos, "can't inherit from final " + t.tsym);
	}
	return t;
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="7339" end="7509" />
        <code>/* ********************************************************************
 * Adding miranda methods
 *********************************************************************/</code>
      </source_code>
      <source_code type="multicomment">
        <location start="7510" end="7634" />
        <code>/** add an abstract method definition to class definition `cd'
     *  for a method `m' defined in an interface
     */</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="7737" end="7796" />
        <code>//	System.err.println("add abstract method: " + m);//DEBUG</code>
      </source_code>
      <source_code type="assignment">
        <location start="7936" end="7968" />
        <code>cd.defs = cd.defs.prepend(def);</code>
      </source_code>
      <source_code type="functioncall">
        <location start="7969" end="7998" />
        <code>enter.memberEnter(def, env);</code>
      </source_code>
      <source_code type="multicomment">
        <location start="8005" end="8214" />
        <code>/** add abstract method definitions for all methods defined in one of
     *  c's interfaces, provided they are not already implemented
     *  env = the environment for the class definition of c.
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="8215" end="8850" />
        <code>void implementInterfaceMethods(ClassSymbol c, Env&lt;AttrContext&gt; env) {
	ClassDef cd = (ClassDef)env.tree;
	for (List&lt;Type&gt; l = c.type.interfaces(); l.nonEmpty(); l = l.tail) {
	    ClassSymbol i = (ClassSymbol)l.head.tsym;
	    for (Scope.Entry e = i.members().elems;
		 e != null;
		 e = e.sibling) {
		if (e.sym.kind == MTH &amp;&amp;
		    (e.sym.flags() &amp; STATIC) == 0) // disregard &lt;clinit&gt;!
		{
		    MethodSymbol absMeth = (MethodSymbol)e.sym;
		    MethodSymbol implMeth = absMeth.implementation(cd.sym);
		    if (implMeth == null)
			addAbstractMethod(cd, absMeth, env);
		}
	    }
	    implementInterfaceMethods(i, env);
	}
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="8851" end="9022" />
        <code>/* ************************************************************************
 * visitor methods
 *************************************************************************/</code>
      </source_code>
      <source_code type="functiondef">
        <location start="9024" end="9379" />
        <code>public Type _case(ClassDef tree, Env&lt;AttrContext&gt; env) {
	if ((env.info.scope.owner.kind &amp; (VAR | MTH)) != 0) {
	    enter.classEnter(tree, env);
	} else if (tree.name.len == 0) {
	    System.out.println(env.info.scope.owner);
	}
	ClassSymbol c = tree.sym;
	if (c == null) return null;
	c.complete();
	attribClass(c);
	return tree.type = c.type;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="9381" end="10941" />
        <code>public Type _case(MethodDef tree, Env&lt;AttrContext&gt; env) {
	MethodSymbol m = tree.sym;
	chk.checkOverride(tree.pos, m);

	Env&lt;AttrContext&gt; localEnv = enter.methodEnv((MethodDef)tree, env);
	for (List&lt;TypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
	    localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
	for (List&lt;VarDef&gt; l = tree.params; l.nonEmpty(); l = l.tail)
	    attribStat(l.head, localEnv);

	chk.validateTypeParams(tree.typarams);
	chk.validate(tree.restype);
	for (List&lt;Tree&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
	    chk.checkType(l.head.pos, l.head.type, syms.throwableType);
	
	ClassSymbol owner = env.enclClass.sym;
	if (tree.body == null) {
	    if ((owner.flags() &amp; INTERFACE) == 0 &amp;&amp;
		(tree.flags &amp; (ABSTRACT | NATIVE)) == 0)
		log.error(tree.pos,
			  "missing method body, or declare as abstract");
	} else if ((owner.flags() &amp; INTERFACE) != 0) {
	    log.error(tree.pos, "interface methods cannot have body");
	} else if ((tree.flags &amp; ABSTRACT) != 0) {
	    log.error(tree.pos, "abstract methods cannot have body");
	} else if ((tree.flags &amp; NATIVE) != 0) {
	    log.error(tree.pos, "native methods cannot have body");
	} else {
	    if (tree.name == Names.init &amp;&amp; owner.type != syms.objectType) {
		Block body = tree.body;
		if (body.stats.isEmpty() || !isSelfCall(body.stats.head)) {
		    body.stats = body.stats.prepend(
			Enter.SuperCall(
			    make.at(body.pos), VarDef.emptyList, false));
		}
	    }
	    attribStat(tree.body, localEnv);
	}
	localEnv.info.scope.leave();
	return tree.type = m.type;
    }</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="10942" end="10950" />
        <code>//where</code>
      </source_code>
      <source_code type="functiondef">
        <location start="10950" end="11257" />
        <code>private boolean isSelfCall(Tree tree) {
	    if (tree.tag == Tree.EXEC) {
		Exec exec = (Exec)tree;
		if (exec.expr.tag == Tree.APPLY) {
		    Name mname = TreeInfo.name(((Apply)exec.expr).meth);
		    if (mname == Names._this || mname == Names._super) return 
true;
		}
	    }
	    return false;
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="11259" end="11901" />
        <code>public Type _case(VarDef tree, Env&lt;AttrContext&gt; env) {
	if (env.info.scope.owner.kind == MTH) enter.memberEnter(tree, env);
	chk.validate(tree.vartype);
	VarSymbol v = tree.sym;
	Base.assert(v != null, tree.name);
	if (tree.init != null) {
	    v.pos = Position.MAXPOS; //to catch self references
	    Type itype = attribExpr(
		tree.init, enter.initEnv((VarDef)tree, env), v.type);
	    if (v.constValue instanceof Enter.EnvAttrContextBox) {
		if (itype.constValue != null)
		    v.constValue = cfolder.coerce(itype, v.type).constValue;
		else
		    v.constValue = null;
	    }
	    v.pos = tree.pos;
	}
	return tree.type = v.type;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="11903" end="12356" />
        <code>public Type _case(Block tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; localEnv =
	    env.dup(tree, env.info.dup(env.info.scope.dup()));
	if (env.info.scope.owner.kind == TYP) {
	    localEnv.info.scope.owner = new MethodSymbol(
		tree.flags | BLOCK, Names.empty, null, env.info.scope.owner);
	    if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
	}
	attribStats(tree.stats, localEnv);
	localEnv.info.scope.leave();
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="12358" end="12522" />
        <code>public Type _case(DoLoop tree, Env&lt;AttrContext&gt; env) {
	attribStat(tree.body, env.dup(tree));
	attribExpr(tree.cond, env, Type.booleanType);
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="12524" end="12691" />
        <code>public Type _case(WhileLoop tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.cond, env, Type.booleanType);
	attribStat(tree.body, env.dup(tree));
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="12693" end="13118" />
        <code>public Type _case(ForLoop tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; loopEnv =
	    env.dup(env.tree, env.info.dup(env.info.scope.dup()));
	attribStats(tree.init, loopEnv);
	if (tree.cond != null) attribExpr(tree.cond, loopEnv, Type.booleanType);
	loopEnv.tree = tree; // before, we were not in loop!
	attribStats(tree.step, loopEnv);
	attribStat(tree.body, loopEnv);
	loopEnv.info.scope.leave();
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="13120" end="13239" />
        <code>public Type _case(Labelled tree, Env&lt;AttrContext&gt; env) {
	attribStat(tree.body, env.dup(tree));
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="13241" end="14158" />
        <code>public Type _case(Switch tree, Env&lt;AttrContext&gt; env) {
	Type seltype = attribExpr(tree.selector, env, Type.intType);
	Env&lt;AttrContext&gt; switchEnv =
	    env.dup(tree, env.info.dup(env.info.scope.dup()));

	Set&lt;Object&gt; tags = Set.make();
	boolean hasDefault = false;
	for (List&lt;Case&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
	    Case c = l.head;
	    if (c.pat != null) {
		Type pattype = attribExpr(c.pat, switchEnv, Type.intType);
		if (pattype.tag != ERROR) {
		    if (pattype.constValue == null)
			log.error(c.pat.pos, "constant expression required");
		    else if (tags.contains(pattype.constValue))
			log.error(c.pos, "duplicate case label");
		    else
			tags.put(pattype.constValue);
		}
	    } else if (hasDefault) {
		log.error(c.pos, "duplicate default label");
	    } else {
		hasDefault = true;
	    }
	    attribStats(c.stats, switchEnv);
	}
	switchEnv.info.scope.leave();
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="14160" end="14319" />
        <code>public Type _case(Synchronized tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.lock, env, syms.objectType);
	attribStat(tree.body, env);
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="14321" end="14956" />
        <code>public Type _case(Try tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; tryEnv = env.dup(tree, env.info.dup());
	for (List&lt;Catch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
	    Catch c = l.head;
	    Env&lt;AttrContext&gt; catchEnv =
		env.dup(c, env.info.dup(env.info.scope.dup()));
	    Type ctype = attribStat(c.param, catchEnv);
	    chk.checkType(c.param.vartype.pos, ctype, syms.throwableType);
	    attribStat(c.body, catchEnv);
	    ClassSymbol exc = (ClassSymbol)ctype.tsym;
	    catchEnv.info.scope.leave();
	}
	attribStat(tree.body, tryEnv);
	if (tree.finalizer != null) attribStat(tree.finalizer, env);
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="14958" end="15421" />
        <code>public Type _case(Conditional tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	attribExpr(tree.cond, env, Type.booleanType);
	attribExpr(tree.thenpart, env, pt);
	if (tree.elsepart != null) attribExpr(tree.elsepart, env, pt);
	if (tree.tag == Tree.CONDSTAT)
	    return null;
	else
	    return check(
		tree,
		condType(
		    tree.pos,
		    tree.cond.type, tree.thenpart.type, tree.elsepart.type),
		VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="15422" end="15430" />
        <code>//where</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="15940" end="16190" />
        <code>else if (thentype.tag &lt;= DOUBLE &amp;&amp; elsetype.tag &lt;= DOUBLE) {
		for (int i = BYTE; i &lt;= DOUBLE; i++) {
		    Type candidate = Type.typeOfTag[i];
		    if (thentype.subType(candidate) &amp;&amp;
			elsetype.subType(candidate)) return candidate;
		}
	    }</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="16310" end="16381" />
        <code>} else if (thentype.subType(elsetype)) {
		return elsetype;
	    }</code>
      </source_code>
      <source_code type="elsestatement">
        <location start="16375" end="16456" />
        <code>} else {
		chk.checkType(pos, elsetype, thentype);
		return thentype;
	    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="16461" end="16566" />
        <code>public Type _case(Exec tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.expr, env);
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="16568" end="16713" />
        <code>public Type _case(Break tree, Env&lt;AttrContext&gt; env) {
	tree.target = findJumpTarget(tree.pos, tree.tag, tree.label, env);
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="16715" end="16863" />
        <code>public Type _case(Continue tree, Env&lt;AttrContext&gt; env) {
	tree.target = findJumpTarget(tree.pos, tree.tag, tree.label, env);
	return null;
    }</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="16864" end="16872" />
        <code>//where</code>
      </source_code>
      <source_code type="assignment">
        <location start="16986" end="17019" />
        <code>Env&lt;AttrContext&gt; env1 = env;</code>
      </source_code>
      <source_code type="functiondef">
        <location start="17020" end="17791" />
        <code>while (env1 != null) {
		switch (env1.tree.tag) {
		case Tree.LABELLED:
		    Labelled labelled = (Labelled)env1.tree;
		    if (label == labelled.label) {
			Tree target = labelled.body;
			while (target.tag == Tree.LABELLED) {
			    target = ((Labelled)target).body;
			}
			if (tag == Tree.CONTINUE &amp;&amp;
			    target.tag != Tree.DOLOOP &amp;&amp;
			    target.tag != Tree.WHILELOOP &amp;&amp;
			    target.tag != Tree.FORLOOP)
			    log.error(pos, "not a loop label: " + label);
			return target;
		    }
		    break;
		case Tree.DOLOOP:
		case Tree.WHILELOOP:
		case Tree.FORLOOP:
		    if (label == null) return env1.tree;
		    break;
		case Tree.SWITCH:
		    if (label == null &amp;&amp; tag == Tree.BREAK) return env1.tree;
		    break;
		default:
		}
		env1 = env1.next;
	    }</code>
      </source_code>
      <source_code type="functioncall">
        <location start="17816" end="17862" />
        <code>log.error(pos, "undefined label: " + label);</code>
      </source_code>
      <source_code type="functioncall">
        <location start="17899" end="17944" />
        <code>log.error(pos, "continue outside of loop");</code>
      </source_code>
      <source_code type="functioncall">
        <location start="17955" end="18004" />
        <code>log.error(pos, "break outside switch or loop");</code>
      </source_code>
      <source_code type="functiondef">
        <location start="18027" end="18615" />
        <code>public Type _case(Return tree, Env&lt;AttrContext&gt; env) {
	if (env.enclMethod == null ||
	    env.enclClass.sym.owner == env.enclMethod.sym) {
	    log.error(tree.pos, "return outside method");
	} else {
	    Symbol m = env.enclMethod.sym;
	    if (m.type.restype().tag == VOID) {
		if (tree.expr != null)
		    log.error(
			tree.expr.pos, "can't return a value from method " +
			"whose result type is void");
	    } else if (tree.expr == null) {
		log.error(tree.pos, "missing return value");
	    } else {
		attribExpr(tree.expr, env, m.type.restype());
	    }
	}
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="18617" end="18752" />
        <code>public Type _case(Throw tree, Env&lt;AttrContext&gt; env) {
	Type t = attribExpr(tree.expr, env, syms.throwableType);
	return null;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="18754" end="20177" />
        <code>public Type _case(Apply tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Env&lt;AttrContext&gt; localEnv = env;
	List&lt;Type&gt; argtypes;
	Name methName = TreeInfo.name(tree.meth);
	boolean isConstructorCall =
	    methName == Names._this || methName == Names._super;
	if (isConstructorCall &amp;&amp; checkFirstConstructorStat(tree, env)) {
	    localEnv = env.dup(env.tree, env.info.dup());
	    localEnv.info.isSelfCall = true;
	    argtypes = attribArgs(tree.args, localEnv);
	    Type site = env.enclClass.sym.type;
	    if (methName == Names._super) site = site.supertype();
	    Type encltype = (tree.meth.tag == Tree.SELECT)
		? attribExpr(((Select)tree.meth).selected, env)
		: null;
	    argtypes = constructorArgs(
		tree.meth.pos, localEnv, site, encltype, argtypes);
	} else {
	    argtypes = attribArgs(tree.args, localEnv);
	}

	List&lt;MethodType&gt; saved = methTemplateSupply.elems;
	Type mpt = newMethTemplate(argtypes);
	// optimization, was ... = new MethodType(argtypes, null, null);

	owntype = attribExpr(tree.meth, localEnv, mpt);

	methTemplateSupply.elems = saved; // optimization

	if (isConstructorCall) {
	    Symbol called = TreeInfo.symbol(tree.meth);
	    if (called == env.enclMethod.sym)
		log.error(tree.pos, "recursive constructor invocation");
//todo: handle indirect recursion as well
	}
	return check(tree, owntype, VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="20178" end="20186" />
        <code>//where</code>
      </source_code>
      <source_code type="assignment">
        <location start="20273" end="20316" />
        <code>MethodDef enclMethod = env.enclMethod;</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="20317" end="20531" />
        <code>if (enclMethod != null &amp;&amp; enclMethod.name == Names.init) {
		Block body = (Block)enclMethod.body;
		if (body.stats.head.tag == Tree.EXEC &amp;&amp;
		    ((Exec)body.stats.head).expr == tree)
		    return true;
	    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="20671" end="20780" />
        <code>/** optimization: To save allocating a new methodtype for every apply,
	 *  we use a reservoir.
	 */</code>
      </source_code>
      <source_code type="functioncall">
        <location start="20860" end="20863" />
        <code>();</code>
      </source_code>
      <source_code type="functiondef">
        <location start="20865" end="21211" />
        <code>public Type newMethTemplate(List&lt;Type&gt; argtypes) {
	    if (methTemplateSupply.elems == methTemplateSupply.last)
		methTemplateSupply.append(new MethodType(null, null, null));
	    MethodType mt = methTemplateSupply.elems.head;
	    methTemplateSupply.elems = methTemplateSupply.elems.tail;
	    mt.argtypes = argtypes;
	    return mt;
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="21213" end="24682" />
        <code>public Type _case(NewClass tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	ClassDef cdef = tree.def;

	// if enclosing class is given, attribute it, and
	// complete class name to be fully qualified
	Type encltype = null;
	Tree clazz = tree.clazz;
	if (tree.encl != null) {
	    encltype = attribExpr(tree.encl, env);
	    if (encltype.tag == CLASS) {
		clazz = make.at(clazz.pos).Select(
		    make.Type(encltype), ((Ident)tree.clazz).name);
//		new Pretty().printExpr(clazz);//DEBUG
	    }
	}

	// attribute clazz and store symbol + type back into tree
	Type clazztype = chk.checkClassType(
	    tree.clazz.pos, attribType(clazz, env));
	chk.validate(clazz);	
	if (tree.encl != null) {
	    tree.clazz.type = clazztype;
	    ((Ident)tree.clazz).sym = TreeInfo.symbol(clazz);
	}

	// attribute arguments;
	List&lt;Type&gt; rawArgtypes = attribArgs(tree.args, env);
	List&lt;Type&gt; argtypes = rawArgtypes;

	if (clazztype.tag == CLASS) {
	    Type site = clazztype.tsym.type;
	    List&lt;Type&gt; typarams = clazztype.typarams();

	    // resolve constructor, if not abstract
	    if (cdef == null &amp;&amp;
		(clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
		log.error(tree.pos,
		    clazztype.tsym + " is abstract; cannot be instantiated");
	    } else if (cdef != null &amp;&amp;
		       (clazztype.tsym.flags() &amp; INTERFACE) != 0) {
		if (rawArgtypes.nonEmpty()) {
		    log.error(tree.pos,
			      "anonymous class implements interface; " +
			      "cannot have arguments");
		    rawArgtypes = argtypes = Type.emptyList;
		} else if (tree.encl != null) {
		    log.error(tree.pos,
			      "anonymous class implements interface; " +
			      "cannot have qualifier for new");
		}
	    } else {
		argtypes = constructorArgs(
		    tree.pos, env, site, encltype, rawArgtypes);
		boolean selectSuperPrev = env.info.selectSuper;
		if (cdef != null) env.info.selectSuper = true;
		tree.constructor = rs.resolveConstructor(
		    tree.pos, env, site, typarams, argtypes);
		env.info.selectSuper = selectSuperPrev;
	    }

	    // if it's an anonymous class...
	    if (cdef != null) {

		// complete class definition with extends/implements clause
	        // and enter + attribute it.
		if (Resolve.isStatic(env)) cdef.flags |= STATIC;

		Tree clazz1 = make.at(cdef.pos).Type(clazztype);
		if ((clazztype.tsym.flags() &amp; INTERFACE) != 0) {
		    cdef.implementing = List.make(clazz1);
		} else {
		    cdef.extending = clazz1;
		}
		attribStat(cdef, env.dup(tree));
//	        new Pretty().printStat(cdef);//DEBUG

		// if enclosing class is given,
		// add it to constructor arguments
		if (tree.encl != null) {
		    tree.args = tree.args.prepend(tree.encl);
		    rawArgtypes = rawArgtypes.prepend(encltype);
		    tree.encl = null;
		    encltype = null;
		}

		// reassign site, typarams and recompute constructor
		site = cdef.sym.type;
		typarams = Type.emptyList;
		argtypes = constructorArgs(
		    tree.pos, env, site, encltype, rawArgtypes);
		tree.constructor = rs.resolveConstructor(
		    tree.pos, env, site, typarams, argtypes);
	    }
	    if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) {
		owntype = rs.instantiate(
		    site, tree.constructor, typarams, argtypes);
		if (owntype == null) {//debug
		    log.error(
			tree.pos, "internal error; cannot instantiate " +
			tree.constructor + " to (" + argtypes + ")");
		}
	    }
	}
	return check(tree, owntype, VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="24684" end="25605" />
        <code>public Type _case(NewArray tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Type elemtype;
	if (tree.elemtype != null) {
	    elemtype = attribType(tree.elemtype, env);
	    if (elemtype.tag == TYPEVAR) {
		log.warning(tree.pos, "unchecked generic array creation");
	    }
	    chk.validate(tree.elemtype);
	    owntype = elemtype;
	    for (List&lt;Tree&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
		attribExpr(l.head, env, Type.intType);
		owntype = new ArrayType(owntype);
	    }
	} else {
	    if (pt.tag == ARRAY) {
		elemtype = pt.elemtype();
	    } else {
		if (pt.tag != ERROR) {
		    log.error(tree.pos, "illegal initializer for " + pt);
		}
		elemtype = Type.errType;
	    }
	}
	if (tree.elems != null) {
	    attribExprs(tree.elems, env, elemtype);
	    owntype = new ArrayType(elemtype);
	}
	return check(tree, owntype, VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="25607" end="25869" />
        <code>public Type _case(Assign tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = attribTerm(tree.lhs, env.dup(tree), VAR, pt);
	attribExpr(tree.rhs, env, owntype);
	return check(tree, owntype, VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="25871" end="26519" />
        <code>public Type _case(Assignop tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	List&lt;Type&gt; argtypes = List.make(
	    attribTerm(tree.lhs, env, VAR, Type.noType),
	    attribExpr(tree.rhs, env));
	Symbol operator = tree.operator = rs.resolveOperator(
	    tree.pos, tree.tag - Tree.ASGOffset, env, argtypes);
	Type owntype = argtypes.head;
	if (operator.kind == MTH) {
	    if (owntype.tag &lt;= DOUBLE)
		chk.checkCastable(
		    tree.rhs.pos, operator.type.restype(), owntype);
	    else
		chk.checkType(
		    tree.rhs.pos, operator.type.restype(), owntype);
	}
	return check(tree, owntype, VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="26521" end="27711" />
        <code>public Type _case(Operation tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	List&lt;Type&gt; argtypes;
	if (Tree.PREINC &lt;= tree.tag &amp;&amp; tree.tag &lt;= Tree.POSTDEC)
	    argtypes = Type.emptyList.prepend(
		attribTerm(tree.args.head, env, VAR, Type.noType));
	else
	    argtypes = attribArgs(tree.args, env);
	Symbol operator = tree.operator = rs.resolveOperator(
	    tree.pos, tree.tag, env, argtypes);
	Type owntype = Type.errType;
	if (operator.kind == MTH) {
	    owntype = operator.type.restype();
	    int opc = ((OperatorSymbol)operator).opcode;
	    List&lt;Type&gt; l = argtypes;
	    while (l.nonEmpty() &amp;&amp; l.head.constValue != null) l = l.tail;
	    if (l.isEmpty()) {
		Type ctype = cfolder.fold(tree.pos, opc, argtypes);
		if (ctype != null) owntype = cfolder.coerce(ctype, owntype);
	    }
	    if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne) &amp;&amp;
		!argtypes.head.castableTo(argtypes.tail.head.erasure()) &amp;&amp;
		!argtypes.tail.head.castableTo(argtypes.head.erasure())) {
		log.error(
		    tree.pos, "incomparable types: " +
		    argtypes.head + " and " + argtypes.tail.head);
	    }
	}
	return check(tree, owntype, VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="27713" end="28125" />
        <code>public Type _case(TypeCast tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type clazztype = attribType(tree.clazz, env);
	Type exprtype = attribExpr(tree.expr, env);
	Type owntype = chk.checkCastable(tree.expr.pos, exprtype, clazztype);
	if (exprtype.constValue != null)
	    owntype = cfolder.coerce(exprtype, owntype);
	return check(tree, owntype, VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="28127" end="28767" />
        <code>public Type _case(TypeTest tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type exprtype = attribExpr(tree.expr, env);

        // The following check is correct for GJ but not for NextGen  Corky 
6/28/00
	/* Type clazztype = chk.checkClassOrArrayType(
	   tree.clazz.pos, attribType(tree.clazz, env)); */
        // In the following invocation, attribType(tree.clazz,env) replaces 
clazztype, which is consistent with successful return from checkClassOrArrayType
	chk.checkCastable(tree.expr.pos, exprtype, attribType
(tree.clazz,env));  
	return check(tree, Type.booleanType, VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="28769" end="29209" />
        <code>public Type _case(Indexed tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Type atype = attribExpr(tree.indexed, env);
	attribExpr(tree.index, env, Type.intType);
	if (atype.tag == ARRAY)
	    owntype = atype.elemtype();
	else if (atype.tag != ERROR)
	    log.error(tree.pos, "array required, but " + atype + " found");
	return check(tree, owntype, VAR, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="29211" end="31574" />
        <code>public Type _case(Ident tree, Env&lt;AttrContext&gt; env) {
	int pkind = env.info.pkind;
	Type pt = env.info.pt;
	Symbol sym;
	
	// find symbol
	if (pt.tag == METHOD) {
	    if (tree.name == Names._super || tree.name == Names._this) {
		sym = rs.resolveSelfConstructor(
		    tree.pos, env, tree.name, pt.argtypes());
	    } else {
		sym = rs.resolveMethod(
		    tree.pos, env, tree.name, Type.emptyList, pt.argtypes());
	    }
	} else {
	    sym = rs.resolveIdent(tree.pos, env, tree.name, pkind);
	}
	tree.sym = sym;

	//check that symbol does not hide identifier in outer class
	if (env.enclClass.sym.owner.kind != PCK &amp;&amp;
	    (sym.kind &amp; (VAR | MTH)) != 0 &amp;&amp; 	
	    sym.owner.kind == TYP &amp;&amp;
	    tree.name != Names._super &amp;&amp; tree.name != Names._this) {
	    Env&lt;AttrContext&gt; env1 = env;
	    while (env1.outer != null &amp;&amp; !env1.enclClass.sym.subclass
(sym.owner))
		env1 = env1.outer;
	    if (env1 != null &amp;&amp; env1.enclClass.sym != sym.owner) {
		do {
		    env1 = env1.outer;
		} while (env1 != null &amp;&amp;
		       (env1.info.scope == null ||
			checkNotHiding(tree.pos, sym, env1.info.scope)) &amp;&amp;
		       (env1.enclClass == null ||
			checkNotHiding(tree.pos, sym, env1.enclClass.sym.members
())));
	    }
	}
		
	// if symbol is a variable, evaluate its initializer, if it has one
	// if it is a local variable accessed from an embedded inner class,
	// mark it as captured, and check that it is final.
	if (sym.kind == VAR) {
	    VarSymbol v = (VarSymbol)sym;
	    checkInit(tree, env, v);
	    if (v.owner.kind == MTH &amp;&amp;
		v.owner != env.info.scope.owner &amp;&amp;
		(v.flags_field &amp; CAPTURED) == 0) {
		v.flags_field |= CAPTURED;
		if ((v.flags_field &amp; FINAL) == 0) {
		    log.error(
			tree.pos, "local " + v +
			" is accessed from within inner class; " +
			" needs to be declared final");
		}
	    }
	    if (pkind == VAR)
		checkAssignable(tree.pos, v, null, env);
	}

	// in constructor body:
        // if symbol is a field or instance method, check that it is not 
accessed
        // before supertype constructor is called.
	if (env.info.isSelfCall &amp;&amp;
	    sym.owner != null &amp;&amp; sym.owner.kind == TYP &amp;&amp;
	    (sym.flags() &amp; STATIC) == 0 &amp;&amp;
	    env.enclClass.sym.subclass(sym.owner) &amp;&amp;
	    sym.name != Names.init)
	    chk.earlyRefError(tree.pos, sym.kind == VAR ? sym : thisSym(env));

	return checkId(tree, env.enclClass.sym.type, sym, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="31576" end="33194" />
        <code>public Type _case(Select tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	int skind = 0;
	if (tree.name == Names._this || tree.name == Names._class) {
	    skind = TYP;
	} else {
	    if ((pkind &amp; PCK) != 0) skind = skind | PCK;
	    if ((pkind &amp; TYP) != 0) skind = skind | TYP | PCK;
	    if ((pkind &amp; (VAL | MTH)) != 0) skind = skind | VAL | TYP;
	}
	Type site = attribTerm(tree.selected, env, skind, Type.noType);
	Symbol sitesym = TreeInfo.symbol(tree.selected);
	
	boolean selectSuperPrev = env.info.selectSuper;
	env.info.selectSuper =
	    sitesym != null &amp;&amp;
	    (sitesym.name == Names._super || sitesym.kind == TYP);

	Symbol sym = selectSym(tree, site, env, pt, pkind);
	tree.sym = sym;

	if (sym.kind == VAR) {
	    VarSymbol v = (VarSymbol)sym;
	    evalInit(v, env);
	    if (pkind == VAR)
		checkAssignable(tree.pos, v, tree.selected, env);
	}

	if (env.info.selectSuper) {
	    if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
		sym.name != Names._this &amp;&amp; sym.name != Names._super) {
		if (sitesym.name == Names._super) {
		    rs.checkNonAbstract(tree.pos, sym);
		} else if (sym.kind == VAR || sym.kind == MTH) {
		    rs.access(new Resolve.StaticError(sym),
			      tree.pos, site, sym.name);
		}
		if (env.info.isSelfCall &amp;&amp;
		    sym.name != Names.init &amp;&amp;
		    tree.name == Names._this &amp;&amp;
		    site.tsym == env.enclClass.sym) {
		    chk.earlyRefError(tree.pos, sym);
		}
		Type site1 = env.enclClass.sym.type.asSuper(site.tsym);
		if (site1 != null) site = site1;
	    }
	    env.info.selectSuper = selectSuperPrev;
	}
	return checkId(tree, site, sym, pkind, pt);
    }</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="33195" end="33203" />
        <code>//where</code>
      </source_code>
      <source_code type="multicomment">
        <location start="33203" end="33560" />
        <code>/** determine symbol referenced by a Select expression,
	 *  @param pos    position for error reporting
	 *  @param site   the type of the selected expression
	 *  @param name   the selector name
	 *  @param env    the current environment
	 *  @param pt     the current prototype
	 *  @param pkind  the expected kind(s) of the Select expression
	 */</code>
      </source_code>
      <source_code type="assignment">
        <location start="33667" end="33691" />
        <code>int pos = tree.pos;</code>
      </source_code>
      <source_code type="assignment">
        <location start="33692" end="33719" />
        <code>Name name = tree.name;</code>
      </source_code>
      <source_code type="functiondef">
        <location start="33720" end="35223" />
        <code>switch (site.tag) {
	    case PACKAGE:
		return rs.access(
		    rs.findIdentInPackage(env, site.tsym, name, pkind),
		    pos, site, name);
	    case ARRAY:
	    case CLASS:
		if (pt.tag == METHOD) {
		    if (name == Names._super) {
			return rs.resolveSelfConstructor(
			    pos, env, name, pt.argtypes());
		    } else {
			return rs.resolveQualifiedMethod(
			    pos, env, site, name, Type.emptyList, pt.argtypes
());
		    }
		} else if (name == Names._this) {
		    return rs.resolveSelf(pos, env, site.tsym, name);
		} else if (name == Names._class) {
		    return new VarSymbol(
			STATIC | PUBLIC, Names._class, syms.classType, 
site.tsym);
		} else {
		    Symbol sym = rs.findIdentInType(env, site, name, pkind);
		    if (sym.kind &gt;= rs.AMBIGUOUS) {
			if ((pkind &amp; (TYP | PCK)) != 0) {
			    Name pname = TreeInfo.fullName(tree.selected);
			    if (pname != null) {
				PackageSymbol p = syms.reader.enterPackage
(pname);
				Symbol sym1 = rs.findIdentInPackage(
				    env, p, name, pkind);
				if (sym1.kind &lt; sym.kind) sym = sym1;
			    }
			}
			sym = rs.access(sym, pos, site, name);
		    }
		    return sym;
		}
	    case TYPEVAR:
		return selectSym(tree, site.bound(), env, pt, pkind);
	    case ERROR:
		return Symbol.errSymbol;
	    default:
		if (name == Names._class) {
		    return new VarSymbol(
			STATIC | PUBLIC, Names._class, syms.classType, 
site.tsym);
		} else {	
		    log.error(pos, site + " cannot be dereferenced");
		}
		return Symbol.errSymbol;
	    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="35227" end="35971" />
        <code>/** determine type of identifier or select expression and check that
	 *  (1) the referenced symbol is not deprecated
	 *  (2) the symbol type is safe (@see checkSafe)
	 *  (3) if symbol is a variable, check that its type and kind are
	 *      compatible with the prototype and protokind.
	 *  (4) if symbol is a field of a raw type, which is being assigned to,
	 *      issue a warning if its type changes under erasure.
	 *  (5) if symbol is a method of a raw type, issue a warning if
	 *      its argument types change under erasure.
	 *  if checks succeed
	 *    if symbol is a constant return its constant type
	 *    else if symbol is a method return its result type
	 *    otherwise return its type
	 *  else return errType
	 */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="35972" end="38103" />
        <code>Type checkId(Tree tree, Type site, Symbol sym, int pkind, Type pt) {
	    if ((sym.flags() &amp; DEPRECATED) != 0) warnDeprecated(tree.pos, sym);
	    Type owntype;
	    switch (sym.kind) {
	    case TYP:
		owntype = sym.type;
		if (owntype.tag == CLASS &amp;&amp; owntype.typarams().nonEmpty()) {
		    owntype = new ClassType(
			owntype.outer(), Type.emptyList, owntype.tsym);
		}
		break;
	    case VAR:
		VarSymbol v = (VarSymbol)sym;
		if (!chk.unchecked &amp;&amp;
		    pkind == VAR &amp;&amp;
		    v.owner.kind == TYP &amp;&amp;
		    (v.flags() &amp; STATIC) == 0 &amp;&amp;
		    site.tag == CLASS) {
		    Type s = site.asOuterSuper(v.owner);
		    if (s != null &amp;&amp;
			s.isRaw() &amp;&amp;
			!v.type.sameType(v.erasure())) {
			log.warning(
			    tree.pos,
			    "unchecked assignment to " + v + " of raw type " + 
site);
		    }
		}
		owntype = (sym.owner.kind == TYP)
		    ? site.memberType(sym)
		    : sym.type;
		if (v.constValue != null) owntype = owntype.constType
(v.constValue);
		break;
	    case MTH:
//todo: find out why this can be false
//		Base.assert(site.asOuterSuper(sym.owner) != null,
//			    sym + " " + site + " " + sym.owner);//DEBUG
		if (!chk.unchecked &amp;&amp;
		    (sym.flags() &amp; STATIC) == 0 &amp;&amp;
		    site.tag == CLASS) {
		    Type s= site.asOuterSuper(sym.owner);
		    if (s != null &amp;&amp;
			s.isRaw() &amp;&amp;
			sym.name != Names.init &amp;&amp;
			!Type.sameTypes(
			    sym.type.argtypes(), sym.erasure().argtypes())) {
			log.warning(
			    tree.pos,
			    "unchecked call to " + sym + " of raw type " + 
site);
		    }
		}
		if (sym.name == Names.init) {
		    owntype = Type.voidType;
		} else {
		    owntype = rs.instantiate(
			site, sym, Type.emptyList, pt.argtypes());
		    if (owntype == null) {//debug
			log.error(
			    tree.pos, "internal error; cannot instantiate " +
			    sym + " at " + site + " to (" + pt.argtypes() 
+ ")");
		    }
		}
		break;
	    case PCK: case ERR:
		owntype = sym.type;
		break;
	    default:
		new Pretty().printExpr(tree);//debug
		throw new InternalError("unexpected kind: " + sym.kind);
	    }
	    infer.checkSafe(tree.pos, owntype, sym);
	    return check(tree, owntype, sym.kind, pkind, pt);
	}</code>
      </source_code>
      <source_code type="multicomment">
        <location start="38104" end="38218" />
        <code>/** check that variable is initialized and evaluate the variable's
	 *  initializer, if not yet done
	 */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="38219" end="38807" />
        <code>private void checkInit(Tree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
//	    System.err.println(v + " " + ((v.flags() &amp; STATIC) != 0) + " " +
//			       tree.pos + " " + v.pos + " " +
//			       (env.info.staticLevel &gt; 
env.outer.info.staticLevel));//DEBUG
	    if (v.pos &gt; tree.pos &amp;&amp;
		(v.owner.kind == MTH ||
		 (v.owner.kind == TYP &amp;&amp;
		  v.owner == env.info.scope.owner &amp;&amp;
		  ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env))) &amp;&amp;
		(env.tree.tag != Tree.ASSIGN || tree != ((Assign)env.tree).lhs))
		log.error(tree.pos, "illegal forward reference");
	    evalInit(v, env);
	}</code>
      </source_code>
      <source_code type="multicomment">
        <location start="38808" end="38893" />
        <code>/** evaluate a final variable's initializer
	 *  and set variable's constValue
	 */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="38894" end="39374" />
        <code>void evalInit(VarSymbol v, Env&lt;AttrContext&gt; env) {
	    if (v.constValue instanceof Enter.EnvAttrContextBox) {
		Env&lt;AttrContext&gt; evalEnv =
		    ((Enter.EnvAttrContextBox)v.constValue).env;
		Name prev = log.useSource(evalEnv.toplevel.sourcefile);
		v.constValue = null;
		Type itype = attribExpr(
		    ((VarDef)evalEnv.tree).init, evalEnv, v.type);
		if (itype.constValue != null)
		    v.constValue = cfolder.coerce(itype, v.type).constValue;
		log.useSource(prev);
	    }
	}</code>
      </source_code>
      <source_code type="multicomment">
        <location start="39375" end="39477" />
        <code>/** check that `sym' does not hide any symbols of the same name and
	 *  kind in `scope'
	 */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="39478" end="40036" />
        <code>boolean checkNotHiding(int pos, Symbol sym, Scope scope) {
	    Scope.Entry e = scope.lookup(sym.name);
	    while (e.scope != null) {
		if (e.sym.owner != sym.owner &amp;&amp;
		    e.sym.kind == sym.kind &amp;&amp;
		    e.sym.owner == scope.owner) {
		    log.error(
			pos, sym + " is inherited from " + sym.owner +
			" and hides a " + Resolve.kindName(sym.kind) +
			" of the same name" + e.sym.location() +
			". An explicit `this' qualifier must be used to select 
the desired instance  ");
		    return false;
		}
		e = e.next();
	    }
	    return true;
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="40038" end="40244" />
        <code>public Type _case(Literal tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	return check(
	    tree, litType(tree.typetag).constType(tree.value), VAL, pkind, pt);
    }</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="40245" end="40253" />
        <code>//where</code>
      </source_code>
      <source_code type="functiondef">
        <location start="40253" end="40355" />
        <code>Type litType(int tag) {
	    return (tag == CLASS) ? syms.stringType : Type.typeOfTag[tag];
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="40357" end="40544" />
        <code>public Type _case(TypeIdent tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	return check(tree, Type.typeOfTag[tree.typetag], TYP, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="40546" end="40771" />
        <code>public Type _case(TypeArray tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type etype = attribType(tree.elemtype, env);
	return check(tree, new ArrayType(etype), TYP, pkind, pt);
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="40772" end="40942" />
        <code>/** attribute type application.
     *  bound checking is left until later, since types are attributed
     *  before supertype structure is completely known
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="40943" end="41947" />
        <code>public Type _case(TypeApply tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;

	Type clazztype = chk.checkClassType(
	    tree.clazz.pos, attribType(tree.clazz, env));

	ListBuffer&lt;Type&gt; actbuf = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = tree.arguments; l.nonEmpty(); l = l.tail)
	    actbuf.append(chk.checkRefType(l.head.pos, attribType(l.head, 
env)));
	List&lt;Type&gt; actuals = actbuf.toList();

	if (clazztype.tag == CLASS) {
	    List&lt;Type&gt; formals = clazztype.tsym.type.typarams();
	    if (actuals.length() == formals.length()) {
		owntype = new ClassType(
		    clazztype.tsym.type.outer(), actuals, clazztype.tsym);
	    } else {
		log.error(
		    tree.pos,
		    (formals.length() != 0)
		        ? "wrong number of type arguments; required: " +
		          formals.length()
		        : "type " + clazztype + " does not take parameters");
		owntype = Type.errType;
	    }
	}
	return check(tree, owntype, TYP, pkind, pt);
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="41949" end="42273" />
        <code>public Type _case(TypeParameter tree, Env&lt;AttrContext&gt; env) {
	TypeVar a = (TypeVar)tree.type;
	if (tree.extBound != null)
	    a.bound = attribBase(tree.extBound, env, 0);
	else if (tree.implBound != null)
	    a.bound = attribBase(tree.implBound, env, INTERFACE);
	else
	    a.bound = syms.objectType;
	return a;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="42275" end="42376" />
        <code>public Type _case(Erroneous tree, Env&lt;AttrContext&gt; env) {
	return tree.type = Type.errType;
    }</code>
      </source_code>
      <source_code type="functiondef">
        <location start="42378" end="42468" />
        <code>public Type _case(Tree tree, Env&lt;AttrContext&gt; env) {
	throw new InternalError();
    }</code>
      </source_code>
      <source_code type="multicomment">
        <location start="42469" end="42555" />
        <code>/** main method: attribute class definition associated given class symbol
     */</code>
      </source_code>
      <source_code type="functiondef">
        <location start="42556" end="44341" />
        <code>public void attribClass(ClassSymbol c) {
	Type st = c.type.supertype();
	if (st.tag == CLASS) attribClass((ClassSymbol)st.tsym);
	if (c.owner.kind == TYP) attribClass((ClassSymbol)c.owner);
	
	if ((c.flags_field &amp; UNFINISHED) != 0) {
	    Name prev = log.useSource(c.sourcefile);
	    c.flags_field &amp;= ~UNFINISHED;

	    Env&lt;AttrContext&gt; env = enter.classEnvs.get(c);
	    enter.classEnvs.remove(c);

	    ClassDef tree = (ClassDef)env.tree;
	
	    implementInterfaceMethods(c, env);
	    chk.validateTypeParams(tree.typarams);
	    chk.validate(tree.extending);
	    chk.validate(tree.implementing);
	    if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0)
		chk.checkAllDefined(tree.pos, c);
	    chk.checkClassBounds(tree.pos, c);
	
	    if (tree.typarams.length() != 0 &amp;&amp; c.subclass
(syms.throwableType.tsym))
		log.error(tree.pos,
			  "subtypes of java.lang.Throwable cannot have 
arguments");
	    tree.type = c.type;
	
	    for (List&lt;TypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = 
l.tail)
		env.info.scope.enterIfAbsent(l.head.type.tsym);
	
	    if ((c.flags() &amp; INTERFACE) == 0) {
		VarSymbol thisSym = new VarSymbol(FINAL, Names._this, c.type, 
c);
		thisSym.pos = Position.FIRSTPOS;
		env.info.scope.enter(thisSym);
		if (st.tag == CLASS) {
		    VarSymbol superSym = new VarSymbol(FINAL, Names._super, st, 
c);
		    superSym.pos = Position.FIRSTPOS;
		    env.info.scope.enter(superSym);
		}
		chk.checkImplementations(tree.pos, c);
	    } else {
		c.members_field = c.members_field.dup();
		implementInterfaceMethods(c, env);
		chk.checkImplementations(tree.pos, c);
		c.members_field = c.members_field.leave();
	    }
	
	    attribStats(tree.defs, env);
//	    checkConstructorsNonCyclic(tree.defs, env);
	    tree.type = c.type;

	    log.useSource(prev);
	}
    }</code>
      </source_code>
      <source_code type="class">
        <location start="44484" end="44594" />
        <code>[public class X {
    Object foo(Stack&lt;X&gt; s) {
    }
    List&lt;T&gt; bar(int pos, T x1, T x2, List&lt;T&gt; l) {
    }
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build 20020321 stable
Importing the file below causes an Out of Memory error in eclipse.  Here is the 
log file:
Log: Wed Mar 27 14:38:33 CST 2002
1 org.eclipse.core.resources 4 Unhandled exception caught in event loop.
Log: Wed Mar 27 14:38:33 CST 2002
4 org.eclipse.ui 0 java.lang.OutOfMemoryError
java.lang.OutOfMemoryError
	&lt;&lt;no stack trace available&gt;&gt;

Problem seems to be associated with parsing the file.  If I turn auto build 
off, the error doesn't appear until I expand the package in the packages view.  
If I turn off Show Members in Packages View it doesn't appear until I open the 
file in the Java editor.  The file is part of the Dr Java package from Rice 
university (http://drjava.sourceforge.net/).  It appears to be compiled with a 
generics compliant compiler as the extends clause contains the following: 
extends Tree.Visitor&lt;Type,Env&lt;AttrContext&gt;&gt;.

As this is not valid Java, I wouldn't expect this to compile.  However, the out 
of memory error could possibly be avoided.  I am able to recreate the problem 
by having autobuild turned on and importing the file into an existing project.



/* ************************************************************************
 * GJC attribution phase
 * by Martin Odersky
 *
 * Copyright (C) 1996-98 Martin Odersky. All rights reserved.
 * Permission is hereby granted to use and modify this software for evaluation
 * and research purposes. Modification and use for other purposes requires
 * prior written permission by the author. The software, or modifications
 * thereof may be given to third parties only with prior written permission
 * by the author.
 *************************************************************************/

package edu.rice.cs.nextgen.compiler.comp;

import edu.rice.cs.nextgen.compiler.util.*;
import edu.rice.cs.nextgen.compiler.code.*;
import edu.rice.cs.nextgen.compiler.tree.*;

import Symbol.*;
import Tree.*;
import Type.*;

public class Attr
extends Tree.Visitor&lt;Type,Env&lt;AttrContext&gt;&gt;
implements /* imports */ Flags, Kinds, TypeTags {

    Log log;
    Symtab syms;
    Resolve rs;
    Check chk;
    Infer infer;
    TreeMaker make;
    public Enter enter;
    public ConstFold cfolder;

    public Attr(Log log, Symtab syms,
		Resolve rs, Check chk, Infer infer,
		TreeMaker make, Enter enter) {
	this.log = log;
	this.syms = syms;
	this.rs = rs;
	this.chk = chk;
	this.infer = infer;
	this.make = make;
	this.enter = enter;
	if (enter != null) enter.attr = this;
	this.cfolder = new ConstFold(log, syms);
    }

    /** check kind and type of given tree against prototype
     *  store resulting type to tree and return it.
     *  no checks are performed if the prototype is a method type.
     *  Its not necessary in this case since we know that kind and type
     *  are correct.
     */
    Type check(Tree tree, Type owntype, int ownkind, int pkind, Type pt) {
	if (owntype.tag != ERROR &amp;&amp; pt.tag != METHOD) {
	    if ((ownkind &amp; ~pkind) == 0) {
		if (pt.tag != NONE)
		    owntype = chk.checkType(tree.pos, owntype, pt);
	    } else {
		log.error(tree.pos,
			  Resolve.kindNames(pkind) + " required, but " +
			  Resolve.kindName(ownkind) + " found");
		owntype = Type.errType;
	    }
	}
	tree.type = owntype;
	return owntype;
    }

    /** is variable `v' assignable, i.e. in a scope where it may be assigned to
     *  even if it is final?
     */
    static boolean finalAssignable(VarSymbol v, Env&lt;AttrContext&gt; env) {
	Symbol owner = env.info.scope.owner;
	return
	    v.constValue == null
	    &amp;&amp;
	    (v.owner == owner
	     ||
	     ((owner.name == Names.init || (owner.flags() &amp; BLOCK) != 0)
	      &amp;&amp;
	      v.owner == owner.owner
	      &amp;&amp;
	      ((v.flags() &amp; STATIC) != 0) == (Resolve.isStatic(env))));
    }

    /** check that variable `v' can be assigned to.
     */
    void checkAssignable(int pos, VarSymbol v, Tree base, Env&lt;AttrContext&gt; env) 
{
	if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
	    !((base == null ||
	       (base.tag == Tree.IDENT &amp;&amp; TreeInfo.name(base) == Names._this)) 
&amp;&amp;
	      finalAssignable(v, env))) {
	    log.error(pos, "can't assign a value to final " + v);
	}
    }

    /** warn about deprecated symbol if not in currently ccompiled files
     */
    void warnDeprecated(int pos, Symbol sym) {
	if (!enter.compiled.contains(sym.enclClass().fullname))
	    log.warning(pos, sym + sym.location() + " has been deprecated");
    }

    /** the current `this' symbol
     */
    Symbol thisSym(Env&lt;AttrContext&gt; env) {
	return rs.resolveSelf(
	    Position.NOPOS, env, env.enclClass.sym, Names._this);
    }

    /** if `site' is an inner class, prepend outer instance to argtypes
     *  outer instance is taken to be `outer' if not null, is made up otherwise.
     */
    List&lt;Type&gt; constructorArgs(int pos, Env&lt;AttrContext&gt; env,
			       Type site, Type outer, List&lt;Type&gt; argtypes) {
	if (site.outer().tag == CLASS) {
	    if (outer == null) {
		Symbol outerthis = rs.resolveSelf(
		    pos, env, site.outer().tsym, Names._this);
		if (outerthis.kind == VAR) {
/*//todo: revise this
		    if (env.info.isSelfCall &amp;&amp;
			outerthis.owner == env.enclClass.sym)
			chk.earlyRefError(pos, outerthis);
 */
		    outer = outerthis.owner.type;
		} else {
		    outer = Type.errType;
		}
	    }
	    argtypes = argtypes.prepend(outer);
	} else if (outer != null &amp;&amp; outer.tag == CLASS &amp;&amp; site.tag != ERROR) {
	    log.error(pos,
		"illegal qualifier; " + site.tsym + " is not an inner class");
	}
	return argtypes;
    }

    Type attribTerm(Tree tree, Env&lt;AttrContext&gt; env, int pkind, Type pt) {
	try {
	    env.info.pkind = pkind;
	    env.info.pt = pt;
	    return tree.visit(this, env);
	} catch (CompletionFailure ex) {
	    return chk.completionError(tree.pos, ex);
	}
    }	

    Type attribExpr(Tree tree, Env&lt;AttrContext&gt; env, Type pt) {
	return attribTerm(tree, env, VAL, pt);
    }

    Type attribExpr(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribExpr(tree, env, Type.noType);
    }

    Type attribType(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribTerm(tree, env, TYP, Type.noType);
    }

    Type attribStat(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribTerm(tree, env, NIL, Type.noType);
    }

    List&lt;Type&gt; attribExprs(List&lt;Tree&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
	ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = trees; l.nonEmpty(); l = l.tail)
	    ts.append(attribExpr(l.head, env, pt));
	return ts.toList();
    }

    &lt;T extends Tree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
	for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
	    attribStat(l.head, env);
    }

    List&lt;Type&gt; attribArgs(List&lt;Tree&gt; trees, Env&lt;AttrContext&gt; env) {
	ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = trees; l.nonEmpty(); l = l.tail)
	    argtypes.append(chk.checkNonVoid(
		l.head.pos, attribExpr(l.head, env)));
	return argtypes.toList();
    }

    /** attribute extended or implemented type reference
     */
    Type attribBase(Tree tree, Env&lt;AttrContext&gt; env, int interfaceFlag) {
	Type t = chk.checkClassType(tree.pos, attribType(tree, env));
	if ((t.tsym.flags() &amp; INTERFACE) != interfaceFlag) {
	    log.error(tree.pos,
		(interfaceFlag == 0 ? "no " : "") + "interface expected here");
	}
	if ((t.tsym.flags() &amp; FINAL) != 0) {
	    log.error(tree.pos, "can't inherit from final " + t.tsym);
	}
	return t;
    }

/* ********************************************************************
 * Adding miranda methods
 *********************************************************************/

    /** add an abstract method definition to class definition `cd'
     *  for a method `m' defined in an interface
     */
    private void addAbstractMethod(ClassDef cd,
				   MethodSymbol m,
				   Env&lt;AttrContext&gt; env) {
//	System.err.println("add abstract method: " + m);//DEBUG
	Tree def = make.at(cd.pos).MethodDef(
	    new MethodSymbol(
		m.flags() | IPROXY, m.name, cd.sym.type.memberType(m), cd.sym),
	    null);
	cd.defs = cd.defs.prepend(def);
	enter.memberEnter(def, env);
    }

    /** add abstract method definitions for all methods defined in one of
     *  c's interfaces, provided they are not already implemented
     *  env = the environment for the class definition of c.
     */
    void implementInterfaceMethods(ClassSymbol c, Env&lt;AttrContext&gt; env) {
	ClassDef cd = (ClassDef)env.tree;
	for (List&lt;Type&gt; l = c.type.interfaces(); l.nonEmpty(); l = l.tail) {
	    ClassSymbol i = (ClassSymbol)l.head.tsym;
	    for (Scope.Entry e = i.members().elems;
		 e != null;
		 e = e.sibling) {
		if (e.sym.kind == MTH &amp;&amp;
		    (e.sym.flags() &amp; STATIC) == 0) // disregard &lt;clinit&gt;!
		{
		    MethodSymbol absMeth = (MethodSymbol)e.sym;
		    MethodSymbol implMeth = absMeth.implementation(cd.sym);
		    if (implMeth == null)
			addAbstractMethod(cd, absMeth, env);
		}
	    }
	    implementInterfaceMethods(i, env);
	}
    }

/* ************************************************************************
 * visitor methods
 *************************************************************************/

    public Type _case(ClassDef tree, Env&lt;AttrContext&gt; env) {
	if ((env.info.scope.owner.kind &amp; (VAR | MTH)) != 0) {
	    enter.classEnter(tree, env);
	} else if (tree.name.len == 0) {
	    System.out.println(env.info.scope.owner);
	}
	ClassSymbol c = tree.sym;
	if (c == null) return null;
	c.complete();
	attribClass(c);
	return tree.type = c.type;
    }

    public Type _case(MethodDef tree, Env&lt;AttrContext&gt; env) {
	MethodSymbol m = tree.sym;
	chk.checkOverride(tree.pos, m);

	Env&lt;AttrContext&gt; localEnv = enter.methodEnv((MethodDef)tree, env);
	for (List&lt;TypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
	    localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
	for (List&lt;VarDef&gt; l = tree.params; l.nonEmpty(); l = l.tail)
	    attribStat(l.head, localEnv);

	chk.validateTypeParams(tree.typarams);
	chk.validate(tree.restype);
	for (List&lt;Tree&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
	    chk.checkType(l.head.pos, l.head.type, syms.throwableType);
	
	ClassSymbol owner = env.enclClass.sym;
	if (tree.body == null) {
	    if ((owner.flags() &amp; INTERFACE) == 0 &amp;&amp;
		(tree.flags &amp; (ABSTRACT | NATIVE)) == 0)
		log.error(tree.pos,
			  "missing method body, or declare as abstract");
	} else if ((owner.flags() &amp; INTERFACE) != 0) {
	    log.error(tree.pos, "interface methods cannot have body");
	} else if ((tree.flags &amp; ABSTRACT) != 0) {
	    log.error(tree.pos, "abstract methods cannot have body");
	} else if ((tree.flags &amp; NATIVE) != 0) {
	    log.error(tree.pos, "native methods cannot have body");
	} else {
	    if (tree.name == Names.init &amp;&amp; owner.type != syms.objectType) {
		Block body = tree.body;
		if (body.stats.isEmpty() || !isSelfCall(body.stats.head)) {
		    body.stats = body.stats.prepend(
			Enter.SuperCall(
			    make.at(body.pos), VarDef.emptyList, false));
		}
	    }
	    attribStat(tree.body, localEnv);
	}
	localEnv.info.scope.leave();
	return tree.type = m.type;
    }
//where
        private boolean isSelfCall(Tree tree) {
	    if (tree.tag == Tree.EXEC) {
		Exec exec = (Exec)tree;
		if (exec.expr.tag == Tree.APPLY) {
		    Name mname = TreeInfo.name(((Apply)exec.expr).meth);
		    if (mname == Names._this || mname == Names._super) return 
true;
		}
	    }
	    return false;
	}

    public Type _case(VarDef tree, Env&lt;AttrContext&gt; env) {
	if (env.info.scope.owner.kind == MTH) enter.memberEnter(tree, env);
	chk.validate(tree.vartype);
	VarSymbol v = tree.sym;
	Base.assert(v != null, tree.name);
	if (tree.init != null) {
	    v.pos = Position.MAXPOS; //to catch self references
	    Type itype = attribExpr(
		tree.init, enter.initEnv((VarDef)tree, env), v.type);
	    if (v.constValue instanceof Enter.EnvAttrContextBox) {
		if (itype.constValue != null)
		    v.constValue = cfolder.coerce(itype, v.type).constValue;
		else
		    v.constValue = null;
	    }
	    v.pos = tree.pos;
	}
	return tree.type = v.type;
    }

    public Type _case(Block tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; localEnv =
	    env.dup(tree, env.info.dup(env.info.scope.dup()));
	if (env.info.scope.owner.kind == TYP) {
	    localEnv.info.scope.owner = new MethodSymbol(
		tree.flags | BLOCK, Names.empty, null, env.info.scope.owner);
	    if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
	}
	attribStats(tree.stats, localEnv);
	localEnv.info.scope.leave();
	return null;
    }

    public Type _case(DoLoop tree, Env&lt;AttrContext&gt; env) {
	attribStat(tree.body, env.dup(tree));
	attribExpr(tree.cond, env, Type.booleanType);
	return null;
    }

    public Type _case(WhileLoop tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.cond, env, Type.booleanType);
	attribStat(tree.body, env.dup(tree));
	return null;
    }

    public Type _case(ForLoop tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; loopEnv =
	    env.dup(env.tree, env.info.dup(env.info.scope.dup()));
	attribStats(tree.init, loopEnv);
	if (tree.cond != null) attribExpr(tree.cond, loopEnv, Type.booleanType);
	loopEnv.tree = tree; // before, we were not in loop!
	attribStats(tree.step, loopEnv);
	attribStat(tree.body, loopEnv);
	loopEnv.info.scope.leave();
	return null;
    }

    public Type _case(Labelled tree, Env&lt;AttrContext&gt; env) {
	attribStat(tree.body, env.dup(tree));
	return null;
    }

    public Type _case(Switch tree, Env&lt;AttrContext&gt; env) {
	Type seltype = attribExpr(tree.selector, env, Type.intType);
	Env&lt;AttrContext&gt; switchEnv =
	    env.dup(tree, env.info.dup(env.info.scope.dup()));

	Set&lt;Object&gt; tags = Set.make();
	boolean hasDefault = false;
	for (List&lt;Case&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
	    Case c = l.head;
	    if (c.pat != null) {
		Type pattype = attribExpr(c.pat, switchEnv, Type.intType);
		if (pattype.tag != ERROR) {
		    if (pattype.constValue == null)
			log.error(c.pat.pos, "constant expression required");
		    else if (tags.contains(pattype.constValue))
			log.error(c.pos, "duplicate case label");
		    else
			tags.put(pattype.constValue);
		}
	    } else if (hasDefault) {
		log.error(c.pos, "duplicate default label");
	    } else {
		hasDefault = true;
	    }
	    attribStats(c.stats, switchEnv);
	}
	switchEnv.info.scope.leave();
	return null;
    }

    public Type _case(Synchronized tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.lock, env, syms.objectType);
	attribStat(tree.body, env);
	return null;
    }

    public Type _case(Try tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; tryEnv = env.dup(tree, env.info.dup());
	for (List&lt;Catch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
	    Catch c = l.head;
	    Env&lt;AttrContext&gt; catchEnv =
		env.dup(c, env.info.dup(env.info.scope.dup()));
	    Type ctype = attribStat(c.param, catchEnv);
	    chk.checkType(c.param.vartype.pos, ctype, syms.throwableType);
	    attribStat(c.body, catchEnv);
	    ClassSymbol exc = (ClassSymbol)ctype.tsym;
	    catchEnv.info.scope.leave();
	}
	attribStat(tree.body, tryEnv);
	if (tree.finalizer != null) attribStat(tree.finalizer, env);
	return null;
    }

    public Type _case(Conditional tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	attribExpr(tree.cond, env, Type.booleanType);
	attribExpr(tree.thenpart, env, pt);
	if (tree.elsepart != null) attribExpr(tree.elsepart, env, pt);
	if (tree.tag == Tree.CONDSTAT)
	    return null;
	else
	    return check(
		tree,
		condType(
		    tree.pos,
		    tree.cond.type, tree.thenpart.type, tree.elsepart.type),
		VAL, pkind, pt);
    }
//where
        private Type condType(int pos, Type condtype, Type thentype, Type 
elsetype) {
	    if (condtype.constValue != null &amp;&amp;
		thentype.constValue != null &amp;&amp;
		elsetype.constValue != null)
		return (((Number)condtype.constValue).intValue() != 0)
		    ? thentype
		    : elsetype;
	    else if (thentype.tag &lt; INT &amp;&amp; elsetype.tag == INT &amp;&amp;
		elsetype.assignable(thentype))
		return thentype;
	    else if (elsetype.tag &lt; INT &amp;&amp; thentype.tag == INT &amp;&amp;
		     thentype.assignable(elsetype))
		return elsetype;
	    else if (thentype.tag &lt;= DOUBLE &amp;&amp; elsetype.tag &lt;= DOUBLE) {
		for (int i = BYTE; i &lt;= DOUBLE; i++) {
		    Type candidate = Type.typeOfTag[i];
		    if (thentype.subType(candidate) &amp;&amp;
			elsetype.subType(candidate)) return candidate;
		}
	    }
	    if (thentype.tsym == syms.stringType.tsym &amp;&amp;
		elsetype.tsym == syms.stringType.tsym) {
		return syms.stringType;
	    } else if (thentype.subType(elsetype)) {
		return elsetype;
	    } else {
		chk.checkType(pos, elsetype, thentype);
		return thentype;
	    }
	}

    public Type _case(Exec tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.expr, env);
	return null;
    }

    public Type _case(Break tree, Env&lt;AttrContext&gt; env) {
	tree.target = findJumpTarget(tree.pos, tree.tag, tree.label, env);
	return null;
    }

    public Type _case(Continue tree, Env&lt;AttrContext&gt; env) {
	tree.target = findJumpTarget(tree.pos, tree.tag, tree.label, env);
	return null;
    }
//where
        private Tree findJumpTarget(int pos,
				    int tag,
				    Name label,
				    Env&lt;AttrContext&gt; env) {
	    Env&lt;AttrContext&gt; env1 = env;
	    while (env1 != null) {
		switch (env1.tree.tag) {
		case Tree.LABELLED:
		    Labelled labelled = (Labelled)env1.tree;
		    if (label == labelled.label) {
			Tree target = labelled.body;
			while (target.tag == Tree.LABELLED) {
			    target = ((Labelled)target).body;
			}
			if (tag == Tree.CONTINUE &amp;&amp;
			    target.tag != Tree.DOLOOP &amp;&amp;
			    target.tag != Tree.WHILELOOP &amp;&amp;
			    target.tag != Tree.FORLOOP)
			    log.error(pos, "not a loop label: " + label);
			return target;
		    }
		    break;
		case Tree.DOLOOP:
		case Tree.WHILELOOP:
		case Tree.FORLOOP:
		    if (label == null) return env1.tree;
		    break;
		case Tree.SWITCH:
		    if (label == null &amp;&amp; tag == Tree.BREAK) return env1.tree;
		    break;
		default:
		}
		env1 = env1.next;
	    }
	    if (label != null)
		log.error(pos, "undefined label: " + label);
	    else if (tag == Tree.CONTINUE)
		log.error(pos, "continue outside of loop");
	    else
		log.error(pos, "break outside switch or loop");
	    return null;
	}

    public Type _case(Return tree, Env&lt;AttrContext&gt; env) {
	if (env.enclMethod == null ||
	    env.enclClass.sym.owner == env.enclMethod.sym) {
	    log.error(tree.pos, "return outside method");
	} else {
	    Symbol m = env.enclMethod.sym;
	    if (m.type.restype().tag == VOID) {
		if (tree.expr != null)
		    log.error(
			tree.expr.pos, "can't return a value from method " +
			"whose result type is void");
	    } else if (tree.expr == null) {
		log.error(tree.pos, "missing return value");
	    } else {
		attribExpr(tree.expr, env, m.type.restype());
	    }
	}
	return null;
    }

    public Type _case(Throw tree, Env&lt;AttrContext&gt; env) {
	Type t = attribExpr(tree.expr, env, syms.throwableType);
	return null;
    }

    public Type _case(Apply tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Env&lt;AttrContext&gt; localEnv = env;
	List&lt;Type&gt; argtypes;
	Name methName = TreeInfo.name(tree.meth);
	boolean isConstructorCall =
	    methName == Names._this || methName == Names._super;
	if (isConstructorCall &amp;&amp; checkFirstConstructorStat(tree, env)) {
	    localEnv = env.dup(env.tree, env.info.dup());
	    localEnv.info.isSelfCall = true;
	    argtypes = attribArgs(tree.args, localEnv);
	    Type site = env.enclClass.sym.type;
	    if (methName == Names._super) site = site.supertype();
	    Type encltype = (tree.meth.tag == Tree.SELECT)
		? attribExpr(((Select)tree.meth).selected, env)
		: null;
	    argtypes = constructorArgs(
		tree.meth.pos, localEnv, site, encltype, argtypes);
	} else {
	    argtypes = attribArgs(tree.args, localEnv);
	}

	List&lt;MethodType&gt; saved = methTemplateSupply.elems;
	Type mpt = newMethTemplate(argtypes);
	// optimization, was ... = new MethodType(argtypes, null, null);

	owntype = attribExpr(tree.meth, localEnv, mpt);

	methTemplateSupply.elems = saved; // optimization

	if (isConstructorCall) {
	    Symbol called = TreeInfo.symbol(tree.meth);
	    if (called == env.enclMethod.sym)
		log.error(tree.pos, "recursive constructor invocation");
//todo: handle indirect recursion as well
	}
	return check(tree, owntype, VAL, pkind, pt);
    }
//where
        private boolean checkFirstConstructorStat(Apply tree, Env&lt;AttrContext&gt; 
env) {
	    MethodDef enclMethod = env.enclMethod;
	    if (enclMethod != null &amp;&amp; enclMethod.name == Names.init) {
		Block body = (Block)enclMethod.body;
		if (body.stats.head.tag == Tree.EXEC &amp;&amp;
		    ((Exec)body.stats.head).expr == tree)
		    return true;
	    }
	    log.error(tree.pos, "call to " + TreeInfo.name(tree.meth) +
		      " must be first statement in constructor");
	    return false;
	}

        /** optimization: To save allocating a new methodtype for every apply,
	 *  we use a reservoir.
	 */
        ListBuffer&lt;MethodType&gt; methTemplateSupply = new ListBuffer&lt;MethodType&gt;
();

        public Type newMethTemplate(List&lt;Type&gt; argtypes) {
	    if (methTemplateSupply.elems == methTemplateSupply.last)
		methTemplateSupply.append(new MethodType(null, null, null));
	    MethodType mt = methTemplateSupply.elems.head;
	    methTemplateSupply.elems = methTemplateSupply.elems.tail;
	    mt.argtypes = argtypes;
	    return mt;
	}

    public Type _case(NewClass tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	ClassDef cdef = tree.def;

	// if enclosing class is given, attribute it, and
	// complete class name to be fully qualified
	Type encltype = null;
	Tree clazz = tree.clazz;
	if (tree.encl != null) {
	    encltype = attribExpr(tree.encl, env);
	    if (encltype.tag == CLASS) {
		clazz = make.at(clazz.pos).Select(
		    make.Type(encltype), ((Ident)tree.clazz).name);
//		new Pretty().printExpr(clazz);//DEBUG
	    }
	}

	// attribute clazz and store symbol + type back into tree
	Type clazztype = chk.checkClassType(
	    tree.clazz.pos, attribType(clazz, env));
	chk.validate(clazz);	
	if (tree.encl != null) {
	    tree.clazz.type = clazztype;
	    ((Ident)tree.clazz).sym = TreeInfo.symbol(clazz);
	}

	// attribute arguments;
	List&lt;Type&gt; rawArgtypes = attribArgs(tree.args, env);
	List&lt;Type&gt; argtypes = rawArgtypes;

	if (clazztype.tag == CLASS) {
	    Type site = clazztype.tsym.type;
	    List&lt;Type&gt; typarams = clazztype.typarams();

	    // resolve constructor, if not abstract
	    if (cdef == null &amp;&amp;
		(clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
		log.error(tree.pos,
		    clazztype.tsym + " is abstract; cannot be instantiated");
	    } else if (cdef != null &amp;&amp;
		       (clazztype.tsym.flags() &amp; INTERFACE) != 0) {
		if (rawArgtypes.nonEmpty()) {
		    log.error(tree.pos,
			      "anonymous class implements interface; " +
			      "cannot have arguments");
		    rawArgtypes = argtypes = Type.emptyList;
		} else if (tree.encl != null) {
		    log.error(tree.pos,
			      "anonymous class implements interface; " +
			      "cannot have qualifier for new");
		}
	    } else {
		argtypes = constructorArgs(
		    tree.pos, env, site, encltype, rawArgtypes);
		boolean selectSuperPrev = env.info.selectSuper;
		if (cdef != null) env.info.selectSuper = true;
		tree.constructor = rs.resolveConstructor(
		    tree.pos, env, site, typarams, argtypes);
		env.info.selectSuper = selectSuperPrev;
	    }

	    // if it's an anonymous class...
	    if (cdef != null) {

		// complete class definition with extends/implements clause
	        // and enter + attribute it.
		if (Resolve.isStatic(env)) cdef.flags |= STATIC;

		Tree clazz1 = make.at(cdef.pos).Type(clazztype);
		if ((clazztype.tsym.flags() &amp; INTERFACE) != 0) {
		    cdef.implementing = List.make(clazz1);
		} else {
		    cdef.extending = clazz1;
		}
		attribStat(cdef, env.dup(tree));
//	        new Pretty().printStat(cdef);//DEBUG

		// if enclosing class is given,
		// add it to constructor arguments
		if (tree.encl != null) {
		    tree.args = tree.args.prepend(tree.encl);
		    rawArgtypes = rawArgtypes.prepend(encltype);
		    tree.encl = null;
		    encltype = null;
		}

		// reassign site, typarams and recompute constructor
		site = cdef.sym.type;
		typarams = Type.emptyList;
		argtypes = constructorArgs(
		    tree.pos, env, site, encltype, rawArgtypes);
		tree.constructor = rs.resolveConstructor(
		    tree.pos, env, site, typarams, argtypes);
	    }
	    if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) {
		owntype = rs.instantiate(
		    site, tree.constructor, typarams, argtypes);
		if (owntype == null) {//debug
		    log.error(
			tree.pos, "internal error; cannot instantiate " +
			tree.constructor + " to (" + argtypes + ")");
		}
	    }
	}
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(NewArray tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Type elemtype;
	if (tree.elemtype != null) {
	    elemtype = attribType(tree.elemtype, env);
	    if (elemtype.tag == TYPEVAR) {
		log.warning(tree.pos, "unchecked generic array creation");
	    }
	    chk.validate(tree.elemtype);
	    owntype = elemtype;
	    for (List&lt;Tree&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
		attribExpr(l.head, env, Type.intType);
		owntype = new ArrayType(owntype);
	    }
	} else {
	    if (pt.tag == ARRAY) {
		elemtype = pt.elemtype();
	    } else {
		if (pt.tag != ERROR) {
		    log.error(tree.pos, "illegal initializer for " + pt);
		}
		elemtype = Type.errType;
	    }
	}
	if (tree.elems != null) {
	    attribExprs(tree.elems, env, elemtype);
	    owntype = new ArrayType(elemtype);
	}
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(Assign tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = attribTerm(tree.lhs, env.dup(tree), VAR, pt);
	attribExpr(tree.rhs, env, owntype);
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(Assignop tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	List&lt;Type&gt; argtypes = List.make(
	    attribTerm(tree.lhs, env, VAR, Type.noType),
	    attribExpr(tree.rhs, env));
	Symbol operator = tree.operator = rs.resolveOperator(
	    tree.pos, tree.tag - Tree.ASGOffset, env, argtypes);
	Type owntype = argtypes.head;
	if (operator.kind == MTH) {
	    if (owntype.tag &lt;= DOUBLE)
		chk.checkCastable(
		    tree.rhs.pos, operator.type.restype(), owntype);
	    else
		chk.checkType(
		    tree.rhs.pos, operator.type.restype(), owntype);
	}
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(Operation tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	List&lt;Type&gt; argtypes;
	if (Tree.PREINC &lt;= tree.tag &amp;&amp; tree.tag &lt;= Tree.POSTDEC)
	    argtypes = Type.emptyList.prepend(
		attribTerm(tree.args.head, env, VAR, Type.noType));
	else
	    argtypes = attribArgs(tree.args, env);
	Symbol operator = tree.operator = rs.resolveOperator(
	    tree.pos, tree.tag, env, argtypes);
	Type owntype = Type.errType;
	if (operator.kind == MTH) {
	    owntype = operator.type.restype();
	    int opc = ((OperatorSymbol)operator).opcode;
	    List&lt;Type&gt; l = argtypes;
	    while (l.nonEmpty() &amp;&amp; l.head.constValue != null) l = l.tail;
	    if (l.isEmpty()) {
		Type ctype = cfolder.fold(tree.pos, opc, argtypes);
		if (ctype != null) owntype = cfolder.coerce(ctype, owntype);
	    }
	    if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne) &amp;&amp;
		!argtypes.head.castableTo(argtypes.tail.head.erasure()) &amp;&amp;
		!argtypes.tail.head.castableTo(argtypes.head.erasure())) {
		log.error(
		    tree.pos, "incomparable types: " +
		    argtypes.head + " and " + argtypes.tail.head);
	    }
	}
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(TypeCast tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type clazztype = attribType(tree.clazz, env);
	Type exprtype = attribExpr(tree.expr, env);
	Type owntype = chk.checkCastable(tree.expr.pos, exprtype, clazztype);
	if (exprtype.constValue != null)
	    owntype = cfolder.coerce(exprtype, owntype);
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(TypeTest tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type exprtype = attribExpr(tree.expr, env);

        // The following check is correct for GJ but not for NextGen  Corky 
6/28/00
	/* Type clazztype = chk.checkClassOrArrayType(
	   tree.clazz.pos, attribType(tree.clazz, env)); */
        // In the following invocation, attribType(tree.clazz,env) replaces 
clazztype, which is consistent with successful return from checkClassOrArrayType
	chk.checkCastable(tree.expr.pos, exprtype, attribType
(tree.clazz,env));  
	return check(tree, Type.booleanType, VAL, pkind, pt);
    }

    public Type _case(Indexed tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Type atype = attribExpr(tree.indexed, env);
	attribExpr(tree.index, env, Type.intType);
	if (atype.tag == ARRAY)
	    owntype = atype.elemtype();
	else if (atype.tag != ERROR)
	    log.error(tree.pos, "array required, but " + atype + " found");
	return check(tree, owntype, VAR, pkind, pt);
    }

    public Type _case(Ident tree, Env&lt;AttrContext&gt; env) {
	int pkind = env.info.pkind;
	Type pt = env.info.pt;
	Symbol sym;
	
	// find symbol
	if (pt.tag == METHOD) {
	    if (tree.name == Names._super || tree.name == Names._this) {
		sym = rs.resolveSelfConstructor(
		    tree.pos, env, tree.name, pt.argtypes());
	    } else {
		sym = rs.resolveMethod(
		    tree.pos, env, tree.name, Type.emptyList, pt.argtypes());
	    }
	} else {
	    sym = rs.resolveIdent(tree.pos, env, tree.name, pkind);
	}
	tree.sym = sym;

	//check that symbol does not hide identifier in outer class
	if (env.enclClass.sym.owner.kind != PCK &amp;&amp;
	    (sym.kind &amp; (VAR | MTH)) != 0 &amp;&amp; 	
	    sym.owner.kind == TYP &amp;&amp;
	    tree.name != Names._super &amp;&amp; tree.name != Names._this) {
	    Env&lt;AttrContext&gt; env1 = env;
	    while (env1.outer != null &amp;&amp; !env1.enclClass.sym.subclass
(sym.owner))
		env1 = env1.outer;
	    if (env1 != null &amp;&amp; env1.enclClass.sym != sym.owner) {
		do {
		    env1 = env1.outer;
		} while (env1 != null &amp;&amp;
		       (env1.info.scope == null ||
			checkNotHiding(tree.pos, sym, env1.info.scope)) &amp;&amp;
		       (env1.enclClass == null ||
			checkNotHiding(tree.pos, sym, env1.enclClass.sym.members
())));
	    }
	}
		
	// if symbol is a variable, evaluate its initializer, if it has one
	// if it is a local variable accessed from an embedded inner class,
	// mark it as captured, and check that it is final.
	if (sym.kind == VAR) {
	    VarSymbol v = (VarSymbol)sym;
	    checkInit(tree, env, v);
	    if (v.owner.kind == MTH &amp;&amp;
		v.owner != env.info.scope.owner &amp;&amp;
		(v.flags_field &amp; CAPTURED) == 0) {
		v.flags_field |= CAPTURED;
		if ((v.flags_field &amp; FINAL) == 0) {
		    log.error(
			tree.pos, "local " + v +
			" is accessed from within inner class; " +
			" needs to be declared final");
		}
	    }
	    if (pkind == VAR)
		checkAssignable(tree.pos, v, null, env);
	}

	// in constructor body:
        // if symbol is a field or instance method, check that it is not 
accessed
        // before supertype constructor is called.
	if (env.info.isSelfCall &amp;&amp;
	    sym.owner != null &amp;&amp; sym.owner.kind == TYP &amp;&amp;
	    (sym.flags() &amp; STATIC) == 0 &amp;&amp;
	    env.enclClass.sym.subclass(sym.owner) &amp;&amp;
	    sym.name != Names.init)
	    chk.earlyRefError(tree.pos, sym.kind == VAR ? sym : thisSym(env));

	return checkId(tree, env.enclClass.sym.type, sym, pkind, pt);
    }

    public Type _case(Select tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	int skind = 0;
	if (tree.name == Names._this || tree.name == Names._class) {
	    skind = TYP;
	} else {
	    if ((pkind &amp; PCK) != 0) skind = skind | PCK;
	    if ((pkind &amp; TYP) != 0) skind = skind | TYP | PCK;
	    if ((pkind &amp; (VAL | MTH)) != 0) skind = skind | VAL | TYP;
	}
	Type site = attribTerm(tree.selected, env, skind, Type.noType);
	Symbol sitesym = TreeInfo.symbol(tree.selected);
	
	boolean selectSuperPrev = env.info.selectSuper;
	env.info.selectSuper =
	    sitesym != null &amp;&amp;
	    (sitesym.name == Names._super || sitesym.kind == TYP);

	Symbol sym = selectSym(tree, site, env, pt, pkind);
	tree.sym = sym;

	if (sym.kind == VAR) {
	    VarSymbol v = (VarSymbol)sym;
	    evalInit(v, env);
	    if (pkind == VAR)
		checkAssignable(tree.pos, v, tree.selected, env);
	}

	if (env.info.selectSuper) {
	    if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
		sym.name != Names._this &amp;&amp; sym.name != Names._super) {
		if (sitesym.name == Names._super) {
		    rs.checkNonAbstract(tree.pos, sym);
		} else if (sym.kind == VAR || sym.kind == MTH) {
		    rs.access(new Resolve.StaticError(sym),
			      tree.pos, site, sym.name);
		}
		if (env.info.isSelfCall &amp;&amp;
		    sym.name != Names.init &amp;&amp;
		    tree.name == Names._this &amp;&amp;
		    site.tsym == env.enclClass.sym) {
		    chk.earlyRefError(tree.pos, sym);
		}
		Type site1 = env.enclClass.sym.type.asSuper(site.tsym);
		if (site1 != null) site = site1;
	    }
	    env.info.selectSuper = selectSuperPrev;
	}
	return checkId(tree, site, sym, pkind, pt);
    }
//where
        /** determine symbol referenced by a Select expression,
	 *  @param pos    position for error reporting
	 *  @param site   the type of the selected expression
	 *  @param name   the selector name
	 *  @param env    the current environment
	 *  @param pt     the current prototype
	 *  @param pkind  the expected kind(s) of the Select expression
	 */
        private Symbol selectSym(Select tree, Type site,
				 Env&lt;AttrContext&gt; env, Type pt, int pkind) {
	    int pos = tree.pos;
	    Name name = tree.name;
	    switch (site.tag) {
	    case PACKAGE:
		return rs.access(
		    rs.findIdentInPackage(env, site.tsym, name, pkind),
		    pos, site, name);
	    case ARRAY:
	    case CLASS:
		if (pt.tag == METHOD) {
		    if (name == Names._super) {
			return rs.resolveSelfConstructor(
			    pos, env, name, pt.argtypes());
		    } else {
			return rs.resolveQualifiedMethod(
			    pos, env, site, name, Type.emptyList, pt.argtypes
());
		    }
		} else if (name == Names._this) {
		    return rs.resolveSelf(pos, env, site.tsym, name);
		} else if (name == Names._class) {
		    return new VarSymbol(
			STATIC | PUBLIC, Names._class, syms.classType, 
site.tsym);
		} else {
		    Symbol sym = rs.findIdentInType(env, site, name, pkind);
		    if (sym.kind &gt;= rs.AMBIGUOUS) {
			if ((pkind &amp; (TYP | PCK)) != 0) {
			    Name pname = TreeInfo.fullName(tree.selected);
			    if (pname != null) {
				PackageSymbol p = syms.reader.enterPackage
(pname);
				Symbol sym1 = rs.findIdentInPackage(
				    env, p, name, pkind);
				if (sym1.kind &lt; sym.kind) sym = sym1;
			    }
			}
			sym = rs.access(sym, pos, site, name);
		    }
		    return sym;
		}
	    case TYPEVAR:
		return selectSym(tree, site.bound(), env, pt, pkind);
	    case ERROR:
		return Symbol.errSymbol;
	    default:
		if (name == Names._class) {
		    return new VarSymbol(
			STATIC | PUBLIC, Names._class, syms.classType, 
site.tsym);
		} else {	
		    log.error(pos, site + " cannot be dereferenced");
		}
		return Symbol.errSymbol;
	    }
	}

        /** determine type of identifier or select expression and check that
	 *  (1) the referenced symbol is not deprecated
	 *  (2) the symbol type is safe (@see checkSafe)
	 *  (3) if symbol is a variable, check that its type and kind are
	 *      compatible with the prototype and protokind.
	 *  (4) if symbol is a field of a raw type, which is being assigned to,
	 *      issue a warning if its type changes under erasure.
	 *  (5) if symbol is a method of a raw type, issue a warning if
	 *      its argument types change under erasure.
	 *  if checks succeed
	 *    if symbol is a constant return its constant type
	 *    else if symbol is a method return its result type
	 *    otherwise return its type
	 *  else return errType
	 */
        Type checkId(Tree tree, Type site, Symbol sym, int pkind, Type pt) {
	    if ((sym.flags() &amp; DEPRECATED) != 0) warnDeprecated(tree.pos, sym);
	    Type owntype;
	    switch (sym.kind) {
	    case TYP:
		owntype = sym.type;
		if (owntype.tag == CLASS &amp;&amp; owntype.typarams().nonEmpty()) {
		    owntype = new ClassType(
			owntype.outer(), Type.emptyList, owntype.tsym);
		}
		break;
	    case VAR:
		VarSymbol v = (VarSymbol)sym;
		if (!chk.unchecked &amp;&amp;
		    pkind == VAR &amp;&amp;
		    v.owner.kind == TYP &amp;&amp;
		    (v.flags() &amp; STATIC) == 0 &amp;&amp;
		    site.tag == CLASS) {
		    Type s = site.asOuterSuper(v.owner);
		    if (s != null &amp;&amp;
			s.isRaw() &amp;&amp;
			!v.type.sameType(v.erasure())) {
			log.warning(
			    tree.pos,
			    "unchecked assignment to " + v + " of raw type " + 
site);
		    }
		}
		owntype = (sym.owner.kind == TYP)
		    ? site.memberType(sym)
		    : sym.type;
		if (v.constValue != null) owntype = owntype.constType
(v.constValue);
		break;
	    case MTH:
//todo: find out why this can be false
//		Base.assert(site.asOuterSuper(sym.owner) != null,
//			    sym + " " + site + " " + sym.owner);//DEBUG
		if (!chk.unchecked &amp;&amp;
		    (sym.flags() &amp; STATIC) == 0 &amp;&amp;
		    site.tag == CLASS) {
		    Type s= site.asOuterSuper(sym.owner);
		    if (s != null &amp;&amp;
			s.isRaw() &amp;&amp;
			sym.name != Names.init &amp;&amp;
			!Type.sameTypes(
			    sym.type.argtypes(), sym.erasure().argtypes())) {
			log.warning(
			    tree.pos,
			    "unchecked call to " + sym + " of raw type " + 
site);
		    }
		}
		if (sym.name == Names.init) {
		    owntype = Type.voidType;
		} else {
		    owntype = rs.instantiate(
			site, sym, Type.emptyList, pt.argtypes());
		    if (owntype == null) {//debug
			log.error(
			    tree.pos, "internal error; cannot instantiate " +
			    sym + " at " + site + " to (" + pt.argtypes() 
+ ")");
		    }
		}
		break;
	    case PCK: case ERR:
		owntype = sym.type;
		break;
	    default:
		new Pretty().printExpr(tree);//debug
		throw new InternalError("unexpected kind: " + sym.kind);
	    }
	    infer.checkSafe(tree.pos, owntype, sym);
	    return check(tree, owntype, sym.kind, pkind, pt);
	}

        /** check that variable is initialized and evaluate the variable's
	 *  initializer, if not yet done
	 */
	private void checkInit(Tree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
//	    System.err.println(v + " " + ((v.flags() &amp; STATIC) != 0) + " " +
//			       tree.pos + " " + v.pos + " " +
//			       (env.info.staticLevel &gt; 
env.outer.info.staticLevel));//DEBUG
	    if (v.pos &gt; tree.pos &amp;&amp;
		(v.owner.kind == MTH ||
		 (v.owner.kind == TYP &amp;&amp;
		  v.owner == env.info.scope.owner &amp;&amp;
		  ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env))) &amp;&amp;
		(env.tree.tag != Tree.ASSIGN || tree != ((Assign)env.tree).lhs))
		log.error(tree.pos, "illegal forward reference");
	    evalInit(v, env);
	}

	/** evaluate a final variable's initializer
	 *  and set variable's constValue
	 */
	void evalInit(VarSymbol v, Env&lt;AttrContext&gt; env) {
	    if (v.constValue instanceof Enter.EnvAttrContextBox) {
		Env&lt;AttrContext&gt; evalEnv =
		    ((Enter.EnvAttrContextBox)v.constValue).env;
		Name prev = log.useSource(evalEnv.toplevel.sourcefile);
		v.constValue = null;
		Type itype = attribExpr(
		    ((VarDef)evalEnv.tree).init, evalEnv, v.type);
		if (itype.constValue != null)
		    v.constValue = cfolder.coerce(itype, v.type).constValue;
		log.useSource(prev);
	    }
	}

        /** check that `sym' does not hide any symbols of the same name and
	 *  kind in `scope'
	 */
        boolean checkNotHiding(int pos, Symbol sym, Scope scope) {
	    Scope.Entry e = scope.lookup(sym.name);
	    while (e.scope != null) {
		if (e.sym.owner != sym.owner &amp;&amp;
		    e.sym.kind == sym.kind &amp;&amp;
		    e.sym.owner == scope.owner) {
		    log.error(
			pos, sym + " is inherited from " + sym.owner +
			" and hides a " + Resolve.kindName(sym.kind) +
			" of the same name" + e.sym.location() +
			". An explicit `this' qualifier must be used to select 
the desired instance  ");
		    return false;
		}
		e = e.next();
	    }
	    return true;
	}

    public Type _case(Literal tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	return check(
	    tree, litType(tree.typetag).constType(tree.value), VAL, pkind, pt);
    }
//where
        Type litType(int tag) {
	    return (tag == CLASS) ? syms.stringType : Type.typeOfTag[tag];
	}

    public Type _case(TypeIdent tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	return check(tree, Type.typeOfTag[tree.typetag], TYP, pkind, pt);
    }

    public Type _case(TypeArray tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type etype = attribType(tree.elemtype, env);
	return check(tree, new ArrayType(etype), TYP, pkind, pt);
    }

    /** attribute type application.
     *  bound checking is left until later, since types are attributed
     *  before supertype structure is completely known
     */
    public Type _case(TypeApply tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;

	Type clazztype = chk.checkClassType(
	    tree.clazz.pos, attribType(tree.clazz, env));

	ListBuffer&lt;Type&gt; actbuf = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = tree.arguments; l.nonEmpty(); l = l.tail)
	    actbuf.append(chk.checkRefType(l.head.pos, attribType(l.head, 
env)));
	List&lt;Type&gt; actuals = actbuf.toList();

	if (clazztype.tag == CLASS) {
	    List&lt;Type&gt; formals = clazztype.tsym.type.typarams();
	    if (actuals.length() == formals.length()) {
		owntype = new ClassType(
		    clazztype.tsym.type.outer(), actuals, clazztype.tsym);
	    } else {
		log.error(
		    tree.pos,
		    (formals.length() != 0)
		        ? "wrong number of type arguments; required: " +
		          formals.length()
		        : "type " + clazztype + " does not take parameters");
		owntype = Type.errType;
	    }
	}
	return check(tree, owntype, TYP, pkind, pt);
    }

    public Type _case(TypeParameter tree, Env&lt;AttrContext&gt; env) {
	TypeVar a = (TypeVar)tree.type;
	if (tree.extBound != null)
	    a.bound = attribBase(tree.extBound, env, 0);
	else if (tree.implBound != null)
	    a.bound = attribBase(tree.implBound, env, INTERFACE);
	else
	    a.bound = syms.objectType;
	return a;
    }

    public Type _case(Erroneous tree, Env&lt;AttrContext&gt; env) {
	return tree.type = Type.errType;
    }

    public Type _case(Tree tree, Env&lt;AttrContext&gt; env) {
	throw new InternalError();
    }

    /** main method: attribute class definition associated given class symbol
     */
    public void attribClass(ClassSymbol c) {
	Type st = c.type.supertype();
	if (st.tag == CLASS) attribClass((ClassSymbol)st.tsym);
	if (c.owner.kind == TYP) attribClass((ClassSymbol)c.owner);
	
	if ((c.flags_field &amp; UNFINISHED) != 0) {
	    Name prev = log.useSource(c.sourcefile);
	    c.flags_field &amp;= ~UNFINISHED;

	    Env&lt;AttrContext&gt; env = enter.classEnvs.get(c);
	    enter.classEnvs.remove(c);

	    ClassDef tree = (ClassDef)env.tree;
	
	    implementInterfaceMethods(c, env);
	    chk.validateTypeParams(tree.typarams);
	    chk.validate(tree.extending);
	    chk.validate(tree.implementing);
	    if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0)
		chk.checkAllDefined(tree.pos, c);
	    chk.checkClassBounds(tree.pos, c);
	
	    if (tree.typarams.length() != 0 &amp;&amp; c.subclass
(syms.throwableType.tsym))
		log.error(tree.pos,
			  "subtypes of java.lang.Throwable cannot have 
arguments");
	    tree.type = c.type;
	
	    for (List&lt;TypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = 
l.tail)
		env.info.scope.enterIfAbsent(l.head.type.tsym);
	
	    if ((c.flags() &amp; INTERFACE) == 0) {
		VarSymbol thisSym = new VarSymbol(FINAL, Names._this, c.type, 
c);
		thisSym.pos = Position.FIRSTPOS;
		env.info.scope.enter(thisSym);
		if (st.tag == CLASS) {
		    VarSymbol superSym = new VarSymbol(FINAL, Names._super, st, 
c);
		    superSym.pos = Position.FIRSTPOS;
		    env.info.scope.enter(superSym);
		}
		chk.checkImplementations(tree.pos, c);
	    } else {
		c.members_field = c.members_field.dup();
		implementInterfaceMethods(c, env);
		chk.checkImplementations(tree.pos, c);
		c.members_field = c.members_field.leave();
	    }
	
	    attribStats(tree.defs, env);
//	    checkConstructorsNonCyclic(tree.defs, env);
	    tree.type = c.type;

	    log.useSource(prev);
	}
    }
}
The selection parser seems to be in a infinite loop in the recovery mode. If it is not infinite, it is 
too long anyway.
Simpler test case:
[public class X {
    Object foo(Stack&lt;X&gt; s) {
    }
    List&lt;T&gt; bar(int pos, T x1, T x2, List&lt;T&gt; l) {
    }
}
]
Offending method is #bar, due to the combination of invalid return type and 
invalid last argument type. The recovery loops because it is branching back at 
the last closing parenthesis (not considering the one from #bar end of 
signature.

The forced argument reduction in case of recovery 
(RecoveredMethod#updateFromParserState) did not fix up the parser RParenPos, 
used then to update the next checkpoint. In this case, there is no right 
parenthesis consumed at this point yet.

Fixed.</WithStack>
    <WithOutStack>Build 20020321 stable
Importing the file below causes an Out of Memory error in eclipse.  Here is the 
log file:
Log: Wed Mar 27 14:38:33 CST 2002
1 org.eclipse.core.resources 4 Unhandled exception caught in event loop.
Log: Wed Mar 27 14:38:33 CST 2002
4 org.eclipse.ui 0 java.lang.OutOfMemoryError
java.lang.OutOfMemoryError
	&lt;&lt;no stack trace available&gt;&gt;

Problem seems to be associated with parsing the file.  If I turn auto build 
off, the error doesn't appear until I expand the package in the packages view.  
If I turn off Show Members in Packages View it doesn't appear until I open the 
file in the Java editor.  The file is part of the Dr Java package from Rice 
university (http://drjava.sourceforge.net/).  It appears to be compiled with a 
generics compliant compiler as the extends clause contains the following: 
extends Tree.Visitor&lt;Type,Env&lt;AttrContext&gt;&gt;.

As this is not valid Java, I wouldn't expect this to compile.  However, the out 
of memory error could possibly be avoided.  I am able to recreate the problem 
by having autobuild turned on and importing the file into an existing project.



/* ************************************************************************
 * GJC attribution phase
 * by Martin Odersky
 *
 * Copyright (C) 1996-98 Martin Odersky. All rights reserved.
 * Permission is hereby granted to use and modify this software for evaluation
 * and research purposes. Modification and use for other purposes requires
 * prior written permission by the author. The software, or modifications
 * thereof may be given to third parties only with prior written permission
 * by the author.
 *************************************************************************/

package edu.rice.cs.nextgen.compiler.comp;

import edu.rice.cs.nextgen.compiler.util.*;
import edu.rice.cs.nextgen.compiler.code.*;
import edu.rice.cs.nextgen.compiler.tree.*;

import Symbol.*;
import Tree.*;
import Type.*;

public class Attr
extends Tree.Visitor&lt;Type,Env&lt;AttrContext&gt;&gt;
implements /* imports */ Flags, Kinds, TypeTags {

    Log log;
    Symtab syms;
    Resolve rs;
    Check chk;
    Infer infer;
    TreeMaker make;
    public Enter enter;
    public ConstFold cfolder;

    public Attr(Log log, Symtab syms,
		Resolve rs, Check chk, Infer infer,
		TreeMaker make, Enter enter) {
	this.log = log;
	this.syms = syms;
	this.rs = rs;
	this.chk = chk;
	this.infer = infer;
	this.make = make;
	this.enter = enter;
	if (enter != null) enter.attr = this;
	this.cfolder = new ConstFold(log, syms);
    }

    /** check kind and type of given tree against prototype
     *  store resulting type to tree and return it.
     *  no checks are performed if the prototype is a method type.
     *  Its not necessary in this case since we know that kind and type
     *  are correct.
     */
    Type check(Tree tree, Type owntype, int ownkind, int pkind, Type pt) {
	if (owntype.tag != ERROR &amp;&amp; pt.tag != METHOD) {
	    if ((ownkind &amp; ~pkind) == 0) {
		if (pt.tag != NONE)
		    owntype = chk.checkType(tree.pos, owntype, pt);
	    } else {
		log.error(tree.pos,
			  Resolve.kindNames(pkind) + " required, but " +
			  Resolve.kindName(ownkind) + " found");
		owntype = Type.errType;
	    }
	}
	tree.type = owntype;
	return owntype;
    }

    /** is variable `v' assignable, i.e. in a scope where it may be assigned to
     *  even if it is final?
     */
    static boolean finalAssignable(VarSymbol v, Env&lt;AttrContext&gt; env) {
	Symbol owner = env.info.scope.owner;
	return
	    v.constValue == null
	    &amp;&amp;
	    (v.owner == owner
	     ||
	     ((owner.name == Names.init || (owner.flags() &amp; BLOCK) != 0)
	      &amp;&amp;
	      v.owner == owner.owner
	      &amp;&amp;
	      ((v.flags() &amp; STATIC) != 0) == (Resolve.isStatic(env))));
    }

    /** check that variable `v' can be assigned to.
     */
    void checkAssignable(int pos, VarSymbol v, Tree base, Env&lt;AttrContext&gt; env) 
{
	if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
	    !((base == null ||
	       (base.tag == Tree.IDENT &amp;&amp; TreeInfo.name(base) == Names._this)) 
&amp;&amp;
	      finalAssignable(v, env))) {
	    log.error(pos, "can't assign a value to final " + v);
	}
    }

    /** warn about deprecated symbol if not in currently ccompiled files
     */
    void warnDeprecated(int pos, Symbol sym) {
	if (!enter.compiled.contains(sym.enclClass().fullname))
	    log.warning(pos, sym + sym.location() + " has been deprecated");
    }

    /** the current `this' symbol
     */
    Symbol thisSym(Env&lt;AttrContext&gt; env) {
	return rs.resolveSelf(
	    Position.NOPOS, env, env.enclClass.sym, Names._this);
    }

    /** if `site' is an inner class, prepend outer instance to argtypes
     *  outer instance is taken to be `outer' if not null, is made up otherwise.
     */
    List&lt;Type&gt; constructorArgs(int pos, Env&lt;AttrContext&gt; env,
			       Type site, Type outer, List&lt;Type&gt; argtypes) {
	if (site.outer().tag == CLASS) {
	    if (outer == null) {
		Symbol outerthis = rs.resolveSelf(
		    pos, env, site.outer().tsym, Names._this);
		if (outerthis.kind == VAR) {
/*//todo: revise this
		    if (env.info.isSelfCall &amp;&amp;
			outerthis.owner == env.enclClass.sym)
			chk.earlyRefError(pos, outerthis);
 */
		    outer = outerthis.owner.type;
		} else {
		    outer = Type.errType;
		}
	    }
	    argtypes = argtypes.prepend(outer);
	} else if (outer != null &amp;&amp; outer.tag == CLASS &amp;&amp; site.tag != ERROR) {
	    log.error(pos,
		"illegal qualifier; " + site.tsym + " is not an inner class");
	}
	return argtypes;
    }

    Type attribTerm(Tree tree, Env&lt;AttrContext&gt; env, int pkind, Type pt) {
	try {
	    env.info.pkind = pkind;
	    env.info.pt = pt;
	    return tree.visit(this, env);
	} catch (CompletionFailure ex) {
	    return chk.completionError(tree.pos, ex);
	}
    }	

    Type attribExpr(Tree tree, Env&lt;AttrContext&gt; env, Type pt) {
	return attribTerm(tree, env, VAL, pt);
    }

    Type attribExpr(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribExpr(tree, env, Type.noType);
    }

    Type attribType(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribTerm(tree, env, TYP, Type.noType);
    }

    Type attribStat(Tree tree, Env&lt;AttrContext&gt; env) {
	return attribTerm(tree, env, NIL, Type.noType);
    }

    List&lt;Type&gt; attribExprs(List&lt;Tree&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
	ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = trees; l.nonEmpty(); l = l.tail)
	    ts.append(attribExpr(l.head, env, pt));
	return ts.toList();
    }

    &lt;T extends Tree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
	for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
	    attribStat(l.head, env);
    }

    List&lt;Type&gt; attribArgs(List&lt;Tree&gt; trees, Env&lt;AttrContext&gt; env) {
	ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = trees; l.nonEmpty(); l = l.tail)
	    argtypes.append(chk.checkNonVoid(
		l.head.pos, attribExpr(l.head, env)));
	return argtypes.toList();
    }

    /** attribute extended or implemented type reference
     */
    Type attribBase(Tree tree, Env&lt;AttrContext&gt; env, int interfaceFlag) {
	Type t = chk.checkClassType(tree.pos, attribType(tree, env));
	if ((t.tsym.flags() &amp; INTERFACE) != interfaceFlag) {
	    log.error(tree.pos,
		(interfaceFlag == 0 ? "no " : "") + "interface expected here");
	}
	if ((t.tsym.flags() &amp; FINAL) != 0) {
	    log.error(tree.pos, "can't inherit from final " + t.tsym);
	}
	return t;
    }

/* ********************************************************************
 * Adding miranda methods
 *********************************************************************/

    /** add an abstract method definition to class definition `cd'
     *  for a method `m' defined in an interface
     */
    private void addAbstractMethod(ClassDef cd,
				   MethodSymbol m,
				   Env&lt;AttrContext&gt; env) {
//	System.err.println("add abstract method: " + m);//DEBUG
	Tree def = make.at(cd.pos).MethodDef(
	    new MethodSymbol(
		m.flags() | IPROXY, m.name, cd.sym.type.memberType(m), cd.sym),
	    null);
	cd.defs = cd.defs.prepend(def);
	enter.memberEnter(def, env);
    }

    /** add abstract method definitions for all methods defined in one of
     *  c's interfaces, provided they are not already implemented
     *  env = the environment for the class definition of c.
     */
    void implementInterfaceMethods(ClassSymbol c, Env&lt;AttrContext&gt; env) {
	ClassDef cd = (ClassDef)env.tree;
	for (List&lt;Type&gt; l = c.type.interfaces(); l.nonEmpty(); l = l.tail) {
	    ClassSymbol i = (ClassSymbol)l.head.tsym;
	    for (Scope.Entry e = i.members().elems;
		 e != null;
		 e = e.sibling) {
		if (e.sym.kind == MTH &amp;&amp;
		    (e.sym.flags() &amp; STATIC) == 0) // disregard &lt;clinit&gt;!
		{
		    MethodSymbol absMeth = (MethodSymbol)e.sym;
		    MethodSymbol implMeth = absMeth.implementation(cd.sym);
		    if (implMeth == null)
			addAbstractMethod(cd, absMeth, env);
		}
	    }
	    implementInterfaceMethods(i, env);
	}
    }

/* ************************************************************************
 * visitor methods
 *************************************************************************/

    public Type _case(ClassDef tree, Env&lt;AttrContext&gt; env) {
	if ((env.info.scope.owner.kind &amp; (VAR | MTH)) != 0) {
	    enter.classEnter(tree, env);
	} else if (tree.name.len == 0) {
	    System.out.println(env.info.scope.owner);
	}
	ClassSymbol c = tree.sym;
	if (c == null) return null;
	c.complete();
	attribClass(c);
	return tree.type = c.type;
    }

    public Type _case(MethodDef tree, Env&lt;AttrContext&gt; env) {
	MethodSymbol m = tree.sym;
	chk.checkOverride(tree.pos, m);

	Env&lt;AttrContext&gt; localEnv = enter.methodEnv((MethodDef)tree, env);
	for (List&lt;TypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
	    localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
	for (List&lt;VarDef&gt; l = tree.params; l.nonEmpty(); l = l.tail)
	    attribStat(l.head, localEnv);

	chk.validateTypeParams(tree.typarams);
	chk.validate(tree.restype);
	for (List&lt;Tree&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
	    chk.checkType(l.head.pos, l.head.type, syms.throwableType);
	
	ClassSymbol owner = env.enclClass.sym;
	if (tree.body == null) {
	    if ((owner.flags() &amp; INTERFACE) == 0 &amp;&amp;
		(tree.flags &amp; (ABSTRACT | NATIVE)) == 0)
		log.error(tree.pos,
			  "missing method body, or declare as abstract");
	} else if ((owner.flags() &amp; INTERFACE) != 0) {
	    log.error(tree.pos, "interface methods cannot have body");
	} else if ((tree.flags &amp; ABSTRACT) != 0) {
	    log.error(tree.pos, "abstract methods cannot have body");
	} else if ((tree.flags &amp; NATIVE) != 0) {
	    log.error(tree.pos, "native methods cannot have body");
	} else {
	    if (tree.name == Names.init &amp;&amp; owner.type != syms.objectType) {
		Block body = tree.body;
		if (body.stats.isEmpty() || !isSelfCall(body.stats.head)) {
		    body.stats = body.stats.prepend(
			Enter.SuperCall(
			    make.at(body.pos), VarDef.emptyList, false));
		}
	    }
	    attribStat(tree.body, localEnv);
	}
	localEnv.info.scope.leave();
	return tree.type = m.type;
    }
//where
        private boolean isSelfCall(Tree tree) {
	    if (tree.tag == Tree.EXEC) {
		Exec exec = (Exec)tree;
		if (exec.expr.tag == Tree.APPLY) {
		    Name mname = TreeInfo.name(((Apply)exec.expr).meth);
		    if (mname == Names._this || mname == Names._super) return 
true;
		}
	    }
	    return false;
	}

    public Type _case(VarDef tree, Env&lt;AttrContext&gt; env) {
	if (env.info.scope.owner.kind == MTH) enter.memberEnter(tree, env);
	chk.validate(tree.vartype);
	VarSymbol v = tree.sym;
	Base.assert(v != null, tree.name);
	if (tree.init != null) {
	    v.pos = Position.MAXPOS; //to catch self references
	    Type itype = attribExpr(
		tree.init, enter.initEnv((VarDef)tree, env), v.type);
	    if (v.constValue instanceof Enter.EnvAttrContextBox) {
		if (itype.constValue != null)
		    v.constValue = cfolder.coerce(itype, v.type).constValue;
		else
		    v.constValue = null;
	    }
	    v.pos = tree.pos;
	}
	return tree.type = v.type;
    }

    public Type _case(Block tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; localEnv =
	    env.dup(tree, env.info.dup(env.info.scope.dup()));
	if (env.info.scope.owner.kind == TYP) {
	    localEnv.info.scope.owner = new MethodSymbol(
		tree.flags | BLOCK, Names.empty, null, env.info.scope.owner);
	    if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
	}
	attribStats(tree.stats, localEnv);
	localEnv.info.scope.leave();
	return null;
    }

    public Type _case(DoLoop tree, Env&lt;AttrContext&gt; env) {
	attribStat(tree.body, env.dup(tree));
	attribExpr(tree.cond, env, Type.booleanType);
	return null;
    }

    public Type _case(WhileLoop tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.cond, env, Type.booleanType);
	attribStat(tree.body, env.dup(tree));
	return null;
    }

    public Type _case(ForLoop tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; loopEnv =
	    env.dup(env.tree, env.info.dup(env.info.scope.dup()));
	attribStats(tree.init, loopEnv);
	if (tree.cond != null) attribExpr(tree.cond, loopEnv, Type.booleanType);
	loopEnv.tree = tree; // before, we were not in loop!
	attribStats(tree.step, loopEnv);
	attribStat(tree.body, loopEnv);
	loopEnv.info.scope.leave();
	return null;
    }

    public Type _case(Labelled tree, Env&lt;AttrContext&gt; env) {
	attribStat(tree.body, env.dup(tree));
	return null;
    }

    public Type _case(Switch tree, Env&lt;AttrContext&gt; env) {
	Type seltype = attribExpr(tree.selector, env, Type.intType);
	Env&lt;AttrContext&gt; switchEnv =
	    env.dup(tree, env.info.dup(env.info.scope.dup()));

	Set&lt;Object&gt; tags = Set.make();
	boolean hasDefault = false;
	for (List&lt;Case&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
	    Case c = l.head;
	    if (c.pat != null) {
		Type pattype = attribExpr(c.pat, switchEnv, Type.intType);
		if (pattype.tag != ERROR) {
		    if (pattype.constValue == null)
			log.error(c.pat.pos, "constant expression required");
		    else if (tags.contains(pattype.constValue))
			log.error(c.pos, "duplicate case label");
		    else
			tags.put(pattype.constValue);
		}
	    } else if (hasDefault) {
		log.error(c.pos, "duplicate default label");
	    } else {
		hasDefault = true;
	    }
	    attribStats(c.stats, switchEnv);
	}
	switchEnv.info.scope.leave();
	return null;
    }

    public Type _case(Synchronized tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.lock, env, syms.objectType);
	attribStat(tree.body, env);
	return null;
    }

    public Type _case(Try tree, Env&lt;AttrContext&gt; env) {
	Env&lt;AttrContext&gt; tryEnv = env.dup(tree, env.info.dup());
	for (List&lt;Catch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
	    Catch c = l.head;
	    Env&lt;AttrContext&gt; catchEnv =
		env.dup(c, env.info.dup(env.info.scope.dup()));
	    Type ctype = attribStat(c.param, catchEnv);
	    chk.checkType(c.param.vartype.pos, ctype, syms.throwableType);
	    attribStat(c.body, catchEnv);
	    ClassSymbol exc = (ClassSymbol)ctype.tsym;
	    catchEnv.info.scope.leave();
	}
	attribStat(tree.body, tryEnv);
	if (tree.finalizer != null) attribStat(tree.finalizer, env);
	return null;
    }

    public Type _case(Conditional tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	attribExpr(tree.cond, env, Type.booleanType);
	attribExpr(tree.thenpart, env, pt);
	if (tree.elsepart != null) attribExpr(tree.elsepart, env, pt);
	if (tree.tag == Tree.CONDSTAT)
	    return null;
	else
	    return check(
		tree,
		condType(
		    tree.pos,
		    tree.cond.type, tree.thenpart.type, tree.elsepart.type),
		VAL, pkind, pt);
    }
//where
        private Type condType(int pos, Type condtype, Type thentype, Type 
elsetype) {
	    if (condtype.constValue != null &amp;&amp;
		thentype.constValue != null &amp;&amp;
		elsetype.constValue != null)
		return (((Number)condtype.constValue).intValue() != 0)
		    ? thentype
		    : elsetype;
	    else if (thentype.tag &lt; INT &amp;&amp; elsetype.tag == INT &amp;&amp;
		elsetype.assignable(thentype))
		return thentype;
	    else if (elsetype.tag &lt; INT &amp;&amp; thentype.tag == INT &amp;&amp;
		     thentype.assignable(elsetype))
		return elsetype;
	    else if (thentype.tag &lt;= DOUBLE &amp;&amp; elsetype.tag &lt;= DOUBLE) {
		for (int i = BYTE; i &lt;= DOUBLE; i++) {
		    Type candidate = Type.typeOfTag[i];
		    if (thentype.subType(candidate) &amp;&amp;
			elsetype.subType(candidate)) return candidate;
		}
	    }
	    if (thentype.tsym == syms.stringType.tsym &amp;&amp;
		elsetype.tsym == syms.stringType.tsym) {
		return syms.stringType;
	    } else if (thentype.subType(elsetype)) {
		return elsetype;
	    } else {
		chk.checkType(pos, elsetype, thentype);
		return thentype;
	    }
	}

    public Type _case(Exec tree, Env&lt;AttrContext&gt; env) {
	attribExpr(tree.expr, env);
	return null;
    }

    public Type _case(Break tree, Env&lt;AttrContext&gt; env) {
	tree.target = findJumpTarget(tree.pos, tree.tag, tree.label, env);
	return null;
    }

    public Type _case(Continue tree, Env&lt;AttrContext&gt; env) {
	tree.target = findJumpTarget(tree.pos, tree.tag, tree.label, env);
	return null;
    }
//where
        private Tree findJumpTarget(int pos,
				    int tag,
				    Name label,
				    Env&lt;AttrContext&gt; env) {
	    Env&lt;AttrContext&gt; env1 = env;
	    while (env1 != null) {
		switch (env1.tree.tag) {
		case Tree.LABELLED:
		    Labelled labelled = (Labelled)env1.tree;
		    if (label == labelled.label) {
			Tree target = labelled.body;
			while (target.tag == Tree.LABELLED) {
			    target = ((Labelled)target).body;
			}
			if (tag == Tree.CONTINUE &amp;&amp;
			    target.tag != Tree.DOLOOP &amp;&amp;
			    target.tag != Tree.WHILELOOP &amp;&amp;
			    target.tag != Tree.FORLOOP)
			    log.error(pos, "not a loop label: " + label);
			return target;
		    }
		    break;
		case Tree.DOLOOP:
		case Tree.WHILELOOP:
		case Tree.FORLOOP:
		    if (label == null) return env1.tree;
		    break;
		case Tree.SWITCH:
		    if (label == null &amp;&amp; tag == Tree.BREAK) return env1.tree;
		    break;
		default:
		}
		env1 = env1.next;
	    }
	    if (label != null)
		log.error(pos, "undefined label: " + label);
	    else if (tag == Tree.CONTINUE)
		log.error(pos, "continue outside of loop");
	    else
		log.error(pos, "break outside switch or loop");
	    return null;
	}

    public Type _case(Return tree, Env&lt;AttrContext&gt; env) {
	if (env.enclMethod == null ||
	    env.enclClass.sym.owner == env.enclMethod.sym) {
	    log.error(tree.pos, "return outside method");
	} else {
	    Symbol m = env.enclMethod.sym;
	    if (m.type.restype().tag == VOID) {
		if (tree.expr != null)
		    log.error(
			tree.expr.pos, "can't return a value from method " +
			"whose result type is void");
	    } else if (tree.expr == null) {
		log.error(tree.pos, "missing return value");
	    } else {
		attribExpr(tree.expr, env, m.type.restype());
	    }
	}
	return null;
    }

    public Type _case(Throw tree, Env&lt;AttrContext&gt; env) {
	Type t = attribExpr(tree.expr, env, syms.throwableType);
	return null;
    }

    public Type _case(Apply tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Env&lt;AttrContext&gt; localEnv = env;
	List&lt;Type&gt; argtypes;
	Name methName = TreeInfo.name(tree.meth);
	boolean isConstructorCall =
	    methName == Names._this || methName == Names._super;
	if (isConstructorCall &amp;&amp; checkFirstConstructorStat(tree, env)) {
	    localEnv = env.dup(env.tree, env.info.dup());
	    localEnv.info.isSelfCall = true;
	    argtypes = attribArgs(tree.args, localEnv);
	    Type site = env.enclClass.sym.type;
	    if (methName == Names._super) site = site.supertype();
	    Type encltype = (tree.meth.tag == Tree.SELECT)
		? attribExpr(((Select)tree.meth).selected, env)
		: null;
	    argtypes = constructorArgs(
		tree.meth.pos, localEnv, site, encltype, argtypes);
	} else {
	    argtypes = attribArgs(tree.args, localEnv);
	}

	List&lt;MethodType&gt; saved = methTemplateSupply.elems;
	Type mpt = newMethTemplate(argtypes);
	// optimization, was ... = new MethodType(argtypes, null, null);

	owntype = attribExpr(tree.meth, localEnv, mpt);

	methTemplateSupply.elems = saved; // optimization

	if (isConstructorCall) {
	    Symbol called = TreeInfo.symbol(tree.meth);
	    if (called == env.enclMethod.sym)
		log.error(tree.pos, "recursive constructor invocation");
//todo: handle indirect recursion as well
	}
	return check(tree, owntype, VAL, pkind, pt);
    }
//where
        private boolean checkFirstConstructorStat(Apply tree, Env&lt;AttrContext&gt; 
env) {
	    MethodDef enclMethod = env.enclMethod;
	    if (enclMethod != null &amp;&amp; enclMethod.name == Names.init) {
		Block body = (Block)enclMethod.body;
		if (body.stats.head.tag == Tree.EXEC &amp;&amp;
		    ((Exec)body.stats.head).expr == tree)
		    return true;
	    }
	    log.error(tree.pos, "call to " + TreeInfo.name(tree.meth) +
		      " must be first statement in constructor");
	    return false;
	}

        /** optimization: To save allocating a new methodtype for every apply,
	 *  we use a reservoir.
	 */
        ListBuffer&lt;MethodType&gt; methTemplateSupply = new ListBuffer&lt;MethodType&gt;
();

        public Type newMethTemplate(List&lt;Type&gt; argtypes) {
	    if (methTemplateSupply.elems == methTemplateSupply.last)
		methTemplateSupply.append(new MethodType(null, null, null));
	    MethodType mt = methTemplateSupply.elems.head;
	    methTemplateSupply.elems = methTemplateSupply.elems.tail;
	    mt.argtypes = argtypes;
	    return mt;
	}

    public Type _case(NewClass tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	ClassDef cdef = tree.def;

	// if enclosing class is given, attribute it, and
	// complete class name to be fully qualified
	Type encltype = null;
	Tree clazz = tree.clazz;
	if (tree.encl != null) {
	    encltype = attribExpr(tree.encl, env);
	    if (encltype.tag == CLASS) {
		clazz = make.at(clazz.pos).Select(
		    make.Type(encltype), ((Ident)tree.clazz).name);
//		new Pretty().printExpr(clazz);//DEBUG
	    }
	}

	// attribute clazz and store symbol + type back into tree
	Type clazztype = chk.checkClassType(
	    tree.clazz.pos, attribType(clazz, env));
	chk.validate(clazz);	
	if (tree.encl != null) {
	    tree.clazz.type = clazztype;
	    ((Ident)tree.clazz).sym = TreeInfo.symbol(clazz);
	}

	// attribute arguments;
	List&lt;Type&gt; rawArgtypes = attribArgs(tree.args, env);
	List&lt;Type&gt; argtypes = rawArgtypes;

	if (clazztype.tag == CLASS) {
	    Type site = clazztype.tsym.type;
	    List&lt;Type&gt; typarams = clazztype.typarams();

	    // resolve constructor, if not abstract
	    if (cdef == null &amp;&amp;
		(clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
		log.error(tree.pos,
		    clazztype.tsym + " is abstract; cannot be instantiated");
	    } else if (cdef != null &amp;&amp;
		       (clazztype.tsym.flags() &amp; INTERFACE) != 0) {
		if (rawArgtypes.nonEmpty()) {
		    log.error(tree.pos,
			      "anonymous class implements interface; " +
			      "cannot have arguments");
		    rawArgtypes = argtypes = Type.emptyList;
		} else if (tree.encl != null) {
		    log.error(tree.pos,
			      "anonymous class implements interface; " +
			      "cannot have qualifier for new");
		}
	    } else {
		argtypes = constructorArgs(
		    tree.pos, env, site, encltype, rawArgtypes);
		boolean selectSuperPrev = env.info.selectSuper;
		if (cdef != null) env.info.selectSuper = true;
		tree.constructor = rs.resolveConstructor(
		    tree.pos, env, site, typarams, argtypes);
		env.info.selectSuper = selectSuperPrev;
	    }

	    // if it's an anonymous class...
	    if (cdef != null) {

		// complete class definition with extends/implements clause
	        // and enter + attribute it.
		if (Resolve.isStatic(env)) cdef.flags |= STATIC;

		Tree clazz1 = make.at(cdef.pos).Type(clazztype);
		if ((clazztype.tsym.flags() &amp; INTERFACE) != 0) {
		    cdef.implementing = List.make(clazz1);
		} else {
		    cdef.extending = clazz1;
		}
		attribStat(cdef, env.dup(tree));
//	        new Pretty().printStat(cdef);//DEBUG

		// if enclosing class is given,
		// add it to constructor arguments
		if (tree.encl != null) {
		    tree.args = tree.args.prepend(tree.encl);
		    rawArgtypes = rawArgtypes.prepend(encltype);
		    tree.encl = null;
		    encltype = null;
		}

		// reassign site, typarams and recompute constructor
		site = cdef.sym.type;
		typarams = Type.emptyList;
		argtypes = constructorArgs(
		    tree.pos, env, site, encltype, rawArgtypes);
		tree.constructor = rs.resolveConstructor(
		    tree.pos, env, site, typarams, argtypes);
	    }
	    if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) {
		owntype = rs.instantiate(
		    site, tree.constructor, typarams, argtypes);
		if (owntype == null) {//debug
		    log.error(
			tree.pos, "internal error; cannot instantiate " +
			tree.constructor + " to (" + argtypes + ")");
		}
	    }
	}
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(NewArray tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Type elemtype;
	if (tree.elemtype != null) {
	    elemtype = attribType(tree.elemtype, env);
	    if (elemtype.tag == TYPEVAR) {
		log.warning(tree.pos, "unchecked generic array creation");
	    }
	    chk.validate(tree.elemtype);
	    owntype = elemtype;
	    for (List&lt;Tree&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
		attribExpr(l.head, env, Type.intType);
		owntype = new ArrayType(owntype);
	    }
	} else {
	    if (pt.tag == ARRAY) {
		elemtype = pt.elemtype();
	    } else {
		if (pt.tag != ERROR) {
		    log.error(tree.pos, "illegal initializer for " + pt);
		}
		elemtype = Type.errType;
	    }
	}
	if (tree.elems != null) {
	    attribExprs(tree.elems, env, elemtype);
	    owntype = new ArrayType(elemtype);
	}
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(Assign tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = attribTerm(tree.lhs, env.dup(tree), VAR, pt);
	attribExpr(tree.rhs, env, owntype);
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(Assignop tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	List&lt;Type&gt; argtypes = List.make(
	    attribTerm(tree.lhs, env, VAR, Type.noType),
	    attribExpr(tree.rhs, env));
	Symbol operator = tree.operator = rs.resolveOperator(
	    tree.pos, tree.tag - Tree.ASGOffset, env, argtypes);
	Type owntype = argtypes.head;
	if (operator.kind == MTH) {
	    if (owntype.tag &lt;= DOUBLE)
		chk.checkCastable(
		    tree.rhs.pos, operator.type.restype(), owntype);
	    else
		chk.checkType(
		    tree.rhs.pos, operator.type.restype(), owntype);
	}
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(Operation tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	List&lt;Type&gt; argtypes;
	if (Tree.PREINC &lt;= tree.tag &amp;&amp; tree.tag &lt;= Tree.POSTDEC)
	    argtypes = Type.emptyList.prepend(
		attribTerm(tree.args.head, env, VAR, Type.noType));
	else
	    argtypes = attribArgs(tree.args, env);
	Symbol operator = tree.operator = rs.resolveOperator(
	    tree.pos, tree.tag, env, argtypes);
	Type owntype = Type.errType;
	if (operator.kind == MTH) {
	    owntype = operator.type.restype();
	    int opc = ((OperatorSymbol)operator).opcode;
	    List&lt;Type&gt; l = argtypes;
	    while (l.nonEmpty() &amp;&amp; l.head.constValue != null) l = l.tail;
	    if (l.isEmpty()) {
		Type ctype = cfolder.fold(tree.pos, opc, argtypes);
		if (ctype != null) owntype = cfolder.coerce(ctype, owntype);
	    }
	    if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne) &amp;&amp;
		!argtypes.head.castableTo(argtypes.tail.head.erasure()) &amp;&amp;
		!argtypes.tail.head.castableTo(argtypes.head.erasure())) {
		log.error(
		    tree.pos, "incomparable types: " +
		    argtypes.head + " and " + argtypes.tail.head);
	    }
	}
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(TypeCast tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type clazztype = attribType(tree.clazz, env);
	Type exprtype = attribExpr(tree.expr, env);
	Type owntype = chk.checkCastable(tree.expr.pos, exprtype, clazztype);
	if (exprtype.constValue != null)
	    owntype = cfolder.coerce(exprtype, owntype);
	return check(tree, owntype, VAL, pkind, pt);
    }

    public Type _case(TypeTest tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type exprtype = attribExpr(tree.expr, env);

        // The following check is correct for GJ but not for NextGen  Corky 
6/28/00
	/* Type clazztype = chk.checkClassOrArrayType(
	   tree.clazz.pos, attribType(tree.clazz, env)); */
        // In the following invocation, attribType(tree.clazz,env) replaces 
clazztype, which is consistent with successful return from checkClassOrArrayType
	chk.checkCastable(tree.expr.pos, exprtype, attribType
(tree.clazz,env));  
	return check(tree, Type.booleanType, VAL, pkind, pt);
    }

    public Type _case(Indexed tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;
	Type atype = attribExpr(tree.indexed, env);
	attribExpr(tree.index, env, Type.intType);
	if (atype.tag == ARRAY)
	    owntype = atype.elemtype();
	else if (atype.tag != ERROR)
	    log.error(tree.pos, "array required, but " + atype + " found");
	return check(tree, owntype, VAR, pkind, pt);
    }

    public Type _case(Ident tree, Env&lt;AttrContext&gt; env) {
	int pkind = env.info.pkind;
	Type pt = env.info.pt;
	Symbol sym;
	
	// find symbol
	if (pt.tag == METHOD) {
	    if (tree.name == Names._super || tree.name == Names._this) {
		sym = rs.resolveSelfConstructor(
		    tree.pos, env, tree.name, pt.argtypes());
	    } else {
		sym = rs.resolveMethod(
		    tree.pos, env, tree.name, Type.emptyList, pt.argtypes());
	    }
	} else {
	    sym = rs.resolveIdent(tree.pos, env, tree.name, pkind);
	}
	tree.sym = sym;

	//check that symbol does not hide identifier in outer class
	if (env.enclClass.sym.owner.kind != PCK &amp;&amp;
	    (sym.kind &amp; (VAR | MTH)) != 0 &amp;&amp; 	
	    sym.owner.kind == TYP &amp;&amp;
	    tree.name != Names._super &amp;&amp; tree.name != Names._this) {
	    Env&lt;AttrContext&gt; env1 = env;
	    while (env1.outer != null &amp;&amp; !env1.enclClass.sym.subclass
(sym.owner))
		env1 = env1.outer;
	    if (env1 != null &amp;&amp; env1.enclClass.sym != sym.owner) {
		do {
		    env1 = env1.outer;
		} while (env1 != null &amp;&amp;
		       (env1.info.scope == null ||
			checkNotHiding(tree.pos, sym, env1.info.scope)) &amp;&amp;
		       (env1.enclClass == null ||
			checkNotHiding(tree.pos, sym, env1.enclClass.sym.members
())));
	    }
	}
		
	// if symbol is a variable, evaluate its initializer, if it has one
	// if it is a local variable accessed from an embedded inner class,
	// mark it as captured, and check that it is final.
	if (sym.kind == VAR) {
	    VarSymbol v = (VarSymbol)sym;
	    checkInit(tree, env, v);
	    if (v.owner.kind == MTH &amp;&amp;
		v.owner != env.info.scope.owner &amp;&amp;
		(v.flags_field &amp; CAPTURED) == 0) {
		v.flags_field |= CAPTURED;
		if ((v.flags_field &amp; FINAL) == 0) {
		    log.error(
			tree.pos, "local " + v +
			" is accessed from within inner class; " +
			" needs to be declared final");
		}
	    }
	    if (pkind == VAR)
		checkAssignable(tree.pos, v, null, env);
	}

	// in constructor body:
        // if symbol is a field or instance method, check that it is not 
accessed
        // before supertype constructor is called.
	if (env.info.isSelfCall &amp;&amp;
	    sym.owner != null &amp;&amp; sym.owner.kind == TYP &amp;&amp;
	    (sym.flags() &amp; STATIC) == 0 &amp;&amp;
	    env.enclClass.sym.subclass(sym.owner) &amp;&amp;
	    sym.name != Names.init)
	    chk.earlyRefError(tree.pos, sym.kind == VAR ? sym : thisSym(env));

	return checkId(tree, env.enclClass.sym.type, sym, pkind, pt);
    }

    public Type _case(Select tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	int skind = 0;
	if (tree.name == Names._this || tree.name == Names._class) {
	    skind = TYP;
	} else {
	    if ((pkind &amp; PCK) != 0) skind = skind | PCK;
	    if ((pkind &amp; TYP) != 0) skind = skind | TYP | PCK;
	    if ((pkind &amp; (VAL | MTH)) != 0) skind = skind | VAL | TYP;
	}
	Type site = attribTerm(tree.selected, env, skind, Type.noType);
	Symbol sitesym = TreeInfo.symbol(tree.selected);
	
	boolean selectSuperPrev = env.info.selectSuper;
	env.info.selectSuper =
	    sitesym != null &amp;&amp;
	    (sitesym.name == Names._super || sitesym.kind == TYP);

	Symbol sym = selectSym(tree, site, env, pt, pkind);
	tree.sym = sym;

	if (sym.kind == VAR) {
	    VarSymbol v = (VarSymbol)sym;
	    evalInit(v, env);
	    if (pkind == VAR)
		checkAssignable(tree.pos, v, tree.selected, env);
	}

	if (env.info.selectSuper) {
	    if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
		sym.name != Names._this &amp;&amp; sym.name != Names._super) {
		if (sitesym.name == Names._super) {
		    rs.checkNonAbstract(tree.pos, sym);
		} else if (sym.kind == VAR || sym.kind == MTH) {
		    rs.access(new Resolve.StaticError(sym),
			      tree.pos, site, sym.name);
		}
		if (env.info.isSelfCall &amp;&amp;
		    sym.name != Names.init &amp;&amp;
		    tree.name == Names._this &amp;&amp;
		    site.tsym == env.enclClass.sym) {
		    chk.earlyRefError(tree.pos, sym);
		}
		Type site1 = env.enclClass.sym.type.asSuper(site.tsym);
		if (site1 != null) site = site1;
	    }
	    env.info.selectSuper = selectSuperPrev;
	}
	return checkId(tree, site, sym, pkind, pt);
    }
//where
        /** determine symbol referenced by a Select expression,
	 *  @param pos    position for error reporting
	 *  @param site   the type of the selected expression
	 *  @param name   the selector name
	 *  @param env    the current environment
	 *  @param pt     the current prototype
	 *  @param pkind  the expected kind(s) of the Select expression
	 */
        private Symbol selectSym(Select tree, Type site,
				 Env&lt;AttrContext&gt; env, Type pt, int pkind) {
	    int pos = tree.pos;
	    Name name = tree.name;
	    switch (site.tag) {
	    case PACKAGE:
		return rs.access(
		    rs.findIdentInPackage(env, site.tsym, name, pkind),
		    pos, site, name);
	    case ARRAY:
	    case CLASS:
		if (pt.tag == METHOD) {
		    if (name == Names._super) {
			return rs.resolveSelfConstructor(
			    pos, env, name, pt.argtypes());
		    } else {
			return rs.resolveQualifiedMethod(
			    pos, env, site, name, Type.emptyList, pt.argtypes
());
		    }
		} else if (name == Names._this) {
		    return rs.resolveSelf(pos, env, site.tsym, name);
		} else if (name == Names._class) {
		    return new VarSymbol(
			STATIC | PUBLIC, Names._class, syms.classType, 
site.tsym);
		} else {
		    Symbol sym = rs.findIdentInType(env, site, name, pkind);
		    if (sym.kind &gt;= rs.AMBIGUOUS) {
			if ((pkind &amp; (TYP | PCK)) != 0) {
			    Name pname = TreeInfo.fullName(tree.selected);
			    if (pname != null) {
				PackageSymbol p = syms.reader.enterPackage
(pname);
				Symbol sym1 = rs.findIdentInPackage(
				    env, p, name, pkind);
				if (sym1.kind &lt; sym.kind) sym = sym1;
			    }
			}
			sym = rs.access(sym, pos, site, name);
		    }
		    return sym;
		}
	    case TYPEVAR:
		return selectSym(tree, site.bound(), env, pt, pkind);
	    case ERROR:
		return Symbol.errSymbol;
	    default:
		if (name == Names._class) {
		    return new VarSymbol(
			STATIC | PUBLIC, Names._class, syms.classType, 
site.tsym);
		} else {	
		    log.error(pos, site + " cannot be dereferenced");
		}
		return Symbol.errSymbol;
	    }
	}

        /** determine type of identifier or select expression and check that
	 *  (1) the referenced symbol is not deprecated
	 *  (2) the symbol type is safe (@see checkSafe)
	 *  (3) if symbol is a variable, check that its type and kind are
	 *      compatible with the prototype and protokind.
	 *  (4) if symbol is a field of a raw type, which is being assigned to,
	 *      issue a warning if its type changes under erasure.
	 *  (5) if symbol is a method of a raw type, issue a warning if
	 *      its argument types change under erasure.
	 *  if checks succeed
	 *    if symbol is a constant return its constant type
	 *    else if symbol is a method return its result type
	 *    otherwise return its type
	 *  else return errType
	 */
        Type checkId(Tree tree, Type site, Symbol sym, int pkind, Type pt) {
	    if ((sym.flags() &amp; DEPRECATED) != 0) warnDeprecated(tree.pos, sym);
	    Type owntype;
	    switch (sym.kind) {
	    case TYP:
		owntype = sym.type;
		if (owntype.tag == CLASS &amp;&amp; owntype.typarams().nonEmpty()) {
		    owntype = new ClassType(
			owntype.outer(), Type.emptyList, owntype.tsym);
		}
		break;
	    case VAR:
		VarSymbol v = (VarSymbol)sym;
		if (!chk.unchecked &amp;&amp;
		    pkind == VAR &amp;&amp;
		    v.owner.kind == TYP &amp;&amp;
		    (v.flags() &amp; STATIC) == 0 &amp;&amp;
		    site.tag == CLASS) {
		    Type s = site.asOuterSuper(v.owner);
		    if (s != null &amp;&amp;
			s.isRaw() &amp;&amp;
			!v.type.sameType(v.erasure())) {
			log.warning(
			    tree.pos,
			    "unchecked assignment to " + v + " of raw type " + 
site);
		    }
		}
		owntype = (sym.owner.kind == TYP)
		    ? site.memberType(sym)
		    : sym.type;
		if (v.constValue != null) owntype = owntype.constType
(v.constValue);
		break;
	    case MTH:
//todo: find out why this can be false
//		Base.assert(site.asOuterSuper(sym.owner) != null,
//			    sym + " " + site + " " + sym.owner);//DEBUG
		if (!chk.unchecked &amp;&amp;
		    (sym.flags() &amp; STATIC) == 0 &amp;&amp;
		    site.tag == CLASS) {
		    Type s= site.asOuterSuper(sym.owner);
		    if (s != null &amp;&amp;
			s.isRaw() &amp;&amp;
			sym.name != Names.init &amp;&amp;
			!Type.sameTypes(
			    sym.type.argtypes(), sym.erasure().argtypes())) {
			log.warning(
			    tree.pos,
			    "unchecked call to " + sym + " of raw type " + 
site);
		    }
		}
		if (sym.name == Names.init) {
		    owntype = Type.voidType;
		} else {
		    owntype = rs.instantiate(
			site, sym, Type.emptyList, pt.argtypes());
		    if (owntype == null) {//debug
			log.error(
			    tree.pos, "internal error; cannot instantiate " +
			    sym + " at " + site + " to (" + pt.argtypes() 
+ ")");
		    }
		}
		break;
	    case PCK: case ERR:
		owntype = sym.type;
		break;
	    default:
		new Pretty().printExpr(tree);//debug
		throw new InternalError("unexpected kind: " + sym.kind);
	    }
	    infer.checkSafe(tree.pos, owntype, sym);
	    return check(tree, owntype, sym.kind, pkind, pt);
	}

        /** check that variable is initialized and evaluate the variable's
	 *  initializer, if not yet done
	 */
	private void checkInit(Tree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
//	    System.err.println(v + " " + ((v.flags() &amp; STATIC) != 0) + " " +
//			       tree.pos + " " + v.pos + " " +
//			       (env.info.staticLevel &gt; 
env.outer.info.staticLevel));//DEBUG
	    if (v.pos &gt; tree.pos &amp;&amp;
		(v.owner.kind == MTH ||
		 (v.owner.kind == TYP &amp;&amp;
		  v.owner == env.info.scope.owner &amp;&amp;
		  ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env))) &amp;&amp;
		(env.tree.tag != Tree.ASSIGN || tree != ((Assign)env.tree).lhs))
		log.error(tree.pos, "illegal forward reference");
	    evalInit(v, env);
	}

	/** evaluate a final variable's initializer
	 *  and set variable's constValue
	 */
	void evalInit(VarSymbol v, Env&lt;AttrContext&gt; env) {
	    if (v.constValue instanceof Enter.EnvAttrContextBox) {
		Env&lt;AttrContext&gt; evalEnv =
		    ((Enter.EnvAttrContextBox)v.constValue).env;
		Name prev = log.useSource(evalEnv.toplevel.sourcefile);
		v.constValue = null;
		Type itype = attribExpr(
		    ((VarDef)evalEnv.tree).init, evalEnv, v.type);
		if (itype.constValue != null)
		    v.constValue = cfolder.coerce(itype, v.type).constValue;
		log.useSource(prev);
	    }
	}

        /** check that `sym' does not hide any symbols of the same name and
	 *  kind in `scope'
	 */
        boolean checkNotHiding(int pos, Symbol sym, Scope scope) {
	    Scope.Entry e = scope.lookup(sym.name);
	    while (e.scope != null) {
		if (e.sym.owner != sym.owner &amp;&amp;
		    e.sym.kind == sym.kind &amp;&amp;
		    e.sym.owner == scope.owner) {
		    log.error(
			pos, sym + " is inherited from " + sym.owner +
			" and hides a " + Resolve.kindName(sym.kind) +
			" of the same name" + e.sym.location() +
			". An explicit `this' qualifier must be used to select 
the desired instance  ");
		    return false;
		}
		e = e.next();
	    }
	    return true;
	}

    public Type _case(Literal tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	return check(
	    tree, litType(tree.typetag).constType(tree.value), VAL, pkind, pt);
    }
//where
        Type litType(int tag) {
	    return (tag == CLASS) ? syms.stringType : Type.typeOfTag[tag];
	}

    public Type _case(TypeIdent tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	return check(tree, Type.typeOfTag[tree.typetag], TYP, pkind, pt);
    }

    public Type _case(TypeArray tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type etype = attribType(tree.elemtype, env);
	return check(tree, new ArrayType(etype), TYP, pkind, pt);
    }

    /** attribute type application.
     *  bound checking is left until later, since types are attributed
     *  before supertype structure is completely known
     */
    public Type _case(TypeApply tree, Env&lt;AttrContext&gt; env) {
	Type pt = env.info.pt;
	int pkind = env.info.pkind;
	Type owntype = Type.errType;

	Type clazztype = chk.checkClassType(
	    tree.clazz.pos, attribType(tree.clazz, env));

	ListBuffer&lt;Type&gt; actbuf = new ListBuffer&lt;Type&gt;();
	for (List&lt;Tree&gt; l = tree.arguments; l.nonEmpty(); l = l.tail)
	    actbuf.append(chk.checkRefType(l.head.pos, attribType(l.head, 
env)));
	List&lt;Type&gt; actuals = actbuf.toList();

	if (clazztype.tag == CLASS) {
	    List&lt;Type&gt; formals = clazztype.tsym.type.typarams();
	    if (actuals.length() == formals.length()) {
		owntype = new ClassType(
		    clazztype.tsym.type.outer(), actuals, clazztype.tsym);
	    } else {
		log.error(
		    tree.pos,
		    (formals.length() != 0)
		        ? "wrong number of type arguments; required: " +
		          formals.length()
		        : "type " + clazztype + " does not take parameters");
		owntype = Type.errType;
	    }
	}
	return check(tree, owntype, TYP, pkind, pt);
    }

    public Type _case(TypeParameter tree, Env&lt;AttrContext&gt; env) {
	TypeVar a = (TypeVar)tree.type;
	if (tree.extBound != null)
	    a.bound = attribBase(tree.extBound, env, 0);
	else if (tree.implBound != null)
	    a.bound = attribBase(tree.implBound, env, INTERFACE);
	else
	    a.bound = syms.objectType;
	return a;
    }

    public Type _case(Erroneous tree, Env&lt;AttrContext&gt; env) {
	return tree.type = Type.errType;
    }

    public Type _case(Tree tree, Env&lt;AttrContext&gt; env) {
	throw new InternalError();
    }

    /** main method: attribute class definition associated given class symbol
     */
    public void attribClass(ClassSymbol c) {
	Type st = c.type.supertype();
	if (st.tag == CLASS) attribClass((ClassSymbol)st.tsym);
	if (c.owner.kind == TYP) attribClass((ClassSymbol)c.owner);
	
	if ((c.flags_field &amp; UNFINISHED) != 0) {
	    Name prev = log.useSource(c.sourcefile);
	    c.flags_field &amp;= ~UNFINISHED;

	    Env&lt;AttrContext&gt; env = enter.classEnvs.get(c);
	    enter.classEnvs.remove(c);

	    ClassDef tree = (ClassDef)env.tree;
	
	    implementInterfaceMethods(c, env);
	    chk.validateTypeParams(tree.typarams);
	    chk.validate(tree.extending);
	    chk.validate(tree.implementing);
	    if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0)
		chk.checkAllDefined(tree.pos, c);
	    chk.checkClassBounds(tree.pos, c);
	
	    if (tree.typarams.length() != 0 &amp;&amp; c.subclass
(syms.throwableType.tsym))
		log.error(tree.pos,
			  "subtypes of java.lang.Throwable cannot have 
arguments");
	    tree.type = c.type;
	
	    for (List&lt;TypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = 
l.tail)
		env.info.scope.enterIfAbsent(l.head.type.tsym);
	
	    if ((c.flags() &amp; INTERFACE) == 0) {
		VarSymbol thisSym = new VarSymbol(FINAL, Names._this, c.type, 
c);
		thisSym.pos = Position.FIRSTPOS;
		env.info.scope.enter(thisSym);
		if (st.tag == CLASS) {
		    VarSymbol superSym = new VarSymbol(FINAL, Names._super, st, 
c);
		    superSym.pos = Position.FIRSTPOS;
		    env.info.scope.enter(superSym);
		}
		chk.checkImplementations(tree.pos, c);
	    } else {
		c.members_field = c.members_field.dup();
		implementInterfaceMethods(c, env);
		chk.checkImplementations(tree.pos, c);
		c.members_field = c.members_field.leave();
	    }
	
	    attribStats(tree.defs, env);
//	    checkConstructorsNonCyclic(tree.defs, env);
	    tree.type = c.type;

	    log.useSource(prev);
	}
    }
}
The selection parser seems to be in a infinite loop in the recovery mode. If it is not infinite, it is 
too long anyway.
Simpler test case:
[public class X {
    Object foo(Stack&lt;X&gt; s) {
    }
    List&lt;T&gt; bar(int pos, T x1, T x2, List&lt;T&gt; l) {
    }
}
]
Offending method is #bar, due to the combination of invalid return type and 
invalid last argument type. The recovery loops because it is branching back at 
the last closing parenthesis (not considering the one from #bar end of 
signature.

The forced argument reduction in case of recovery 
(RecoveredMethod#updateFromParserState) did not fix up the parser RParenPos, 
used then to update the next checkpoint. In this case, there is no right 
parenthesis consumed at this point yet.

Fixed.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12388" />
    <CreationDate amount="2002-03-27 16:01:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Update  (deprecated - use RT&gt;Equinox&gt;p2)" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Should we allow multiple unconfigured</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Right now when you unconfigure a feature you cannot unconfigure anotehr one
before you restart.
Should it be allowed (the asme way you can uninstall multiples features)
If so, is there any other pattern where multiple pending job can exist ?
can we discuss ?
The rules we have discussed were that we should not allow a second action on a 
feature that already has some changes pending. So unconfiguring 2 different 
features before restart should be OK, because the second feature does not have 
any changes pending.
We have to be able to unconfigure different features
That works.</WithStack>
    <WithOutStack>Right now when you unconfigure a feature you cannot unconfigure anotehr one
before you restart.
Should it be allowed (the asme way you can uninstall multiples features)
If so, is there any other pattern where multiple pending job can exist ?
can we discuss ?
The rules we have discussed were that we should not allow a second action on a 
feature that already has some changes pending. So unconfiguring 2 different 
features before restart should be OK, because the second feature does not have 
any changes pending.
We have to be able to unconfigure different features
That works.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12389" />
    <CreationDate amount="2002-03-27 16:01:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Error message at double-click on empty console</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437330634042">
        <Exception>org.eclipse.jface.text.BadLocationException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.jface.text.AbstractLineTracker.getLineNumberOfOffset(AbstractLineTracker.java:151)</Frame>
          <Frame depth="1">org.eclipse.jface.text.AbstractDocument.getLineOfOffset(AbstractDocument.java:604)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.debug.ui.actions.OpenOnConsoleTypeAction.determineSearchParameters(OpenOnConsoleTypeAction.java:240)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.debug.ui.actions.OpenOnConsoleTypeAction.doOpenType(OpenOnConsoleTypeAction.java:114)</Frame>
          <Frame depth="4">org.eclipse.jdt.internal.debug.ui.actions.OpenOnConsoleTypeAction.handleEvent(OpenOnConsoleTypeAction.java:345)</Frame>
          <Frame depth="5">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)</Frame>
          <Frame depth="6">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)</Frame>
          <Frame depth="7">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)</Frame>
          <Frame depth="8">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)</Frame>
          <Frame depth="9">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:722)</Frame>
          <Frame depth="10">org.eclipse.ui.internal.Workbench.run(Workbench.java:705)</Frame>
          <Frame depth="11">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:777)</Frame>
          <Frame depth="12">org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)</Frame>
          <Frame depth="13">java.lang.reflect.Method.invoke(Native Method)</Frame>
          <Frame depth="14">org.eclipse.core.launcher.Main.basicRun(Main.java:196)</Frame>
          <Frame depth="15">org.eclipse.core.launcher.Main.run(Main.java:555)</Frame>
          <Frame depth="16">org.eclipse.core.launcher.Main.main(Main.java:396)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>An error dialog titled "Open Type" containing "Error parsing console document" 
is shown when I double click on an empty console area. The log file contains 
the following:

Log: Wed Mar 27 14:59:39 CST 2002
4 org.eclipse.jdt.debug.ui 150 Internal Error
org.eclipse.jface.text.BadLocationException
	at org.eclipse.jface.text.AbstractLineTracker.getLineNumberOfOffset
(AbstractLineTracker.java:151)
	at org.eclipse.jface.text.AbstractDocument.getLineOfOffset
(AbstractDocument.java:604)
	at 
org.eclipse.jdt.internal.debug.ui.actions.OpenOnConsoleTypeAction.determineSearc
hParameters(OpenOnConsoleTypeAction.java:240)
	at 
org.eclipse.jdt.internal.debug.ui.actions.OpenOnConsoleTypeAction.doOpenType
(OpenOnConsoleTypeAction.java:114)
	at 
org.eclipse.jdt.internal.debug.ui.actions.OpenOnConsoleTypeAction.handleEvent
(OpenOnConsoleTypeAction.java:345)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:75)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1420)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1208)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:722)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:705)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:777)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:319)
	at java.lang.reflect.Method.invoke(Native Method)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:196)
	at org.eclipse.core.launcher.Main.run(Main.java:555)
	at org.eclipse.core.launcher.Main.main(Main.java:396)
Build is 20020321
I could not reproduce on 20020321 or 20020326.  I get a beep in this case.
Stepping thru the code I get a text selection offset of 0 and a linenumber of 0.
Anything else you could add to help me diagnose the problem?
It turns that I see the problem *after* the running application has terminated 
and I have manually cleared the console. The termination is somehow critical as 
I can't replicate the problem when the application is already running and I 
clear the console manually.
Turns out we were not firing a selection changed when clearing the console 
document.  Fixed in OpenOnConsoleTypeAction.
Please verify (Joe).
Verified.</WithStack>
    <WithOutStack>An error dialog titled "Open Type" containing "Error parsing console document" 
is shown when I double click on an empty console area. The log file contains 
the following:

Log: Wed Mar 27 14:59:39 CST 2002
4 org.eclipse.jdt.debug.ui 150 Internal Error

Build is 20020321
I could not reproduce on 20020321 or 20020326.  I get a beep in this case.
Stepping thru the code I get a text selection offset of 0 and a linenumber of 0.
Anything else you could add to help me diagnose the problem?
It turns that I see the problem *after* the running application has terminated 
and I have manually cleared the console. The termination is somehow critical as 
I can't replicate the problem when the application is already running and I 
clear the console manually.
Turns out we were not firing a selection changed when clearing the console 
document.  Fixed in OpenOnConsoleTypeAction.
Please verify (Joe).
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12390" />
    <CreationDate amount="2002-03-27 16:11:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Releng" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Add the provided PDE entry in "Welcome" page</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>As part of the overal efforts to make Eclipse plug-in development easier and 
more accessible to beginners, please add the following entry in the Eclipse SDK 
welcome.xml file. The entry has been tested. If the new lines have been 
relocated by Bugzilla text editor, please rearrange them to fit the item nicely 
into the overall welcome page text width:

&lt;item&gt;&lt;b&gt;Create Eclipse plug-ins &lt;/b&gt;
To create a new Eclipse plug-in, create a &lt;action pluginId="org.eclipse.pde"  
class="org.eclipse.pde.internal.wizards.project.OpenProjectWizardAction"&gt;plug-
in project&lt;/action&gt;. You will be able to choose between 
creating an empty plug-in project or starting with some useful content. To have 
the content 
generated, select one of the available templates in the wizard. 

After the project is created, the plug-in manifest editor will open into the 
&lt;b&gt;Welcome&lt;/b&gt; page 
that will tell you what you can do next.
&lt;/item&gt;
Please note that the plug-in id and class name has changed to the following:

pluginId = "org.eclipse.pde.ui"
class="org.eclipse.pde.internal.ui.wizards.project.OpenProjectWizardAction"

The welcome.xml in the org.eclipse.platform plugin has been updated and 
tested.  Fix will be in build 20020502.</WithStack>
    <WithOutStack>As part of the overal efforts to make Eclipse plug-in development easier and 
more accessible to beginners, please add the following entry in the Eclipse SDK 
welcome.xml file. The entry has been tested. If the new lines have been 
relocated by Bugzilla text editor, please rearrange them to fit the item nicely 
into the overall welcome page text width:

&lt;item&gt;&lt;b&gt;Create Eclipse plug-ins &lt;/b&gt;
To create a new Eclipse plug-in, create a &lt;action pluginId="org.eclipse.pde"  
class="org.eclipse.pde.internal.wizards.project.OpenProjectWizardAction"&gt;plug-
in project&lt;/action&gt;. You will be able to choose between 
creating an empty plug-in project or starting with some useful content. To have 
the content 
generated, select one of the available templates in the wizard. 

After the project is created, the plug-in manifest editor will open into the 
&lt;b&gt;Welcome&lt;/b&gt; page 
that will tell you what you can do next.
&lt;/item&gt;
Please note that the plug-in id and class name has changed to the following:

pluginId = "org.eclipse.pde.ui"
class="org.eclipse.pde.internal.ui.wizards.project.OpenProjectWizardAction"

The welcome.xml in the org.eclipse.platform plugin has been updated and 
tested.  Fix will be in build 20020502.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12391" />
    <CreationDate amount="2002-03-27 16:15:00 -0500" />
    <DupId amount="12224" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Handling OutOfMemoryError</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="8">
      <source_code type="package">
        <location start="1644" end="1682" />
        <code>package org.eclipse.benchmarks.search;</code>
      </source_code>
      <source_code type="import">
        <location start="1683" end="1715" />
        <code>import java.lang.reflect.Field;</code>
      </source_code>
      <source_code type="import">
        <location start="1716" end="1749" />
        <code>import org.eclipse.benchmarks.*;</code>
      </source_code>
      <source_code type="import">
        <location start="1750" end="1803" />
        <code>import org.eclipse.jface.viewers.StructuredSelection;</code>
      </source_code>
      <source_code type="import">
        <location start="1804" end="1856" />
        <code>import org.eclipse.pde.core.plugin.IPluginModelBase;</code>
      </source_code>
      <source_code type="import">
        <location start="1857" end="1915" />
        <code>import org.eclipse.search.internal.ui.text.TextSearchPage;</code>
      </source_code>
      <source_code type="import">
        <location start="1916" end="1949" />
        <code>import org.eclipse.swt.widgets.*;</code>
      </source_code>
      <source_code type="class">
        <location start="1951" end="3935" />
        <code>public class TextSearchBenchmark extends Benchmark {
	private static final int ITERATIONS = 25;
	
	private Shell shell;

	/**
	 * Constructor for TextSearchBenchmark.
	 * @param testName
	 */
	public TextSearchBenchmark(String testName) {
		super(testName);
	}

	public void testTextSearch() throws Exception {
		Field searchPattern = TextSearchPage.class.getDeclaredField
("fPattern");
		Field fileExtensions = TextSearchPage.class.getDeclaredField
("fExtensions");
		
		searchPattern.setAccessible(true);
		fileExtensions.setAccessible(true);
		
		Combo pattern;
		Combo extensions;
		
		TextSearchPage page = new TextSearchPage();
		SearchPageContainer container = new SearchPageContainer
(this.shell, new StructuredSelection(), page);
		
		container.setBlockOnOpen(false);
		container.open();
		
		pattern = (Combo)searchPattern.get(page);
		pattern.setText("for");
		
		extensions = (Combo)fileExtensions.get(page);
		extensions.setText("*.*");
		
		AggregateStopWatch watch = new AggregateStopWatch(ITERATIONS, 
1, new String[] {"Time to search for 'for'"});
		BenchmarkLogFile file = new BenchmarkLogFile();
		file.addWatch(watch, watch.getDefaultHeader("TextSearch", "Time 
to search all of Eclipse for instances of 'for'"));

		file.prepareForCrash();
		
		for(int i = 0; i &lt; ITERATIONS; i++) {
			watch.startNewIteration();
			page.performAction();
			watch.stopIteration();
			this.flushEventQueue(this.shell.getDisplay());
			System.out.println(i + 1);
		}
		
		container.cancelPressed();
		
		file.writeAsCSVTo(this.log);
		file.normalShutDown();
//		MessageDialog.openInformation(this.shell, "Wait loop", "Look 
for some search results");
	}
	
	public void setUp() throws Exception {
		super.setUp();
		
		this.shell = this.fWorkbench.getActiveWorkbenchWindow().getShell
();
		IPluginModelBase[] models = BenchmarkPDEUtil.getAllModels();
		BenchmarkPDEUtil.importModels(models, true);
//		BenchmarkPDEUtil.importModels(models, 0, Math.min(5, 
models.length), true);
	}
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="2">
        <Lines>
          <Line>1. text search</Line>
          <Line>2. remove all search results</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Build: 20020321

Description:
I developed a benchmark to determine how long it takes to do a plaintext search 
in Eclipse.  Effectively, my benchmark imports all of Eclipse as source, and 
then repeatedly searches for instances of the word 'for' in all available 
resources.  I can only do the search about 12 times before I get an error 
message telling me to go look in the log file for further details.  I did a 
system-wide search for this log file and found none.  After checking my 
benchmark code a few times, I performed the test manually and came up with the 
same results.  I lost track of how many searches it took to cause the error but 
I did eventually cause it.  

There are approximately 48,000 instances of 'for' in Eclipse.  The first few 
times I ran the search, it found all 48,000 and it seemed to run reasonably 
quickly.  The time that the search failed, it only found about 1,700 instances 
and the search ran very slowly.  I dismissed the error and tried the search 
again.  This time it found about 12,000 instances before failing the same way.  
I can't find a log file, or a core file, so I don't know what the exception 
was, and I don't have a stack trace.  The problem does seem to be repeatable, 
though.
Possible reason which comes to mind: out of memory exception


Could you provide the benchmark? Could my comment point into the right direction?


This is in the org.eclipse.benchmarks in ottcvs1://home/cvs/desktop in the 
class TextSearchBenchmark.

Here is the contents of the class. And yes I believe this was a result of an 
Out of Memory error as Search increases the siuze of the heap dramatically.


package org.eclipse.benchmarks.search;

import java.lang.reflect.Field;

import org.eclipse.benchmarks.*;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.pde.core.plugin.IPluginModelBase;
import org.eclipse.search.internal.ui.text.TextSearchPage;
import org.eclipse.swt.widgets.*;

public class TextSearchBenchmark extends Benchmark {
	private static final int ITERATIONS = 25;
	
	private Shell shell;

	/**
	 * Constructor for TextSearchBenchmark.
	 * @param testName
	 */
	public TextSearchBenchmark(String testName) {
		super(testName);
	}

	public void testTextSearch() throws Exception {
		Field searchPattern = TextSearchPage.class.getDeclaredField
("fPattern");
		Field fileExtensions = TextSearchPage.class.getDeclaredField
("fExtensions");
		
		searchPattern.setAccessible(true);
		fileExtensions.setAccessible(true);
		
		Combo pattern;
		Combo extensions;
		
		TextSearchPage page = new TextSearchPage();
		SearchPageContainer container = new SearchPageContainer
(this.shell, new StructuredSelection(), page);
		
		container.setBlockOnOpen(false);
		container.open();
		
		pattern = (Combo)searchPattern.get(page);
		pattern.setText("for");
		
		extensions = (Combo)fileExtensions.get(page);
		extensions.setText("*.*");
		
		AggregateStopWatch watch = new AggregateStopWatch(ITERATIONS, 
1, new String[] {"Time to search for 'for'"});
		BenchmarkLogFile file = new BenchmarkLogFile();
		file.addWatch(watch, watch.getDefaultHeader("TextSearch", "Time 
to search all of Eclipse for instances of 'for'"));

		file.prepareForCrash();
		
		for(int i = 0; i &lt; ITERATIONS; i++) {
			watch.startNewIteration();
			page.performAction();
			watch.stopIteration();
			this.flushEventQueue(this.shell.getDisplay());
			System.out.println(i + 1);
		}
		
		container.cancelPressed();
		
		file.writeAsCSVTo(this.log);
		file.normalShutDown();
//		MessageDialog.openInformation(this.shell, "Wait loop", "Look 
for some search results");
	}
	
	public void setUp() throws Exception {
		super.setUp();
		
		this.shell = this.fWorkbench.getActiveWorkbenchWindow().getShell
();
		IPluginModelBase[] models = BenchmarkPDEUtil.getAllModels();
		BenchmarkPDEUtil.importModels(models, true);
//		BenchmarkPDEUtil.importModels(models, 0, Math.min(5, 
models.length), true);
	}
}



see bug 16731 
and bug 16732
(once these get fixed we can retry this scenario)
nope, these 2 are not related
they are major , but show up only whan you close the search view, 
reopen, do search, close .... (basically, if you do search in a new view 
everytime)
sorry for confusion

i'm back to leak hunting...

more findings

no leak in the following scenario:
1. text search
2. remove all search results

however, repeated search is a problem
because all previous searches are kept around
objects of class Search are heavy-weighted - they have handles to many things

so, repeated search, without clearing search results will eventually lead 
to OutOfMemory error
Since the history is kept search will run out of memory at some point. When I
test it against 2.0 then an error dialog is shown which points you to the .log.
The .log contains the OutOfMemoryError. This can happen to *all* our operations
at some point: we normally don't catch OutOfMemoryError in our code to present a
special dialog.

This is a general platform issue: how do we handle out of memory and how is it
presented to the user. Currently he is most likely lost: the VM is already out
of memory and saving the workspace will fail. 
Core (along with Platform UI) should pre-allocate some memory, catch the
OutOfMemoryException if not headless show a dialog to the user saying we're out
of memory and then freeing the memory we allocated at the beginning, then save
and exit the workspace.

Moving to platform core for investigation of the general problem.

Old title: Internal Error after repeated search


*** This bug has been marked as a duplicate of 12224 ***</WithStack>
    <WithOutStack>Build: 20020321

Description:
I developed a benchmark to determine how long it takes to do a plaintext search 
in Eclipse.  Effectively, my benchmark imports all of Eclipse as source, and 
then repeatedly searches for instances of the word 'for' in all available 
resources.  I can only do the search about 12 times before I get an error 
message telling me to go look in the log file for further details.  I did a 
system-wide search for this log file and found none.  After checking my 
benchmark code a few times, I performed the test manually and came up with the 
same results.  I lost track of how many searches it took to cause the error but 
I did eventually cause it.  

There are approximately 48,000 instances of 'for' in Eclipse.  The first few 
times I ran the search, it found all 48,000 and it seemed to run reasonably 
quickly.  The time that the search failed, it only found about 1,700 instances 
and the search ran very slowly.  I dismissed the error and tried the search 
again.  This time it found about 12,000 instances before failing the same way.  
I can't find a log file, or a core file, so I don't know what the exception 
was, and I don't have a stack trace.  The problem does seem to be repeatable, 
though.
Possible reason which comes to mind: out of memory exception


Could you provide the benchmark? Could my comment point into the right direction?


This is in the org.eclipse.benchmarks in ottcvs1://home/cvs/desktop in the 
class TextSearchBenchmark.

Here is the contents of the class. And yes I believe this was a result of an 
Out of Memory error as Search increases the siuze of the heap dramatically.


package org.eclipse.benchmarks.search;

import java.lang.reflect.Field;

import org.eclipse.benchmarks.*;
import org.eclipse.jface.viewers.StructuredSelection;
import org.eclipse.pde.core.plugin.IPluginModelBase;
import org.eclipse.search.internal.ui.text.TextSearchPage;
import org.eclipse.swt.widgets.*;

public class TextSearchBenchmark extends Benchmark {
	private static final int ITERATIONS = 25;
	
	private Shell shell;

	/**
	 * Constructor for TextSearchBenchmark.
	 * @param testName
	 */
	public TextSearchBenchmark(String testName) {
		super(testName);
	}

	public void testTextSearch() throws Exception {
		Field searchPattern = TextSearchPage.class.getDeclaredField
("fPattern");
		Field fileExtensions = TextSearchPage.class.getDeclaredField
("fExtensions");
		
		searchPattern.setAccessible(true);
		fileExtensions.setAccessible(true);
		
		Combo pattern;
		Combo extensions;
		
		TextSearchPage page = new TextSearchPage();
		SearchPageContainer container = new SearchPageContainer
(this.shell, new StructuredSelection(), page);
		
		container.setBlockOnOpen(false);
		container.open();
		
		pattern = (Combo)searchPattern.get(page);
		pattern.setText("for");
		
		extensions = (Combo)fileExtensions.get(page);
		extensions.setText("*.*");
		
		AggregateStopWatch watch = new AggregateStopWatch(ITERATIONS, 
1, new String[] {"Time to search for 'for'"});
		BenchmarkLogFile file = new BenchmarkLogFile();
		file.addWatch(watch, watch.getDefaultHeader("TextSearch", "Time 
to search all of Eclipse for instances of 'for'"));

		file.prepareForCrash();
		
		for(int i = 0; i &lt; ITERATIONS; i++) {
			watch.startNewIteration();
			page.performAction();
			watch.stopIteration();
			this.flushEventQueue(this.shell.getDisplay());
			System.out.println(i + 1);
		}
		
		container.cancelPressed();
		
		file.writeAsCSVTo(this.log);
		file.normalShutDown();
//		MessageDialog.openInformation(this.shell, "Wait loop", "Look 
for some search results");
	}
	
	public void setUp() throws Exception {
		super.setUp();
		
		this.shell = this.fWorkbench.getActiveWorkbenchWindow().getShell
();
		IPluginModelBase[] models = BenchmarkPDEUtil.getAllModels();
		BenchmarkPDEUtil.importModels(models, true);
//		BenchmarkPDEUtil.importModels(models, 0, Math.min(5, 
models.length), true);
	}
}



see bug 16731 
and bug 16732
(once these get fixed we can retry this scenario)
nope, these 2 are not related
they are major , but show up only whan you close the search view, 
reopen, do search, close .... (basically, if you do search in a new view 
everytime)
sorry for confusion

i'm back to leak hunting...

more findings

no leak in the following scenario:
1. text search
2. remove all search results

however, repeated search is a problem
because all previous searches are kept around
objects of class Search are heavy-weighted - they have handles to many things

so, repeated search, without clearing search results will eventually lead 
to OutOfMemory error
Since the history is kept search will run out of memory at some point. When I
test it against 2.0 then an error dialog is shown which points you to the .log.
The .log contains the OutOfMemoryError. This can happen to *all* our operations
at some point: we normally don't catch OutOfMemoryError in our code to present a
special dialog.

This is a general platform issue: how do we handle out of memory and how is it
presented to the user. Currently he is most likely lost: the VM is already out
of memory and saving the workspace will fail. 
Core (along with Platform UI) should pre-allocate some memory, catch the
OutOfMemoryException if not headless show a dialog to the user saying we're out
of memory and then freeing the memory we allocated at the beginning, then save
and exit the workspace.

Moving to platform core for investigation of the general problem.

Old title: Internal Error after repeated search


*** This bug has been marked as a duplicate of 12224 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12392" />
    <CreationDate amount="2002-03-27 16:21:00 -0500" />
    <DupId amount="12977" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Problems to add Project from repository</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="2">
        <Lines>
          <Line>- create a vanilla project</Line>
          <Line>- added the lines to .project to "turn it into a java project"</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Hello,

I have problems with adding projects to my Java view. If I add a project 
with "Check out as project" in the CVS Respoitories view, I see it in the 
Resources Perspective, but not in the Java Perspective. 

The only way is to add a new Project (with the same name in the repository) to 
my Java Perspective and than synchronize it with the repository.

My current version is: Stable Build 20020321 

Mirko
*** Bug 12393 has been marked as a duplicate of this bug. ***
Are the projects in your repository Eclipse projects? (e.g. do they contain 
either a .project or .vcm_meta file?)

Moving to Platform/VCM for comment.
I saw similar today but with completely different steps not involving VCM:

- create a vanilla project
- added the lines to .project to "turn it into a java project"

The resulting project was decorated with a 'J' in the navigator and I was able 
to get at its Java properties and change its source folder, a bin folder 
appeared in the project, etc., which all suggests it was a real java project.

And yet, I couldn't get it to show up in the Packages view.  I tried closing 
and recreating the Packages view to no avail.  I didn't try closing and 
restarting the workbench (it was end of day and had to get going).

Moving to JDT-UI for comment.
Yes, there is a .project file in the repository, and in the workspace local 
file system.


Mirko


As a workaround try to close and reopen the Java project in the navigator.

moving to JDT CORE for investigation.
We did not reconcile addition of Java nature properly. This should be fixed in 
latest integration build.

Please confirm it is so.


*** This bug has been marked as a duplicate of 12977 ***</WithStack>
    <WithOutStack>Hello,

I have problems with adding projects to my Java view. If I add a project 
with "Check out as project" in the CVS Respoitories view, I see it in the 
Resources Perspective, but not in the Java Perspective. 

The only way is to add a new Project (with the same name in the repository) to 
my Java Perspective and than synchronize it with the repository.

My current version is: Stable Build 20020321 

Mirko
*** Bug 12393 has been marked as a duplicate of this bug. ***
Are the projects in your repository Eclipse projects? (e.g. do they contain 
either a .project or .vcm_meta file?)

Moving to Platform/VCM for comment.
I saw similar today but with completely different steps not involving VCM:

- create a vanilla project
- added the lines to .project to "turn it into a java project"

The resulting project was decorated with a 'J' in the navigator and I was able 
to get at its Java properties and change its source folder, a bin folder 
appeared in the project, etc., which all suggests it was a real java project.

And yet, I couldn't get it to show up in the Packages view.  I tried closing 
and recreating the Packages view to no avail.  I didn't try closing and 
restarting the workbench (it was end of day and had to get going).

Moving to JDT-UI for comment.
Yes, there is a .project file in the repository, and in the workspace local 
file system.


Mirko


As a workaround try to close and reopen the Java project in the navigator.

moving to JDT CORE for investigation.
We did not reconcile addition of Java nature properly. This should be fixed in 
latest integration build.

Please confirm it is so.


*** This bug has been marked as a duplicate of 12977 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12393" />
    <CreationDate amount="2002-03-27 16:21:00 -0500" />
    <DupId amount="12392" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Problems to add Project from repository</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Hello,

I have problems with adding projects to my Java view. If I add a project 
with "Check out as project" in the CVS Respoitories view, I see it in the 
Resources Perspective, but not in the Java Perspective. 

The only way is to add a new Project (with the same name in the repository) to 
my Java Perspective and than synchronize it with the repository.

My current version is: Stable Build 20020321 

Mirko


*** This bug has been marked as a duplicate of 12392 ***</WithStack>
    <WithOutStack>Hello,

I have problems with adding projects to my Java view. If I add a project 
with "Check out as project" in the CVS Respoitories view, I see it in the 
Resources Perspective, but not in the Java Perspective. 

The only way is to add a new Project (with the same name in the repository) to 
my Java Perspective and than synchronize it with the repository.

My current version is: Stable Build 20020321 

Mirko


*** This bug has been marked as a duplicate of 12392 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12394" />
    <CreationDate amount="2002-03-27 16:24:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Problems to create new CVS project</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="2">
      <Enumeration lines="10">
        <Lines>
          <Line>1. what version of the server and type (linux, CVSNT)</Line>
          <Line>2. was there anything in the .log?</Line>
          <Line>3. are the steps reproduceable?</Line>
          <Line>4. are you sure the server was accessible?  For example could you create a repo</Line>
          <Line>location for it and browse it?</Line>
          <Line>1. Version is CVSNT 1.11.1.3</Line>
          <Line>2. Where do I find the .log?</Line>
          <Line>3. The steps are reproduceable</Line>
          <Line>4. The server is accessable. If I create the project on CVS and import it, than</Line>
          <Line>I can synchronize it without problems. But I can't create one in Eclipse.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="5">
        <Lines>
          <Line>1. Version is CVSNT 1.11.1.3</Line>
          <Line>2. Where do I find the .log?</Line>
          <Line>3. The steps are reproduceable</Line>
          <Line>4. The server is accessable. If I create the project on CVS and import it, than</Line>
          <Line>I can synchronize it without problems. But I can't create one in Eclipse.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Hello,

if I click "Share Project" in the Java perspective to share a new project in 
CVS, I get the message "Unknown response received from server"...

My current version is: Stable Build 20020321 

Mirko
Can you please let us know:

1. what version of the server and type (linux, CVSNT)
2. was there anything in the .log?
3. are the steps reproduceable?
4. are you sure the server was accessible?  For example could you create a repo 
location for it and browse it?
1. Version is CVSNT 1.11.1.3
2. Where do I find the .log?
3. The steps are reproduceable
4. The server is accessable. If I create the project on CVS and import it, than 
I can synchronize it without problems. But I can't create one in Eclipse.

The .log is found under the .metadata directory (your workspace location).

Usually something like c:\eclipse\workspace\.metadata\.log.
What connection method did you use? We usually see this error when using an 
improperly configured EXT methd.
I am using pserver to connect to CVSNT.

Mirko
Closing bug.
Its a month old and we haven't seen anything related - not enough for us to 
take action on, and its CVSNT which we don't support.</WithStack>
    <WithOutStack>Hello,

if I click "Share Project" in the Java perspective to share a new project in 
CVS, I get the message "Unknown response received from server"...

My current version is: Stable Build 20020321 

Mirko
Can you please let us know:

1. what version of the server and type (linux, CVSNT)
2. was there anything in the .log?
3. are the steps reproduceable?
4. are you sure the server was accessible?  For example could you create a repo 
location for it and browse it?
1. Version is CVSNT 1.11.1.3
2. Where do I find the .log?
3. The steps are reproduceable
4. The server is accessable. If I create the project on CVS and import it, than 
I can synchronize it without problems. But I can't create one in Eclipse.

The .log is found under the .metadata directory (your workspace location).

Usually something like c:\eclipse\workspace\.metadata\.log.
What connection method did you use? We usually see this error when using an 
improperly configured EXT methd.
I am using pserver to connect to CVSNT.

Mirko
Closing bug.
Its a month old and we haven't seen anything related - not enough for us to 
take action on, and its CVSNT which we don't support.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12395" />
    <CreationDate amount="2002-03-27 16:29:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Export function</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Hello,

if I wnat to export a project and select "File system", than check "Create 
directory structure for files", to get the package structure. The default is, 
that the project name is exported, too. 

So I have to uncheck the whole project and check my packages to get only the 
package structure.

I think normally a developer only wnats the package structure exported directly 
to the destination directory.

My current version is: Stable Build 20020321 

Mirko
Moving to Platform/UI for comment about the export.
Export is resource centric - the exportresources option does not think in terms 
of java.

What you can do (which is easier) is select the project, deselect one of the 
packages and reselect it - the project will show as grey and will then not be 
exported.

Select the Create Only Selected Directories option and you will get what you 
want
Marking as Works for me.</WithStack>
    <WithOutStack>Hello,

if I wnat to export a project and select "File system", than check "Create 
directory structure for files", to get the package structure. The default is, 
that the project name is exported, too. 

So I have to uncheck the whole project and check my packages to get only the 
package structure.

I think normally a developer only wnats the package structure exported directly 
to the destination directory.

My current version is: Stable Build 20020321 

Mirko
Moving to Platform/UI for comment about the export.
Export is resource centric - the exportresources option does not think in terms 
of java.

What you can do (which is easier) is select the project, deselect one of the 
packages and reselect it - the project will show as grey and will then not be 
exported.

Select the Create Only Selected Directories option and you will get what you 
want
Marking as Works for me.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12396" />
    <CreationDate amount="2002-03-27 16:48:00 -0500" />
    <DupId amount="21240" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[CVS Sync View] Synchronizing package synchronizes fragments as well</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>build 20020321

When I synchronize org.eclipse.ui, the synchronize viewer shows outgoing 
changes in org.eclipse.ui.internal.model.
Probably related, not only org.eclipse.ui.internal.model, but also 
org.eclipse.ui.internal and org.eclipse.ui are shown with the "change present" 
decorator.
Indeed related.

Package fragments are semantically shallow, while folders are semantically deep.
The packages view maps a package fragment to a folder, on which we operate. We
have found no viable solution to this problem, and I don't think we'll be
addressing it in 2.0.
Unsolveable for 2.0, regretably
Reopening
*** Bug 25587 has been marked as a duplicate of this bug. ***


*** This bug has been marked as a duplicate of 21240 ***</WithStack>
    <WithOutStack>build 20020321

When I synchronize org.eclipse.ui, the synchronize viewer shows outgoing 
changes in org.eclipse.ui.internal.model.
Probably related, not only org.eclipse.ui.internal.model, but also 
org.eclipse.ui.internal and org.eclipse.ui are shown with the "change present" 
decorator.
Indeed related.

Package fragments are semantically shallow, while folders are semantically deep.
The packages view maps a package fragment to a folder, on which we operate. We
have found no viable solution to this problem, and I don't think we'll be
addressing it in 2.0.
Unsolveable for 2.0, regretably
Reopening
*** Bug 25587 has been marked as a duplicate of this bug. ***


*** This bug has been marked as a duplicate of 21240 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12397" />
    <CreationDate amount="2002-03-27 17:06:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[resources] Cannot delete read-only file</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="8">
        <Lines>
          <Line>- create project AAA</Line>
          <Line>- create file myfile.txt</Line>
          <Line>- context menu on myfile.txt and check mark read-only in the properties</Line>
          <Line>- confirm via Windows Explorer that the file is read-only on disk</Line>
          <Line>- select the file in the Navigator</Line>
          <Line>- context menu -&gt; Delete</Line>
          <Line>- Yes to delete and Yes to I'm really sure</Line>
          <Line>- file is deleted from both the workspace and file system</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>If I create a simple project, add a file to it and mark it the file read only, 
I cannot delete it, even though the UI prompts me twice: once to ask to confirm 
and once to ask to confirm a deletion of a read-only file. I assume that the 
introduction of the move/delete hook is responsible for this.
Which build are you using?
I am unable to reproduce this using the latest Core on a 2002-03-21 build. 
The steps that I am using:

- create project AAA
- create file myfile.txt
- context menu on myfile.txt and check mark read-only in the properties
- confirm via Windows Explorer that the file is read-only on disk
- select the file in the Navigator
- context menu -&gt; Delete
- Yes to delete and Yes to I'm really sure
- file is deleted from both the workspace and file system

Also, you mention the move/delete hook. Does this mean that you have a CVS (or 
other) implementation hooked in your workspace or are you defaulting to the 
standard delete behaviour?
This happened in my self-hosting workspace. It works in my regular workspace. 
This is strange since I'm running on the same code in both.
Is this still a problem for you in build 2002-04-02?
Thanks.
Yes, it still occures
I found the problem! It only occurs using J9
Works ok in build i20041026.</WithStack>
    <WithOutStack>If I create a simple project, add a file to it and mark it the file read only, 
I cannot delete it, even though the UI prompts me twice: once to ask to confirm 
and once to ask to confirm a deletion of a read-only file. I assume that the 
introduction of the move/delete hook is responsible for this.
Which build are you using?
I am unable to reproduce this using the latest Core on a 2002-03-21 build. 
The steps that I am using:

- create project AAA
- create file myfile.txt
- context menu on myfile.txt and check mark read-only in the properties
- confirm via Windows Explorer that the file is read-only on disk
- select the file in the Navigator
- context menu -&gt; Delete
- Yes to delete and Yes to I'm really sure
- file is deleted from both the workspace and file system

Also, you mention the move/delete hook. Does this mean that you have a CVS (or 
other) implementation hooked in your workspace or are you defaulting to the 
standard delete behaviour?
This happened in my self-hosting workspace. It works in my regular workspace. 
This is strange since I'm running on the same code in both.
Is this still a problem for you in build 2002-04-02?
Thanks.
Yes, it still occures
I found the problem! It only occurs using J9
Works ok in build i20041026.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12398" />
    <CreationDate amount="2002-03-27 17:13:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P1" />
    <bug_severity amount="blocker" />
    <Summery>Accessibility problems</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="18">
      <source_code type="multicomment">
        <location start="3211" end="3283" />
        <code>/*
 * (c) Copyright IBM Corp. 2000, 2002.
 * All Rights Reserved.
 */</code>
      </source_code>
      <source_code type="package">
        <location start="3284" end="3335" />
        <code>package org.eclipse.help.ui.internal.browser.win32;</code>
      </source_code>
      <source_code type="import">
        <location start="3336" end="3400" />
        <code>import org.eclipse.help.internal.ui.util.HelpWorkbenchException;</code>
      </source_code>
      <source_code type="import">
        <location start="3401" end="3445" />
        <code>import org.eclipse.help.ui.browser.IBrowser;</code>
      </source_code>
      <source_code type="import">
        <location start="3446" end="3473" />
        <code>import org.eclipse.swt.SWT;</code>
      </source_code>
      <source_code type="import">
        <location start="3474" end="3506" />
        <code>import org.eclipse.swt.events.*;</code>
      </source_code>
      <source_code type="import">
        <location start="3507" end="3539" />
        <code>import org.eclipse.swt.layout.*;</code>
      </source_code>
      <source_code type="import">
        <location start="3540" end="3573" />
        <code>import org.eclipse.swt.widgets.*;</code>
      </source_code>
      <source_code type="functiondef">
        <location start="3714" end="3799" />
        <code>public void displayURL(String url) {
		createShell();
		webBrowser.navigate(url);
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="3800" end="4190" />
        <code>private void createShell() {
		Shell shell = new Shell();
		GridLayout layout = new GridLayout();
		layout.marginHeight = 0;
		layout.marginWidth = 0;
		layout.horizontalSpacing = 0;
		layout.verticalSpacing = 0;
		shell.setLayout(layout);
		createContents(shell);
		int w = 800;
		int h = 600;
		shell.setSize(w, h);
		shell.open();
		//shell.setVisible(true);
		shell.moveAbove(null);
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="4191" end="5827" />
        <code>private Control createContents(Composite parent) {
		Composite composite = new Composite(parent, SWT.NONE);
		GridData data = new GridData(GridData.FILL_BOTH);
		composite.setLayoutData(data);
		GridLayout layout = new GridLayout();
		layout.marginHeight = 0;
		layout.marginWidth = 0;
		layout.horizontalSpacing = 0;
		layout.verticalSpacing = 0;
		composite.setLayout(layout);
		// Add a toolbar
		ToolBar bar = new ToolBar(composite, SWT.FLAT | SWT.HORIZONTAL);
		GridData gridData = new GridData();
		gridData.horizontalAlignment = GridData.FILL;
		gridData.grabExcessHorizontalSpace = true;
		//gridData.horizontalSpan = 3;
		bar.setLayoutData(gridData);
		// Add a button to navigate back
		backItem = new ToolItem(bar, SWT.HORIZONTAL, 0);
		backItem.setText("Previous_page");
		backItem.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				webBrowser.back();
			}
			public void widgetDefaultSelected(SelectionEvent e) {
				widgetSelected(e);
			}
		});
		// Add a button to navigate forward
		forwardItem = new ToolItem(bar, SWT.NONE, 1);
		forwardItem.setText("Next_page");
		forwardItem.setHotImage(null);
		forwardItem.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				webBrowser.forward();
			}
			public void widgetDefaultSelected(SelectionEvent e) {
				widgetSelected(e);
			}
		});
		try {
			webBrowser = new WebBrowser(composite);
			webBrowser.addCommandStateChangedListener(this);
			webBrowser.navigate("about:blank");
		} catch (HelpWorkbenchException hwe) {
			System.err.println(hwe);
		}
		return composite;
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="5828" end="6042" />
        <code>public void commandStateChanged(boolean back, boolean forward) {
		if (backItem.getEnabled() != back)
			backItem.setEnabled(back);
		if (forwardItem.getEnabled() != forward)
			forwardItem.setEnabled(forward);
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6043" end="6068" />
        <code>public void close() {
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6069" end="6123" />
        <code>public boolean isCloseSupported() {
		return true;
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6124" end="6184" />
        <code>public boolean isSetLocationSupported() {
		return true;
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6185" end="6241" />
        <code>public boolean isSetSizeSupported() {
		return true;
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6242" end="6285" />
        <code>public void setLocation(int x, int y) {
	}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="6286" end="6334" />
        <code>public void setSize(int width, int height) {
	}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="2">
      <Enumeration lines="14">
        <Lines>
          <Line>a)  Visible effect of page being reloaded.</Line>
          <Line>b)  Audible click sound, while no navigation has been triggered by the user.</Line>
          <Line>c)  All user state information within a frame to be reset, i.e. the state of</Line>
          <Line>the navigation tree, navigation page displayed will be lost.  All of help</Line>
          <Line>frames (except the topic content) have dynamic content that reloading the frame</Line>
          <Line>will reset.</Line>
          <Line>3.  The above effects will also affect users not using keyboard navigation.</Line>
          <Line>Whenever user brings the help window to foreground, or restores from minimized</Line>
          <Line>state the focus is set</Line>
          <Line>4.  Browser history might be affected.</Line>
          <Line>We have done all we can about this issue. You need to set up your pages in a</Line>
          <Line>way that allows you to reference the content in a navigable way. We have</Line>
          <Line>described the nature of the problem and provided a possible workaround. We do</Line>
          <Line>not have time to do more than that.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="19">
        <Lines>
          <Line>1.  The name of the frame to navigate is not always known.  Help browser is not</Line>
          <Line>only used to display help frame set.  Same goes for the URL displayed within a</Line>
          <Line>frame.  URLs to load within help frames are dynamically computed by JavaScript.</Line>
          <Line>2.  Calling this navigate method, will cause frame to be reloaded.  This in</Line>
          <Line>turn results in:</Line>
          <Line>a)  Visible effect of page being reloaded.</Line>
          <Line>b)  Audible click sound, while no navigation has been triggered by the user.</Line>
          <Line>c)  All user state information within a frame to be reset, i.e. the state of</Line>
          <Line>the navigation tree, navigation page displayed will be lost.  All of help</Line>
          <Line>frames (except the topic content) have dynamic content that reloading the frame</Line>
          <Line>will reset.</Line>
          <Line>3.  The above effects will also affect users not using keyboard navigation.</Line>
          <Line>Whenever user brings the help window to foreground, or restores from minimized</Line>
          <Line>state the focus is set</Line>
          <Line>4.  Browser history might be affected.</Line>
          <Line>We have done all we can about this issue. You need to set up your pages in a</Line>
          <Line>way that allows you to reference the content in a navigable way. We have</Line>
          <Line>described the nature of the problem and provided a possible workaround. We do</Line>
          <Line>not have time to do more than that.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>20020326, Win2K

When I launch the Help view, the tab key does not actually do anything. I need 
to first click on one of the "live" areas before it starts working (eg. the 
banner with the tool buttons, the nav frame or the content frame. We should be 
starting the Help view in a way that can be immediately navigated via the 
keyboard.
It also does not work when launched from F1 or search.
I will make it a P2 item, but it should probably be a P1
Our OLE control for Internet Explorer does not accept focus until it is clicked 
once.

Since the back and forward buttons are initially dissabled, there is nothing 
left in the shell to accept the focus.  If I create some controls that accept 
focus (or anable toolbar buttons), the focus traverses these controls but skips 
OLE.  Once OLE control is clicked, the focus can traverse all controls.

I will route the bug to SWT.  Could you (SWT experts) see if we need to do 
anything special, or is this SWT or IE limitation?  Please change back the 
component if this does not look like SWT bug.
&lt;rant&gt;
It is incredibly hard to debug and test changes to SWT or to your IEHost - I 
can't just modify your code and run with it because I get 
a "javax.servlet.ServletException: org.eclipse.core.boot.BootLoader " error.  
And if I make changes to SWT I guess I have to create a jar and put it in the 
plugins folder because you do not seem to pick up the changes from the 
workspace and even then, where is standard out - I was unable to verify that I 
actually ever ran my code changes.  I was in fact unable to test any changes 
with your stuff but I have been testing against a plain IE ActiveX control.  
&lt;/rant&gt;

I made one fix which helps to get focus in other activeX controls but it does 
not seem to help IE.  I have found no way to get IE to become active and take 
input except for clicking on the control.  I will continue to poke around but I 
do not have high hopes.
It should not be too bad to work with IHost (with SWT being contstant in a dll).
Standard out is written to Eclipse .log file.  There is one message per line 
and they start with "Web browser message:" followed by line that IEHost wrote 
to stdout.

javax.servlet.ServletException: org.eclipse.core.boot.BootLoader error - I have 
never seen it.  You should be able to have 0409 integration driver, load 
org.eclipse.help.ui from repository, import other plugins to your workspace and 
run help.  The error might be caused by having SWT in a workspace rather than a 
dll.  I do not know the mechanism what happens then.
If you tried self hosting help, you should also import the org.eclipse.tomcat 
into the same workspace. Basically you need to have the tomcat and help plugins 
in the same directory.
If you take the below code and overwrite the 
org.eclipse.help.ui.internal.browser.win32.IEBrowserAdapter, it will allow for 
easier debugging.  It will open an in-process shell with embedded IE, instead 
of launching IEHost class in a separate process, but still has the problem that 
this bug is about.

It should be easy to debug this now.  Make sure you have plugins
  org.eclipse.help
  org.eclipse.help.ui
  org.eclipse.help.webapp
  org.eclipse.tomcat
in your workspace.
 

/*
 * (c) Copyright IBM Corp. 2000, 2002.
 * All Rights Reserved.
 */
package org.eclipse.help.ui.internal.browser.win32;
import org.eclipse.help.internal.ui.util.HelpWorkbenchException;
import org.eclipse.help.ui.browser.IBrowser;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.*;
import org.eclipse.swt.layout.*;
import org.eclipse.swt.widgets.*;
public class IEBrowserAdapter
	implements IBrowser, ICommandStateChangedListener {
	WebBrowser webBrowser;
	ToolItem backItem, forwardItem;
	public void displayURL(String url) {
		createShell();
		webBrowser.navigate(url);
	}
	private void createShell() {
		Shell shell = new Shell();
		GridLayout layout = new GridLayout();
		layout.marginHeight = 0;
		layout.marginWidth = 0;
		layout.horizontalSpacing = 0;
		layout.verticalSpacing = 0;
		shell.setLayout(layout);
		createContents(shell);
		int w = 800;
		int h = 600;
		shell.setSize(w, h);
		shell.open();
		//shell.setVisible(true);
		shell.moveAbove(null);
	}
	private Control createContents(Composite parent) {
		Composite composite = new Composite(parent, SWT.NONE);
		GridData data = new GridData(GridData.FILL_BOTH);
		composite.setLayoutData(data);
		GridLayout layout = new GridLayout();
		layout.marginHeight = 0;
		layout.marginWidth = 0;
		layout.horizontalSpacing = 0;
		layout.verticalSpacing = 0;
		composite.setLayout(layout);
		// Add a toolbar
		ToolBar bar = new ToolBar(composite, SWT.FLAT | SWT.HORIZONTAL);
		GridData gridData = new GridData();
		gridData.horizontalAlignment = GridData.FILL;
		gridData.grabExcessHorizontalSpace = true;
		//gridData.horizontalSpan = 3;
		bar.setLayoutData(gridData);
		// Add a button to navigate back
		backItem = new ToolItem(bar, SWT.HORIZONTAL, 0);
		backItem.setText("Previous_page");
		backItem.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				webBrowser.back();
			}
			public void widgetDefaultSelected(SelectionEvent e) {
				widgetSelected(e);
			}
		});
		// Add a button to navigate forward
		forwardItem = new ToolItem(bar, SWT.NONE, 1);
		forwardItem.setText("Next_page");
		forwardItem.setHotImage(null);
		forwardItem.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				webBrowser.forward();
			}
			public void widgetDefaultSelected(SelectionEvent e) {
				widgetSelected(e);
			}
		});
		try {
			webBrowser = new WebBrowser(composite);
			webBrowser.addCommandStateChangedListener(this);
			webBrowser.navigate("about:blank");
		} catch (HelpWorkbenchException hwe) {
			System.err.println(hwe);
		}
		return composite;
	}
	public void commandStateChanged(boolean back, boolean forward) {
		if (backItem.getEnabled() != back)
			backItem.setEnabled(back);
		if (forwardItem.getEnabled() != forward)
			forwardItem.setEnabled(forward);
	}
	public void close() {
	}
	public boolean isCloseSupported() {
		return true;
	}
	public boolean isSetLocationSupported() {
		return true;
	}
	public boolean isSetSizeSupported() {
		return true;
	}
	public void setLocation(int x, int y) {
	}
	public void setSize(int width, int height) {
	}

}
This is critical for 13934 (P1, blocker).
Without it, help cannot be navigated with the keyboard.
I think I may have a solution for this one in hand.  The biggest problem I have 
to overcome before releasing it is that the solution seems to break Word and 
Paint which are embedded editors in Eclipse.

I may just release this as a change to OleControlSite and leave OleClientSite 
untouched.  We shall see.
I have released the fix to just the OleControlSite part.  This is in today's 
integration build (0515).
Veronika, this fixed the orginal problem but broke it in a different place:

- click Tab or Ctrl-Tab until you get focus on the toolbar that contains the 
tree icons: toggle navigation, synchronize and print (this is just above the 
main help area). Tab or Ctrl-Tab on this frame. The focus never leaveas the 
frame, or if it does, it goes to the main SWT control with back/forward buttons 
if they are enabled and comes back to the same frame.

Keybaord navigation works fine in IE (try Ctrl-N when focus is on Help view, it 
should open the browser), and also worked fine before the fix. The problem was 
only getting the initial focus inside the control.

We opened bug 16093 for it, but I will probably mark it as a dup of this bug.
The problem you are seeing is described by:

http://dev.eclipse.org/bugs/show_bug.cgi?id=5910

5910 is fixed but not in 0515 - see the HEAD stream to test it.

Everything works in IE because the place you tab to after the print button is 
the text field in the ie browser which takes focus.  In the embedded guy, the 
place you tab to is the forward/backward toolbar which has nothing but disabled 
items in it and grabs the focus erroniously.

Closing this PR and marking 16093 asa duplicate of 5910.
I am reoppenning this, as the fix caused a regression.

In this driver when back button and forward button are anabled, tab navigation 
does not work correctly.  After tabbing to toolbar frame, focuses gets to 
toolbar buttons and back to toolbar frame.  It does not move to next (first) 
frame.  I was suggested in bug 16093 that shift tab should be used.  Shift tab 
causes focus to traverse frames back but stops on the first frame without 
placing focus on toolbar.
Both tab and shift-tab should allow for getting to all the frames.  There 
should not be frames beyond which keyboard navigation does not work.

Notice that in the build, that did not contain fix for the original problem, 
once the IE area has been clicked once with the mouse, the focus could traverse 
all frames and toolbar without any dead ends.

There is something different about your web page.  I have tested this with the 
OTI internal home page and I can access all fields on the page by tabbing 
around even when tabbing in and out.

This is the behaviour of the activeX control and there is nothing I can do 
about forcing the focus to go to one frame or another on activation.

In the old driver the control was never activated/deactivated when focus 
changed.
Can you guys use the following Navigate method in which you specify the frame 
to navigate to as a workaround.  Listen for focus in and then call this method 
on the OleAutomation object to force the focus to the first frame on your page 
using TargetFrameForName :

IWebBrowser2.Navigate

Navigates to a resource identified by a URL or to the file identified by a full 
path.

Syntax

HRESULT Navigate(
    BSTR url,
    VARIANT *Flags,
    VARIANT *TargetFrameName,
    VARIANT *PostData,
    VARIANT *Headers
);

Parameters

url
[in] Required. A BSTR expression that evaluates to the URL, full path, or 
Universal Naming Convention (UNC) location and name of the resource to display.
Flags
[in] Pointer to a variable that specifies whether to add the resource to the 
history list, whether to read to or write from the cache, and whether to 
display the resource in a new window. The variable can be a combination of the 
values defined by the BrowserNavConstants enumeration. 
TargetFrameName
[in] Pointer to a string that contains the name of the frame in which to 
display the resource. The possible values for this parameter are:
_BLANK
Load the link into a new unnamed window.
_PARENT
Load the link into the immediate parent of the document the link is in.
_SELF
Load the link into the same window the link was clicked in.
_TOP
Load the link into the full body of the current window.
&lt;WINDOW_NAME&gt;
A named HTML frame. If no frame or window exists that matches the specified 
target name, a new window is opened for the specified link.
PostData
[in] Pointer to data to send with the HTTP POST transaction. For example, the 
POST transaction is used to send data gathered by an HTML form. If this 
parameter does not specify any post data, IWebBrowser2::Navigate issues an HTTP 
GET transaction. This parameter is ignored if URL is not an HTTPURL. 
Headers
[in] Pointer to a value that contains the HTTP headers to send to the server. 
These headers are added to the default Microsoft Internet Explorer headers. 
The headers can specify things such as the action required of the server, the 
type of data being passed to the server, or a status code. This parameter is 
ignored if URL is not an HTTPURL. 
Return Value

Returns one of the following values.

S_OK The operation was successful. 
E_INVALIDARG One or more parameters are invalid. 
E_OUTOFMEMORY Out of memory. 

*** Bug 17350 has been marked as a duplicate of this bug. ***
I'll let Konrad explain his experimentation with the proposed Navigate method 
(I recall there were problems), but I tested a different page that contains 
frames: http://www.msdn.microsoft.com/library and noticed identical behavior: 
things work fine until reaching the last frame, then focus goes between that 
frame the and back/forward buttons.
The workaround to call HRESULT Navigate(
    BSTR url,
    VARIANT *Flags,
    VARIANT *TargetFrameName,
    VARIANT *PostData,
    VARIANT *Headers
);
by help does not look like acceptable solution.  Some of the issues are:
1.  The name of the frame to navigate is not always known.  Help browser is not 
only used to display help frame set.  Same goes for the URL displayed within a 
frame.  URLs to load within help frames are dynamically computed by JavaScript.
2.  Calling this navigate method, will cause frame to be reloaded.  This in 
turn results in:
a)  Visible effect of page being reloaded.
b)  Audible click sound, while no navigation has been triggered by the user.
c)  All user state information within a frame to be reset, i.e. the state of 
the navigation tree, navigation page displayed will be lost.  All of help 
frames (except the topic content) have dynamic content that reloading the frame 
will reset.
3.  The above effects will also affect users not using keyboard navigation.  
Whenever user brings the help window to foreground, or restores from minimized 
state the focus is set
4.  Browser history might be affected.
We have done all we can about this issue. You need to set up your pages in a 
way that allows you to reference the content in a navigable way. We have 
described the nature of the problem and provided a possible workaround. We do 
not have time to do more than that.

(Previous comment from McQ).
Thanks Veronika. 
I think we'll have to investigate different workarounds that don't involve he 
SWT control. I will leave the bug as WNF for the time being.
I have removed the toolbar from the help browser on windows, and added the 
buttons to one of the HTML frames displayed by help.  This eliminates the 
accessibility problem for help.</WithStack>
    <WithOutStack>20020326, Win2K

When I launch the Help view, the tab key does not actually do anything. I need 
to first click on one of the "live" areas before it starts working (eg. the 
banner with the tool buttons, the nav frame or the content frame. We should be 
starting the Help view in a way that can be immediately navigated via the 
keyboard.
It also does not work when launched from F1 or search.
I will make it a P2 item, but it should probably be a P1
Our OLE control for Internet Explorer does not accept focus until it is clicked 
once.

Since the back and forward buttons are initially dissabled, there is nothing 
left in the shell to accept the focus.  If I create some controls that accept 
focus (or anable toolbar buttons), the focus traverses these controls but skips 
OLE.  Once OLE control is clicked, the focus can traverse all controls.

I will route the bug to SWT.  Could you (SWT experts) see if we need to do 
anything special, or is this SWT or IE limitation?  Please change back the 
component if this does not look like SWT bug.
&lt;rant&gt;
It is incredibly hard to debug and test changes to SWT or to your IEHost - I 
can't just modify your code and run with it because I get 
a "javax.servlet.ServletException: org.eclipse.core.boot.BootLoader " error.  
And if I make changes to SWT I guess I have to create a jar and put it in the 
plugins folder because you do not seem to pick up the changes from the 
workspace and even then, where is standard out - I was unable to verify that I 
actually ever ran my code changes.  I was in fact unable to test any changes 
with your stuff but I have been testing against a plain IE ActiveX control.  
&lt;/rant&gt;

I made one fix which helps to get focus in other activeX controls but it does 
not seem to help IE.  I have found no way to get IE to become active and take 
input except for clicking on the control.  I will continue to poke around but I 
do not have high hopes.
It should not be too bad to work with IHost (with SWT being contstant in a dll).
Standard out is written to Eclipse .log file.  There is one message per line 
and they start with "Web browser message:" followed by line that IEHost wrote 
to stdout.

javax.servlet.ServletException: org.eclipse.core.boot.BootLoader error - I have 
never seen it.  You should be able to have 0409 integration driver, load 
org.eclipse.help.ui from repository, import other plugins to your workspace and 
run help.  The error might be caused by having SWT in a workspace rather than a 
dll.  I do not know the mechanism what happens then.
If you tried self hosting help, you should also import the org.eclipse.tomcat 
into the same workspace. Basically you need to have the tomcat and help plugins 
in the same directory.
If you take the below code and overwrite the 
org.eclipse.help.ui.internal.browser.win32.IEBrowserAdapter, it will allow for 
easier debugging.  It will open an in-process shell with embedded IE, instead 
of launching IEHost class in a separate process, but still has the problem that 
this bug is about.

It should be easy to debug this now.  Make sure you have plugins
  org.eclipse.help
  org.eclipse.help.ui
  org.eclipse.help.webapp
  org.eclipse.tomcat
in your workspace.
 

/*
 * (c) Copyright IBM Corp. 2000, 2002.
 * All Rights Reserved.
 */
package org.eclipse.help.ui.internal.browser.win32;
import org.eclipse.help.internal.ui.util.HelpWorkbenchException;
import org.eclipse.help.ui.browser.IBrowser;
import org.eclipse.swt.SWT;
import org.eclipse.swt.events.*;
import org.eclipse.swt.layout.*;
import org.eclipse.swt.widgets.*;
public class IEBrowserAdapter
	implements IBrowser, ICommandStateChangedListener {
	WebBrowser webBrowser;
	ToolItem backItem, forwardItem;
	public void displayURL(String url) {
		createShell();
		webBrowser.navigate(url);
	}
	private void createShell() {
		Shell shell = new Shell();
		GridLayout layout = new GridLayout();
		layout.marginHeight = 0;
		layout.marginWidth = 0;
		layout.horizontalSpacing = 0;
		layout.verticalSpacing = 0;
		shell.setLayout(layout);
		createContents(shell);
		int w = 800;
		int h = 600;
		shell.setSize(w, h);
		shell.open();
		//shell.setVisible(true);
		shell.moveAbove(null);
	}
	private Control createContents(Composite parent) {
		Composite composite = new Composite(parent, SWT.NONE);
		GridData data = new GridData(GridData.FILL_BOTH);
		composite.setLayoutData(data);
		GridLayout layout = new GridLayout();
		layout.marginHeight = 0;
		layout.marginWidth = 0;
		layout.horizontalSpacing = 0;
		layout.verticalSpacing = 0;
		composite.setLayout(layout);
		// Add a toolbar
		ToolBar bar = new ToolBar(composite, SWT.FLAT | SWT.HORIZONTAL);
		GridData gridData = new GridData();
		gridData.horizontalAlignment = GridData.FILL;
		gridData.grabExcessHorizontalSpace = true;
		//gridData.horizontalSpan = 3;
		bar.setLayoutData(gridData);
		// Add a button to navigate back
		backItem = new ToolItem(bar, SWT.HORIZONTAL, 0);
		backItem.setText("Previous_page");
		backItem.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				webBrowser.back();
			}
			public void widgetDefaultSelected(SelectionEvent e) {
				widgetSelected(e);
			}
		});
		// Add a button to navigate forward
		forwardItem = new ToolItem(bar, SWT.NONE, 1);
		forwardItem.setText("Next_page");
		forwardItem.setHotImage(null);
		forwardItem.addSelectionListener(new SelectionListener() {
			public void widgetSelected(SelectionEvent e) {
				webBrowser.forward();
			}
			public void widgetDefaultSelected(SelectionEvent e) {
				widgetSelected(e);
			}
		});
		try {
			webBrowser = new WebBrowser(composite);
			webBrowser.addCommandStateChangedListener(this);
			webBrowser.navigate("about:blank");
		} catch (HelpWorkbenchException hwe) {
			System.err.println(hwe);
		}
		return composite;
	}
	public void commandStateChanged(boolean back, boolean forward) {
		if (backItem.getEnabled() != back)
			backItem.setEnabled(back);
		if (forwardItem.getEnabled() != forward)
			forwardItem.setEnabled(forward);
	}
	public void close() {
	}
	public boolean isCloseSupported() {
		return true;
	}
	public boolean isSetLocationSupported() {
		return true;
	}
	public boolean isSetSizeSupported() {
		return true;
	}
	public void setLocation(int x, int y) {
	}
	public void setSize(int width, int height) {
	}

}
This is critical for 13934 (P1, blocker).
Without it, help cannot be navigated with the keyboard.
I think I may have a solution for this one in hand.  The biggest problem I have 
to overcome before releasing it is that the solution seems to break Word and 
Paint which are embedded editors in Eclipse.

I may just release this as a change to OleControlSite and leave OleClientSite 
untouched.  We shall see.
I have released the fix to just the OleControlSite part.  This is in today's 
integration build (0515).
Veronika, this fixed the orginal problem but broke it in a different place:

- click Tab or Ctrl-Tab until you get focus on the toolbar that contains the 
tree icons: toggle navigation, synchronize and print (this is just above the 
main help area). Tab or Ctrl-Tab on this frame. The focus never leaveas the 
frame, or if it does, it goes to the main SWT control with back/forward buttons 
if they are enabled and comes back to the same frame.

Keybaord navigation works fine in IE (try Ctrl-N when focus is on Help view, it 
should open the browser), and also worked fine before the fix. The problem was 
only getting the initial focus inside the control.

We opened bug 16093 for it, but I will probably mark it as a dup of this bug.
The problem you are seeing is described by:

http://dev.eclipse.org/bugs/show_bug.cgi?id=5910

5910 is fixed but not in 0515 - see the HEAD stream to test it.

Everything works in IE because the place you tab to after the print button is 
the text field in the ie browser which takes focus.  In the embedded guy, the 
place you tab to is the forward/backward toolbar which has nothing but disabled 
items in it and grabs the focus erroniously.

Closing this PR and marking 16093 asa duplicate of 5910.
I am reoppenning this, as the fix caused a regression.

In this driver when back button and forward button are anabled, tab navigation 
does not work correctly.  After tabbing to toolbar frame, focuses gets to 
toolbar buttons and back to toolbar frame.  It does not move to next (first) 
frame.  I was suggested in bug 16093 that shift tab should be used.  Shift tab 
causes focus to traverse frames back but stops on the first frame without 
placing focus on toolbar.
Both tab and shift-tab should allow for getting to all the frames.  There 
should not be frames beyond which keyboard navigation does not work.

Notice that in the build, that did not contain fix for the original problem, 
once the IE area has been clicked once with the mouse, the focus could traverse 
all frames and toolbar without any dead ends.

There is something different about your web page.  I have tested this with the 
OTI internal home page and I can access all fields on the page by tabbing 
around even when tabbing in and out.

This is the behaviour of the activeX control and there is nothing I can do 
about forcing the focus to go to one frame or another on activation.

In the old driver the control was never activated/deactivated when focus 
changed.
Can you guys use the following Navigate method in which you specify the frame 
to navigate to as a workaround.  Listen for focus in and then call this method 
on the OleAutomation object to force the focus to the first frame on your page 
using TargetFrameForName :

IWebBrowser2.Navigate

Navigates to a resource identified by a URL or to the file identified by a full 
path.

Syntax

HRESULT Navigate(
    BSTR url,
    VARIANT *Flags,
    VARIANT *TargetFrameName,
    VARIANT *PostData,
    VARIANT *Headers
);

Parameters

url
[in] Required. A BSTR expression that evaluates to the URL, full path, or 
Universal Naming Convention (UNC) location and name of the resource to display.
Flags
[in] Pointer to a variable that specifies whether to add the resource to the 
history list, whether to read to or write from the cache, and whether to 
display the resource in a new window. The variable can be a combination of the 
values defined by the BrowserNavConstants enumeration. 
TargetFrameName
[in] Pointer to a string that contains the name of the frame in which to 
display the resource. The possible values for this parameter are:
_BLANK
Load the link into a new unnamed window.
_PARENT
Load the link into the immediate parent of the document the link is in.
_SELF
Load the link into the same window the link was clicked in.
_TOP
Load the link into the full body of the current window.
&lt;WINDOW_NAME&gt;
A named HTML frame. If no frame or window exists that matches the specified 
target name, a new window is opened for the specified link.
PostData
[in] Pointer to data to send with the HTTP POST transaction. For example, the 
POST transaction is used to send data gathered by an HTML form. If this 
parameter does not specify any post data, IWebBrowser2::Navigate issues an HTTP 
GET transaction. This parameter is ignored if URL is not an HTTPURL. 
Headers
[in] Pointer to a value that contains the HTTP headers to send to the server. 
These headers are added to the default Microsoft Internet Explorer headers. 
The headers can specify things such as the action required of the server, the 
type of data being passed to the server, or a status code. This parameter is 
ignored if URL is not an HTTPURL. 
Return Value

Returns one of the following values.

S_OK The operation was successful. 
E_INVALIDARG One or more parameters are invalid. 
E_OUTOFMEMORY Out of memory. 

*** Bug 17350 has been marked as a duplicate of this bug. ***
I'll let Konrad explain his experimentation with the proposed Navigate method 
(I recall there were problems), but I tested a different page that contains 
frames: http://www.msdn.microsoft.com/library and noticed identical behavior: 
things work fine until reaching the last frame, then focus goes between that 
frame the and back/forward buttons.
The workaround to call HRESULT Navigate(
    BSTR url,
    VARIANT *Flags,
    VARIANT *TargetFrameName,
    VARIANT *PostData,
    VARIANT *Headers
);
by help does not look like acceptable solution.  Some of the issues are:
1.  The name of the frame to navigate is not always known.  Help browser is not 
only used to display help frame set.  Same goes for the URL displayed within a 
frame.  URLs to load within help frames are dynamically computed by JavaScript.
2.  Calling this navigate method, will cause frame to be reloaded.  This in 
turn results in:
a)  Visible effect of page being reloaded.
b)  Audible click sound, while no navigation has been triggered by the user.
c)  All user state information within a frame to be reset, i.e. the state of 
the navigation tree, navigation page displayed will be lost.  All of help 
frames (except the topic content) have dynamic content that reloading the frame 
will reset.
3.  The above effects will also affect users not using keyboard navigation.  
Whenever user brings the help window to foreground, or restores from minimized 
state the focus is set
4.  Browser history might be affected.
We have done all we can about this issue. You need to set up your pages in a 
way that allows you to reference the content in a navigable way. We have 
described the nature of the problem and provided a possible workaround. We do 
not have time to do more than that.

(Previous comment from McQ).
Thanks Veronika. 
I think we'll have to investigate different workarounds that don't involve he 
SWT control. I will leave the bug as WNF for the time being.
I have removed the toolbar from the help browser on windows, and added the 
buttons to one of the HTML frames displayed by help.  This eliminates the 
accessibility problem for help.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12399" />
    <CreationDate amount="2002-03-27 17:16:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="1.0" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Automatically Insert method declaration if a class inherits from an interface or an abstract class.</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>I suggest if I have a class and then extends/implements an interface or an 
abstract class, eclipse will add declaration of those abstract methods in the 
class editor.
I figure out how to do that manually. 
Verified. Rightclick on Class in outline view, or use code assist.</WithStack>
    <WithOutStack>I suggest if I have a class and then extends/implements an interface or an 
abstract class, eclipse will add declaration of those abstract methods in the 
class editor.
I figure out how to do that manually. 
Verified. Rightclick on Class in outline view, or use code assist.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="12400" />
    <CreationDate amount="2002-03-27 17:54:00 -0500" />
    <DupId amount="" />
    <classification amount="Tools" />
    <Product amount="CDT" />
    <component amount="cdt-core" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>REMOTE parse with PARSE PATH(jikes)</Summery>
    <Patches amount="0" />
    <Stacktraces amount="2">
      <Stacktrace timestamp="1437330634058">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason>java.lang.NullPointerException</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.cdt.cpp.miners.managedproject.ManagedProjectMiner.handleCommand(ManagedProjectMiner.java:128)</Frame>
          <Frame depth="1">org.eclipse.cdt.dstore.core.miners.miner.Miner.command(Miner.java:175)</Frame>
          <Frame depth="2">org.eclipse.cdt.dstore.core.server.ServerCommandHandler.sendCommands(ServerCommandHandler.java:184)</Frame>
          <Frame depth="3">org.eclipse.cdt.dstore.core.model.CommandHandler.handle(CommandHandler.java(CompiledCode))</Frame>
          <Frame depth="4">org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java(CompiledCode))</Frame>
          <Frame depth="5">org.eclipse.cdt.cpp.miners.managedproject.ManagedProjectMiner.handleCommand(ManagedProjectMiner.java:128)</Frame>
          <Frame depth="6">org.eclipse.cdt.dstore.core.miners.miner.Miner.command(Miner.java:175)</Frame>
          <Frame depth="7">org.eclipse.cdt.dstore.core.server.ServerCommandHandler.sendCommands(ServerCommandHandler.java:184)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437330634058">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason>java.lang.NullPointerException</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.cdt.cpp.miners.parser.ParseMiner.handleObjectParse(ParseMiner.java:510)</Frame>
          <Frame depth="1">org.eclipse.cdt.cpp.miners.parser.ParseMiner.handleCommand(ParseMiner.java:76)</Frame>
          <Frame depth="2">org.eclipse.cdt.dstore.core.miners.miner.Miner.command(Miner.java:175)</Frame>
          <Frame depth="3">org.eclipse.cdt.dstore.core.server.ServerCommandHandler.sendCommands(ServerCommandHandler.java:184)</Frame>
          <Frame depth="4">org.eclipse.cdt.dstore.core.model.CommandHandler.handle(CommandHandler.java(CompiledCode))</Frame>
          <Frame depth="5">org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java(CompiledCode))</Frame>
          <Frame depth="6">org.eclipse.cdt.cpp.miners.parser.ParseMiner.handleObjectParse(ParseMiner.java:510)</Frame>
          <Frame depth="7">org.eclipse.cdt.cpp.miners.parser.ParseMiner.handleCommand(ParseMiner.java:76)</Frame>
          <Frame depth="8">org.eclipse.cdt.dstore.core.miners.miner.Miner.command(Miner.java:175)</Frame>
          <Frame depth="9">org.eclipse.cdt.dstore.core.server.ServerCommandHandler.sendCommands(ServerCommandHandler.java:184)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Using jikes as a remote project, specify the 'parse path'=/usr/include
Then attempt to parse it. Although in the client some functions are displayed in
the Projects Objects view, the parse will never finish in the server(CPU usage
stays close to 100% in the server). Right-click on the project(in the C++
Projects view) or Left-click on any of the functions(in the Project Objects
view) and you get a NullPointerException (in the server):
This problem happens only when jikes is REMOTE and with a PARSE PATH
----------------------------------------------------------
Server Started Successfully
4040
Server running on: hack
java.lang.NullPointerException
java.lang.NullPointerException
        at
org.eclipse.cdt.cpp.miners.managedproject.ManagedProjectMiner.handleCommand(ManagedProjectMiner.java:128)
        at
org.eclipse.cdt.dstore.core.miners.miner.Miner.command(Miner.java:175)
        at
org.eclipse.cdt.dstore.core.server.ServerCommandHandler.sendCommands(ServerCommandHandler.java:184)
        at
org.eclipse.cdt.dstore.core.model.CommandHandler.handle(CommandHandler.java(Compiled
Code))
        at org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java(Compiled
Code))
java.lang.NullPointerException
        at
org.eclipse.cdt.cpp.miners.managedproject.ManagedProjectMiner.handleCommand(ManagedProjectMiner.java:128)
        at
org.eclipse.cdt.dstore.core.miners.miner.Miner.command(Miner.java:175)
        at
org.eclipse.cdt.dstore.core.server.ServerCommandHandler.sendCommands(ServerCommandHandler.java:184)
        at
org.eclipse.cdt.dstore.core.model.CommandHandler.handle(CommandHandler.java(Compiled
Code))
        at org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java(Compiled
Code))
java.lang.NullPointerException
java.lang.NullPointerException
        at
org.eclipse.cdt.cpp.miners.parser.ParseMiner.handleObjectParse(ParseMiner.java:510)
        at
org.eclipse.cdt.cpp.miners.parser.ParseMiner.handleCommand(ParseMiner.java:76)
        at
org.eclipse.cdt.dstore.core.miners.miner.Miner.command(Miner.java:175)
        at
org.eclipse.cdt.dstore.core.server.ServerCommandHandler.sendCommands(ServerCommandHandler.java:184)
        at
org.eclipse.cdt.dstore.core.model.CommandHandler.handle(CommandHandler.java(Compiled
Code))
        at org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java(Compiled
Code))
java.lang.NullPointerException
        at
org.eclipse.cdt.cpp.miners.parser.ParseMiner.handleObjectParse(ParseMiner.java:510)
        at
org.eclipse.cdt.cpp.miners.parser.ParseMiner.handleCommand(ParseMiner.java:76)
        at
org.eclipse.cdt.dstore.core.miners.miner.Miner.command(Miner.java:175)
        at
org.eclipse.cdt.dstore.core.server.ServerCommandHandler.sendCommands(ServerCommandHandler.java:184)
        at
org.eclipse.cdt.dstore.core.model.CommandHandler.handle(CommandHandler.java(Compiled
Code))
        at org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java(Compiled
Code))
These stacks are caused by the ManagedProjectMiner and the ParseMiner getting 
commands with null subjects.  I've added checks in both the Miners to make sure 
we handle null subjects, but the real fix here is to not send such commands.  
There must be some general problem on the server-side in this scenario that is 
corrupting the commands.

As discussed, this is not all that easy to reproduce as the clicking on the 
objects have to be done at a particular time during the parse.  I'll look into 
this for R2.
Is this still reproducable?
I'll assume that this gets fixed with Jeff's parser changes.</WithStack>
    <WithOutStack>Using jikes as a remote project, specify the 'parse path'=/usr/include
Then attempt to parse it. Although in the client some functions are displayed in
the Projects Objects view, the parse will never finish in the server(CPU usage
stays close to 100% in the server). Right-click on the project(in the C++
Projects view) or Left-click on any of the functions(in the Project Objects
view) and you get a NullPointerException (in the server):
This problem happens only when jikes is REMOTE and with a PARSE PATH
----------------------------------------------------------
Server Started Successfully
4040
Server running on: hack
        at
org.eclipse.cdt.dstore.core.model.CommandHandler.handle(CommandHandler.java(Compiled
Code))
        at org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java(Compiled
Code))

        at
org.eclipse.cdt.dstore.core.model.CommandHandler.handle(CommandHandler.java(Compiled
Code))
        at org.eclipse.cdt.dstore.core.model.Handler.run(Handler.java(Compiled
Code))
These stacks are caused by the ManagedProjectMiner and the ParseMiner getting 
commands with null subjects.  I've added checks in both the Miners to make sure 
we handle null subjects, but the real fix here is to not send such commands.  
There must be some general problem on the server-side in this scenario that is 
corrupting the commands.

As discussed, this is not all that easy to reproduce as the clicking on the 
objects have to be done at a particular time during the parse.  I'll look into 
this for R2.
Is this still reproducable?
I'll assume that this gets fixed with Jeff's parser changes.</WithOutStack>
  </Bug>
</infozilla-output>

