<?xml version="1.0" encoding="UTF-8"?>
<infozilla-output>
  <Bug>
    <BugId amount="35401" />
    <CreationDate amount="2003-03-20 15:21:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Update  (deprecated - use RT&gt;Equinox&gt;p2)" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="minor" />
    <Summery>2.1 RC3; (De)Select All buttons always enabled on Optional Feature page in Install Wizard</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>On the Optional Feature page in the Install Wizard, there is buttons Select All 
and Deselect All.  I have checkboxes to select optional features in the tree 
grayed out and cannot change selection, but the buttons on the right are not 
disabled, suggesting that I can change something.  They do not do anything 
(correct), so they should be disabled.
Fixed. We now count the optional features that are selectable, and if none is, 
we disable both buttons.</WithStack>
    <WithOutStack>On the Optional Feature page in the Install Wizard, there is buttons Select All 
and Deselect All.  I have checkboxes to select optional features in the tree 
grayed out and cannot change selection, but the buttons on the right are not 
disabled, suggesting that I can change something.  They do not do anything 
(correct), so they should be disabled.
Fixed. We now count the optional features that are selectable, and if none is, 
we disable both buttons.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35402" />
    <CreationDate amount="2003-03-20 15:25:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Update  (deprecated - use RT&gt;Equinox&gt;p2)" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="major" />
    <Summery>Install manager refuses further installs if current configuration has problems</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="2">
      <Enumeration lines="8">
        <Lines>
          <Line>1) A feature cannot be installed if it requires another feature be present AND</Line>
          <Line>that feature has errors in the current configuration</Line>
          <Line>2) A new version of a feature cannot be installed if the old version is present</Line>
          <Line>and has errors in the current configuration</Line>
          <Line>3) A patch cannot be installed if the feature that it is patching has errors in</Line>
          <Line>the current configuration</Line>
          <Line>4) A feature that WOULD create errors in the configuration cannot be enabled</Line>
          <Line>5) A feature that has errors in the cofiguration CAN be disabled or uninstalled</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="17">
        <Lines>
          <Line>1. it is possible to end up with a broken configuration</Line>
          <Line>2. the update manager should be able to cope with a broken configuration</Line>
          <Line>and allow further operations if certain conditions are met</Line>
          <Line>3. ideally, if the configuration is broken, the user must be informed</Line>
          <Line>and let decide whether to continue with update mgr operations or not</Line>
          <Line>4. any update mgr operation should not introduce new broken features.</Line>
          <Line>5. a corollary of #4 is that when starting with a clean configuration,</Line>
          <Line>the result of the update manager operation should be another clean</Line>
          <Line>configuration.</Line>
          <Line>6. another corollary of #4 is that when starting with a broken</Line>
          <Line>configuration, any new operation may fix some broken features,</Line>
          <Line>or leave them in the same state.</Line>
          <Line>7. the update manager should be able to operate on a broken feature,</Line>
          <Line>including updating it, unconfiguring it, etc. As per #4, the new</Line>
          <Line>version of a feature could be broken if the old version was broken,</Line>
          <Line>but if the old feature was valid, the new one should still be</Line>
          <Line>valid (not broken).</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>This situation arises when the current feature configuration has problems. This 
can arise easily if someone manually installs a feature by some means other 
than the install manager. Interim/development drops of Eclipse-based products 
like WSAD/WSSD/WSWB ave sometimes shipped with a feature misconfiguration; they 
did not have time to correct all the dependencies among the shipped features 
(suffice it to say that this happens very often in practice). At runtime, 
everything works fine, because the plug-in dependencies are satisfied, and 
that's all the runtime seems to care about.

However, if a workbench is in this state, where there is one or more feature 
misconfiguration, the Install/Update Manager is effectively DISABLED. When 
attempting to download any new feature through the IUM, you get a dialog whose 
message reads something like (for example):


 Current configuration contains errors that are not corrected by the requested 
operation.  see details.

Details -
IBM Remote Debug (2.0.0) Feature requires plug-in "com.ibm.lpex".
com.ibm.debug.spd (1.0.0) Feature requires plug-in "com.ibm.lpex".

So, apparently, whenever you try to do an install or update, the workbench 
performs a pre-check. In this pre-check, it validates all existing features to 
ensure that your configuration is OK. This seems fine, but the way it reacts to 
a bad feature configuration is not. If it detects any problem with the current 
configuration, it stops the install/update process right there; that is, it 
will not allow you to install or update any new features until the current 
configuration is fixed.

The only way around this is to manually replace/hack into the offending 
feature.xml files.

It seems very extreme to completely and always disallow further feature 
installs/updates in this situation (when the offending feature[s] could be 
totally unrelated to what you're trying to install). What if a feature exists 
out on an update site that, if you could install it, would fix your current 
feature misconfiguration?

Better behavior would seem to be to warn the user and ask if the install/update 
should proceed anyway.
I think the current behaviour is reasonable.

We assume that Eclipse products are installed correctly and that any problems 
with the current configuration must be dealt with before you can start 
installing new features. What chance do we have to guarantee configuration 
integrity if the configuration has errors to begin with?

You say:
&lt;quote&gt;
The only way around this is to manually replace/hack into the offending 
feature.xml files.
&lt;/quote&gt;

This is not the realistic scenario Update Manager users would face. The 
assumption is that they installed a working product with a valid
configuration. We do not stop you from editing/changing plug-ins and
features on the file system manually and will react to these changes,
but we refuse to execute Update operations if we cannot claim with
reasonable probability that the attempted operation will succeed.
Starting with an invalid configuration virtually guarantees failure.

I have to disagree. Feature configurations do not guarantee runtime integrity 
anyway, they just encourage it. It is certainly very easy for someone to ship a 
full Eclipse-extending product that contains a bunch of features that have 
errors in their feature.xml files. The plugins contained in the features will 
all work just fine; the user will never know there's a problem unless they look 
at their current configuration or try to install a new feature.

And what about my point of installing a feature that *fixes* a configuration 
problem? You are saying it is acceptable to ask users to correct such a problem 
by asking them to hack into their feature.xml files? Wouldn't giving them the 
ability to download a feature fix be a much more elegant solution?

Given this, I fail to see how changing this behavior to the way I suggest will 
cause any harm. Users will still be warned, but they will be given a newer and 
better avenue for getting their configuration corrected. And I believe that 
disabling the install/update manager is extreme punishment for those, foolish 
as they may be, who have failed to ensure that all their feature.xmls are 
correct.

You say "Starting with an invalid configuration virtually guarantees failure." 
How is that, when it comes to feature configurations? Does the feature.xml data 
have any effect on the runtime behavior of a platform instance other than 
misconfiguration warnings?

I have had correspondence with Cristophe Elek about this, and he seemed to 
think it was a reasonable request.
Features DIRECTLY affect the runtime. We walk the enabled features, compute 
their plug-ins and compose the list of plug-ins and fragments to run. We pass 
this list to Eclipse boot loader. When features show errors, the fact that you 
are still running is by pure chance, not because features are optional.

Errors in features that come with products are not acceptible. A product should 
not ship with broken features. Users should not get into situation to download 
fixes for products they just installed. This is not unlike shipping with 
compile errors, corrupted DLLs or missing files. Besides, broken features are 
easy to spot - it is not something you need to debug carefully. Just install a 
product and head directly to Update Manager. A product must not have errors or 
warnings in 'Current Configuration'. 

Install/Update mission is to prevent you from corrupting your configuration 
through install, update or enable/disable operations. If we don't start from
a clean slate, all bets are off. You may think you are still running, so 
who cares, but you are mistaken. In many cases you may be running wrong
plug-in versions, or not running some plug-ins at all.
Is it not possible to contribute a product that contributes only one or more 
plugins, but no features? If you unzip a plugin into the plugins directory, and 
make no modifications or additions in your features directory, is the plugin 
not available at runtime? Boot-loading through features isn't the be-all and 
end-all.

Aside from that, why would all bets be off if some third-party feature is 
misconfigured? If feature X is misconfigured and I am trying to install feature 
Y, and Y has no dependencies on X, why categorically disallow the install of Y?
It is true that 'orphaned' plug-ins (those not listed in any features) are 
still passed to the boot loader. However, this is done to allow experimentation 
and to allow Eclipse to start even with orphaned plug-ins. It does not mean 
that we recommend this to products.

What I am trying to communicate here is that you should never be with a broken 
configuration to begin with. If you download Eclipse SDK, the configuration is 
clean. If you install a commercial Eclipse-based product, it is clean. So we 
assume that product teams have tested their products and that they shipped them 
with the correct initial configuration.

After that, Update Manager will ensure to not allow you to install features 
that will invalidate the current configuration. If you start with a clean
product, the only way to end up with a broken configuration is if you
manually install that feature (unzip) into an existing Eclipse product.
Update Manager will not allow you to install it through it, and (tested)
native installers should also not install broken additions into
your product. 

If you hack into an clean Eclipse product and add a broken feature
manually, we will do our best to be able to start, but we refuse
to offer further update/install services because we cannot use 
a broken configuration as a reliable 'before' state we can use to
extrapolate the 'after' state. 

Relationships between features can be complex: features can require 
other features, they can include them, they can be patches to
specific versions of other features. We don't want to go into
the shady area of estimating the impact of errors and try to
work around them. 

This is also related to service and support. You will not be able
to receive service and support for your install/update problems from
any commercial product team if you have installed broken third party
software into the main product.

I am sure Eclipse community will have something to say on this topic,
so I will post the defect URL on platform-update-dev.
Most installs are done by unzipping into the Eclipse directory. So if it's 
possible that a broken configuration can be created that way and it won't be 
noticed until much later that's a problem. Is it possible to notice the broken 
install earlier and allow it to be backed out / disabled?
The issue here is not the install technique. We can cope with features that 
suddently appear on the file system. But we do require that they are correct 
i.e. without errors. When native installers lay down files during commercial 
product install, it is the same as the unzip as far as we are concerned. In 
both cases we will run the reconciler and try to bring the file system state in 
sync with our internal state.

We will not configure the newly found features automatically. You will be 
presented with a dialog informing you about them and you can accept them if you 
want. If there are errors in features, we will not allow you to accept them.

The only problem we cannot cope with is when your product has a broken 
configuration from day 1. I think it is reasonable to expect that Eclipse 
product providers have clean configuration for their newly installed product.
From a product ie WSAD perspective. Random thoughts.

Your product should ship with a clean set of features at the end of the day. If
people are taking interim drivers they are on their own. Use a GA version if you
need stability.

If a user pops in a plugin into the wsad tree and is having problems the first
thing support will say is disable or remove all non-wsad plugins/features.
Anything eclipse can do to make this easier like being able to specify a user
plugin direcory (i think there is already another bug opened for this). Or make
it easier to partition it out. 

There is 1 situtation coming up where the misconfiguration is going to be valid
and a problem. In 2.1 both Motif and GTK are supported. So it is likely
eventually that WSAD will pick both up. What WSAD will want to do is to install
both at the same time in the same directory. Currently on windows if a
linux/motif plugin exists the configuration is invalid. I believe but haven't
verified that having both GTK and Motif features will cause misconfiguration
errors. That would have to be fixed.

An advanced user option to disable the checking would be ok, I wouldn't tell
anyone about it though and a product should be able to disable it in some way. 



In theory, it is possible to implement less strict mechanism for plain Eclipse 
users and more restrictive one for product users. A simple (non-visual) 
preference that products can flip via product customizations can turn the 
strict mode on.

Another solution could be pluggable policy (only one can exist per product) 
where products can be able to veto or verify operations that are normally 
allowed (in a default policy implementation). Just to be clear, neither 
interface nor extension point do not exist yet - I am simply dispensing random 
thoughts for our 2.2 work :-).
From a practical viewpoint, a semi-hidden solution like that sounds like it 
would satisfy my needs. I have gotten into real-world situations where this 
problem arises, and some solution that I can give users that doesn't involve a 
prolonged search through their feature.xml files would be more than welcome.

But at a higher level, I still am not sure that I agree with the overall 
philosophy I am hearing of, "if any feature is misconfigured, your whole 
workbench setup is assumed to be useless". If that is true, why allow a 
workbench with misconfigured features to be launched at all? Is that really 
reasonable if there is one misconfigured feature, which provides nice but non-
critical functionality? If that sounds unreasonable, why then disallow 
installs/updates of properly-configured features that have no dependency on 
anything referred to in the misconfigured feature? Especially if one of the 
properly-configured features you could install would be an update to the 
misconfigured feature, and getting that update would resolve the 
misconfiguration?
As I said before, it is possible to assume error-tolerant posture and try to 
work around 'rogue' features and only allow update operations on clean ones. So 
far, we made a decision that trying to be clever is dangerous.

To answer your second question, historically Eclipse had only plug-ins. 
Therefore, its lowest laywers know only about plug-ins. It is possible to have 
only plug-ins and still boot without problems. Features came later and they add 
level of control and granularity that is more aligned with units of useful 
functionality. In addition, plug-ins are not designed to handle packaging and 
installation issues like license, copyright, physical installation, updates, 
digital signatures etc. etc. Therefore, even though for historic reasons it is 
still possible to launch with plug-ins only, it is practically impossible to 
ship a complete, professional product without features.
So what is the resolution on this bug?
I would vote for allowing the user to select whether or not to continue 
installing when the configuration contains errors.
I would relax the restriction to allow installation after user explicitly 
confirms that he/she wants to do so (using a warning dialog with Yes/No 
buttons), BUT only if the feature in question has no references to the already 
installed feature that has errors. Here are some rough rules (you can 
revise/expand this table):

1) A feature cannot be installed if it requires another feature be present AND 
that feature has errors in the current configuration
2) A new version of a feature cannot be installed if the old version is present 
and has errors in the current configuration
3) A patch cannot be installed if the feature that it is patching has errors in 
the current configuration
4) A feature that WOULD create errors in the configuration cannot be enabled
5) A feature that has errors in the cofiguration CAN be disabled or uninstalled

This set of rules would resolve this particular and other similar problems. The 
focus is on allowing cleanly configured features to be available for 
manipulation if unrelated installed root features are misbehaving.


I would like to see something done by M4, so I'd like to summarize what I 
gathered from all the comments and add a couple of suggestions:

1. it is possible to end up with a broken configuration 
2. the update manager should be able to cope with a broken configuration 
   and allow further operations if certain conditions are met
3. ideally, if the configuration is broken, the user must be informed 
   and let decide whether to continue with update mgr operations or not
4. any update mgr operation should not introduce new broken features. 
5. a corollary of #4 is that when starting with a clean configuration, 
   the result of the update manager operation should be another clean 
   configuration.
6. another corollary of #4 is that when starting with a broken 
   configuration, any new operation may fix some broken features, 
   or leave them in the same state.
7. the update manager should be able to operate on a broken feature,
   including updating it, unconfiguring it, etc. As per #4, the new
   version of a feature could be broken if the old version was broken,
   but if the old feature was valid, the new one should still be 
   valid (not broken).

Note: some of these rules conflict with some of the rules in comment #13.

The new operations API provided by the update manager could be used to changed 
some behavior and define what it means to be a valid or broken feature. 
Currently, the validator is defined by the IOperationValidator, with a default 
impl defined by OperationValidator.
One can get the validator calling OperationsManager.getValidator(), which 
returns the default validator if nothing has been set, or whatever has been 
set by the OperationsManager.setValidator(). 
Obviously, this mechanism can be improved, but at least it's starting point 
for defining a custom validation policy.

Note that the current validator does not implement any of the above rules and 
there is no mechanism to allow the user to say go/no go for operations on a 
broken configuration.
I released code changes that allow operations on a broken configuration as 
long as 
1. the user confirms it
2. no new broken features are introduced

So, if you have a broken feature, you should be able to install an update or 
to disable it.</WithStack>
    <WithOutStack>This situation arises when the current feature configuration has problems. This 
can arise easily if someone manually installs a feature by some means other 
than the install manager. Interim/development drops of Eclipse-based products 
like WSAD/WSSD/WSWB ave sometimes shipped with a feature misconfiguration; they 
did not have time to correct all the dependencies among the shipped features 
(suffice it to say that this happens very often in practice). At runtime, 
everything works fine, because the plug-in dependencies are satisfied, and 
that's all the runtime seems to care about.

However, if a workbench is in this state, where there is one or more feature 
misconfiguration, the Install/Update Manager is effectively DISABLED. When 
attempting to download any new feature through the IUM, you get a dialog whose 
message reads something like (for example):


 Current configuration contains errors that are not corrected by the requested 
operation.  see details.

Details -
IBM Remote Debug (2.0.0) Feature requires plug-in "com.ibm.lpex".
com.ibm.debug.spd (1.0.0) Feature requires plug-in "com.ibm.lpex".

So, apparently, whenever you try to do an install or update, the workbench 
performs a pre-check. In this pre-check, it validates all existing features to 
ensure that your configuration is OK. This seems fine, but the way it reacts to 
a bad feature configuration is not. If it detects any problem with the current 
configuration, it stops the install/update process right there; that is, it 
will not allow you to install or update any new features until the current 
configuration is fixed.

The only way around this is to manually replace/hack into the offending 
feature.xml files.

It seems very extreme to completely and always disallow further feature 
installs/updates in this situation (when the offending feature[s] could be 
totally unrelated to what you're trying to install). What if a feature exists 
out on an update site that, if you could install it, would fix your current 
feature misconfiguration?

Better behavior would seem to be to warn the user and ask if the install/update 
should proceed anyway.
I think the current behaviour is reasonable.

We assume that Eclipse products are installed correctly and that any problems 
with the current configuration must be dealt with before you can start 
installing new features. What chance do we have to guarantee configuration 
integrity if the configuration has errors to begin with?

You say:
&lt;quote&gt;
The only way around this is to manually replace/hack into the offending 
feature.xml files.
&lt;/quote&gt;

This is not the realistic scenario Update Manager users would face. The 
assumption is that they installed a working product with a valid
configuration. We do not stop you from editing/changing plug-ins and
features on the file system manually and will react to these changes,
but we refuse to execute Update operations if we cannot claim with
reasonable probability that the attempted operation will succeed.
Starting with an invalid configuration virtually guarantees failure.

I have to disagree. Feature configurations do not guarantee runtime integrity 
anyway, they just encourage it. It is certainly very easy for someone to ship a 
full Eclipse-extending product that contains a bunch of features that have 
errors in their feature.xml files. The plugins contained in the features will 
all work just fine; the user will never know there's a problem unless they look 
at their current configuration or try to install a new feature.

And what about my point of installing a feature that *fixes* a configuration 
problem? You are saying it is acceptable to ask users to correct such a problem 
by asking them to hack into their feature.xml files? Wouldn't giving them the 
ability to download a feature fix be a much more elegant solution?

Given this, I fail to see how changing this behavior to the way I suggest will 
cause any harm. Users will still be warned, but they will be given a newer and 
better avenue for getting their configuration corrected. And I believe that 
disabling the install/update manager is extreme punishment for those, foolish 
as they may be, who have failed to ensure that all their feature.xmls are 
correct.

You say "Starting with an invalid configuration virtually guarantees failure." 
How is that, when it comes to feature configurations? Does the feature.xml data 
have any effect on the runtime behavior of a platform instance other than 
misconfiguration warnings?

I have had correspondence with Cristophe Elek about this, and he seemed to 
think it was a reasonable request.
Features DIRECTLY affect the runtime. We walk the enabled features, compute 
their plug-ins and compose the list of plug-ins and fragments to run. We pass 
this list to Eclipse boot loader. When features show errors, the fact that you 
are still running is by pure chance, not because features are optional.

Errors in features that come with products are not acceptible. A product should 
not ship with broken features. Users should not get into situation to download 
fixes for products they just installed. This is not unlike shipping with 
compile errors, corrupted DLLs or missing files. Besides, broken features are 
easy to spot - it is not something you need to debug carefully. Just install a 
product and head directly to Update Manager. A product must not have errors or 
warnings in 'Current Configuration'. 

Install/Update mission is to prevent you from corrupting your configuration 
through install, update or enable/disable operations. If we don't start from
a clean slate, all bets are off. You may think you are still running, so 
who cares, but you are mistaken. In many cases you may be running wrong
plug-in versions, or not running some plug-ins at all.
Is it not possible to contribute a product that contributes only one or more 
plugins, but no features? If you unzip a plugin into the plugins directory, and 
make no modifications or additions in your features directory, is the plugin 
not available at runtime? Boot-loading through features isn't the be-all and 
end-all.

Aside from that, why would all bets be off if some third-party feature is 
misconfigured? If feature X is misconfigured and I am trying to install feature 
Y, and Y has no dependencies on X, why categorically disallow the install of Y?
It is true that 'orphaned' plug-ins (those not listed in any features) are 
still passed to the boot loader. However, this is done to allow experimentation 
and to allow Eclipse to start even with orphaned plug-ins. It does not mean 
that we recommend this to products.

What I am trying to communicate here is that you should never be with a broken 
configuration to begin with. If you download Eclipse SDK, the configuration is 
clean. If you install a commercial Eclipse-based product, it is clean. So we 
assume that product teams have tested their products and that they shipped them 
with the correct initial configuration.

After that, Update Manager will ensure to not allow you to install features 
that will invalidate the current configuration. If you start with a clean
product, the only way to end up with a broken configuration is if you
manually install that feature (unzip) into an existing Eclipse product.
Update Manager will not allow you to install it through it, and (tested)
native installers should also not install broken additions into
your product. 

If you hack into an clean Eclipse product and add a broken feature
manually, we will do our best to be able to start, but we refuse
to offer further update/install services because we cannot use 
a broken configuration as a reliable 'before' state we can use to
extrapolate the 'after' state. 

Relationships between features can be complex: features can require 
other features, they can include them, they can be patches to
specific versions of other features. We don't want to go into
the shady area of estimating the impact of errors and try to
work around them. 

This is also related to service and support. You will not be able
to receive service and support for your install/update problems from
any commercial product team if you have installed broken third party
software into the main product.

I am sure Eclipse community will have something to say on this topic,
so I will post the defect URL on platform-update-dev.
Most installs are done by unzipping into the Eclipse directory. So if it's 
possible that a broken configuration can be created that way and it won't be 
noticed until much later that's a problem. Is it possible to notice the broken 
install earlier and allow it to be backed out / disabled?
The issue here is not the install technique. We can cope with features that 
suddently appear on the file system. But we do require that they are correct 
i.e. without errors. When native installers lay down files during commercial 
product install, it is the same as the unzip as far as we are concerned. In 
both cases we will run the reconciler and try to bring the file system state in 
sync with our internal state.

We will not configure the newly found features automatically. You will be 
presented with a dialog informing you about them and you can accept them if you 
want. If there are errors in features, we will not allow you to accept them.

The only problem we cannot cope with is when your product has a broken 
configuration from day 1. I think it is reasonable to expect that Eclipse 
product providers have clean configuration for their newly installed product.
From a product ie WSAD perspective. Random thoughts.

Your product should ship with a clean set of features at the end of the day. If
people are taking interim drivers they are on their own. Use a GA version if you
need stability.

If a user pops in a plugin into the wsad tree and is having problems the first
thing support will say is disable or remove all non-wsad plugins/features.
Anything eclipse can do to make this easier like being able to specify a user
plugin direcory (i think there is already another bug opened for this). Or make
it easier to partition it out. 

There is 1 situtation coming up where the misconfiguration is going to be valid
and a problem. In 2.1 both Motif and GTK are supported. So it is likely
eventually that WSAD will pick both up. What WSAD will want to do is to install
both at the same time in the same directory. Currently on windows if a
linux/motif plugin exists the configuration is invalid. I believe but haven't
verified that having both GTK and Motif features will cause misconfiguration
errors. That would have to be fixed.

An advanced user option to disable the checking would be ok, I wouldn't tell
anyone about it though and a product should be able to disable it in some way. 



In theory, it is possible to implement less strict mechanism for plain Eclipse 
users and more restrictive one for product users. A simple (non-visual) 
preference that products can flip via product customizations can turn the 
strict mode on.

Another solution could be pluggable policy (only one can exist per product) 
where products can be able to veto or verify operations that are normally 
allowed (in a default policy implementation). Just to be clear, neither 
interface nor extension point do not exist yet - I am simply dispensing random 
thoughts for our 2.2 work :-).
From a practical viewpoint, a semi-hidden solution like that sounds like it 
would satisfy my needs. I have gotten into real-world situations where this 
problem arises, and some solution that I can give users that doesn't involve a 
prolonged search through their feature.xml files would be more than welcome.

But at a higher level, I still am not sure that I agree with the overall 
philosophy I am hearing of, "if any feature is misconfigured, your whole 
workbench setup is assumed to be useless". If that is true, why allow a 
workbench with misconfigured features to be launched at all? Is that really 
reasonable if there is one misconfigured feature, which provides nice but non-
critical functionality? If that sounds unreasonable, why then disallow 
installs/updates of properly-configured features that have no dependency on 
anything referred to in the misconfigured feature? Especially if one of the 
properly-configured features you could install would be an update to the 
misconfigured feature, and getting that update would resolve the 
misconfiguration?
As I said before, it is possible to assume error-tolerant posture and try to 
work around 'rogue' features and only allow update operations on clean ones. So 
far, we made a decision that trying to be clever is dangerous.

To answer your second question, historically Eclipse had only plug-ins. 
Therefore, its lowest laywers know only about plug-ins. It is possible to have 
only plug-ins and still boot without problems. Features came later and they add 
level of control and granularity that is more aligned with units of useful 
functionality. In addition, plug-ins are not designed to handle packaging and 
installation issues like license, copyright, physical installation, updates, 
digital signatures etc. etc. Therefore, even though for historic reasons it is 
still possible to launch with plug-ins only, it is practically impossible to 
ship a complete, professional product without features.
So what is the resolution on this bug?
I would vote for allowing the user to select whether or not to continue 
installing when the configuration contains errors.
I would relax the restriction to allow installation after user explicitly 
confirms that he/she wants to do so (using a warning dialog with Yes/No 
buttons), BUT only if the feature in question has no references to the already 
installed feature that has errors. Here are some rough rules (you can 
revise/expand this table):

1) A feature cannot be installed if it requires another feature be present AND 
that feature has errors in the current configuration
2) A new version of a feature cannot be installed if the old version is present 
and has errors in the current configuration
3) A patch cannot be installed if the feature that it is patching has errors in 
the current configuration
4) A feature that WOULD create errors in the configuration cannot be enabled
5) A feature that has errors in the cofiguration CAN be disabled or uninstalled

This set of rules would resolve this particular and other similar problems. The 
focus is on allowing cleanly configured features to be available for 
manipulation if unrelated installed root features are misbehaving.


I would like to see something done by M4, so I'd like to summarize what I 
gathered from all the comments and add a couple of suggestions:

1. it is possible to end up with a broken configuration 
2. the update manager should be able to cope with a broken configuration 
   and allow further operations if certain conditions are met
3. ideally, if the configuration is broken, the user must be informed 
   and let decide whether to continue with update mgr operations or not
4. any update mgr operation should not introduce new broken features. 
5. a corollary of #4 is that when starting with a clean configuration, 
   the result of the update manager operation should be another clean 
   configuration.
6. another corollary of #4 is that when starting with a broken 
   configuration, any new operation may fix some broken features, 
   or leave them in the same state.
7. the update manager should be able to operate on a broken feature,
   including updating it, unconfiguring it, etc. As per #4, the new
   version of a feature could be broken if the old version was broken,
   but if the old feature was valid, the new one should still be 
   valid (not broken).

Note: some of these rules conflict with some of the rules in comment #13.

The new operations API provided by the update manager could be used to changed 
some behavior and define what it means to be a valid or broken feature. 
Currently, the validator is defined by the IOperationValidator, with a default 
impl defined by OperationValidator.
One can get the validator calling OperationsManager.getValidator(), which 
returns the default validator if nothing has been set, or whatever has been 
set by the OperationsManager.setValidator(). 
Obviously, this mechanism can be improved, but at least it's starting point 
for defining a custom validation policy.

Note that the current validator does not implement any of the above rules and 
there is no mechanism to allow the user to say go/no go for operations on a 
broken configuration.
I released code changes that allow operations on a broken configuration as 
long as 
1. the user confirms it
2. no new broken features are introduced

So, if you have a broken feature, you should be able to install an update or 
to disable it.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35403" />
    <CreationDate amount="2003-03-20 15:38:00 -0500" />
    <DupId amount="22398" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Debug" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Organize launch configurations</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>I'm finding that I have more and more launch configurations. It would be nice 
if we could group them into folders so I could collapse these in the launch 
config window.
Deferred. We are looking for a solution to this problem (we experimented with 
working sets, but decided against it).
Invesitgate LC scalibility isssues for 3.0


*** This bug has been marked as a duplicate of 22398 ***</WithStack>
    <WithOutStack>I'm finding that I have more and more launch configurations. It would be nice 
if we could group them into folders so I could collapse these in the launch 
config window.
Deferred. We are looking for a solution to this problem (we experimented with 
working sets, but decided against it).
Invesitgate LC scalibility isssues for 3.0


*** This bug has been marked as a duplicate of 22398 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35404" />
    <CreationDate amount="2003-03-20 15:38:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>[Contributions] state: Can't programmatically set initial checked state</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="2">
      <Enumeration lines="11">
        <Lines>
          <Line>1) There seems to be no way to make my action manifest itself as a</Line>
          <Line>checkbox-menu-item without specifying a "state" attribute. I tried</Line>
          <Line>overriding the Action's getStyle() method, but it never gets called.</Line>
          <Line />
          <Line>2) When I do provide a "state" attribute ("true" or "false"), that is</Line>
          <Line>how the menu item's check shows up. Any calls to Action.setChecked()</Line>
          <Line>that I insert, for example, in delegate's constructor, or in the</Line>
          <Line>constructor of my Action, have no effect. So, for example, if I insert</Line>
          <Line>'state="false"' in my plugin.xml, no call to Action.setChecked(true)</Line>
          <Line>will cause the menu item to be displayed as checked the first time it is</Line>
          <Line>shown.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="5">
        <Lines>
          <Line>- User starts up Eclipse first time</Line>
          <Line>- Turns on your toggle action, which causes your delegate (&amp; plug-in) to load</Line>
          <Line>- Your delegate launches the background process</Line>
          <Line>- User exits Eclipse</Line>
          <Line>- User restarts Eclipse</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="ASSIGNED" />
    <resolution amount="" />
    <WithStack>I'm trying to do something that I thought would be simple, but it
doesn't seem to be. I have an org.eclipse.ui.actionSets extension that I
want to be manifested as a checkbox-menu-item. To do this, apparently, I
have to add a "true" or "false" value to the state attribute of the
action element in my plugin.xml.

However, I really want to be able to control, *dynamically*, whether or
not the menu item is checked when it's first shown. That is, I have a
persisted property that tells me whether or not the checkbox was checked
when the workbench was last shut down, and I want to restore the menu
item to that state.

IWorkbenchWindowActionDelegate does not give the ability to
do this - I don't get a reference to the IAction object until the menu
item actually is selected.

Some notes I took while trying to find a workaround (never did find one) with 
IWorkbenchWindowPulldownDelegate2:

1) There seems to be no way to make my action manifest itself as a
checkbox-menu-item without specifying a "state" attribute. I tried
overriding the Action's getStyle() method, but it never gets called.

2) When I do provide a "state" attribute ("true" or "false"), that is
how the menu item's check shows up. Any calls to Action.setChecked()
that I insert, for example, in delegate's constructor, or in the
constructor of my Action, have no effect. So, for example, if I insert
'state="false"' in my plugin.xml, no call to Action.setChecked(true)
will cause the menu item to be displayed as checked the first time it is
shown.

Perhaps the 'state' attribute should be able to take a 3rd value in addition 
to 'true' and 'false' that indicates that the initial state will be under 
programmatic control. Or maybe it's OK with the 2 that exist, but there should 
exist some way to programmatically override the value given in the plugin 
descriptor.

See the 'Initial selection of an actionSet' thread (~3/5/03) in the 
eclipse.tools newsgroup for more details, and some context on the workarounds I 
attempted.
It's possible that your action delegate class has not yet been loaded.  They 
are lazily loaded when the action is first run.  Action delegates are also 
loaded when the plugin that contributes them is activated.

If that's not the case, try implementing IActionDelegate2, in addition to 
IWorkbenchWindowActionDelegate.  

You mentioned IWorkbenchWindowPulldownDelegate2.  That is not the interface to 
use for check box actions, but pulldowns also support IActionDelegate2.

Can you also provide a simple test plugin to show up this problem. In your 
point #2 above, you say "in delegate's constructor, or in the constructor of my 
Action, have no effect". What do you mean by "in the constructor of my Action"? 
You only need to provide an action delegate.
That's a reference to my failed attempt to use 
IWorkbenchWindowPulldownDelegate2, as was suggested to me on the newsgroup (the 
sample code that served as my basis for that attempt is posted in that thread).

I'll have to try Nick's suggestion of using IActionDelegate2.
As I feared when I saw that it was yet another delegate, implementing 
IActionDelegate2 does not help. The delegate, following the pattern of all the 
delegates, is not even constructed until the menu item is actually selected, so 
I have no Action to which I can programmatically set a checked state.

The IWorkbenchWindowPulldownDelegate2 still seems like the closest I have 
gotten. Using that delegate, I construct my own MenuItem and Action. But, as I 
mentioned, that action does not respond to my attempts to set its initial state.
Before your delegate is loaded, the initial state of the toggle menu item is 
control by the value of the state attribute in the plugin.xml file. There is no 
support nor API to set the initial toggle state via other means. Going the 
IWorkbenchPulldownDelegate route will not work.

Can you describe your use case for this? Having a "real world" example would 
help us understand what support we could add to help with this. If there was a 
mechanism via the plugin.xml to specify the state depends on some persisted 
property, would that be sufficient? Or would the delegate need to be loaded 
when the action is initially set to true or false?
The use case is: I have a checkbox menu item actionSet contribution. A 
persistent property keeps track of the last checked state of the menu item. On 
workbench startup, I wish to restore the menu item's checked state to the state 
it had when the workbench was last shut down.

So the answer to your question, "If there was a 
mechanism via the plugin.xml to specify the state depends on some persisted 
property, would that be sufficient?" is yes!


Just to clarify one more thing... And it would be ok that the delegate may not 
be loaded at the time? Lets look at two "types" of toggle actions.

1 - The toggle action represent only a state which is used by other actions. 
For example, say there was a toggle action "Verbose". Turning it on/off did not 
cause anything to happen. But when the action "Package for runtime" was called, 
it checked the state of the "Verbose" action and wrote more things to the 
console if on.

2 - The toggle action represents a running process. For example, say there was 
a toggle action "New item alert". Turning it on caused a background process to 
run looking for new items and notifying the user when found. Turning it off, no 
background process would be running.

So in case 1, the workbench could set the initial state of the toggle button 
from a persisted property (or better yet, could just remember it betwee 
shutdown/startup of Eclipse). It would not matter whether the delegate it 
loaded or not.

But in case 2, the delegate would need to be loaded if the state was set to 
true, otherwise, the background process would not be running as expected by the 
user.

For your action, which type would best describe it - 1 or 2? Or is there 
another type?

Sorry for all the questions. We just want to fully understand as many of the 
use cases for this so we can determine what solution would be best and still 
only load plugins as late as possible.
Your scenario #2 really describes what I am trying to do, but I don't think the 
solution you propose for #1 would still be sufficient. 

My plug-in has a subsystem that must be launched if my persistent property is 
set to true. However, I must launch that subsystem on a background thread at 
the time my plug-in starts up. The startup wouldn't wait for the first time the 
menu item is shown.

In general, I think the checked state of the menu item would reflect a state of 
affairs that is independent of whether the user has looked at the menu item 
yet, and therefore, up-front construction of the delegate wouldn't be necessary.

I am assuming that you are talking about constructing the delegate when the 
menu item is shown. I may be misunderstanding, and you may be talking about 
constructing the delegate on plug-in startup. That would perhaps make for 
cleaner code, as I can simply detect the state change in the menu item on 
startup and start my subsystem as needed, in lieu of having an independent read 
of the persistent property. But there are good reasons for not going down that 
route: 1) it probably would have a negative impact on workbench startup time. 
2) (this is just a more obscure gut feeling I have, and I apologize if it 
doesn't make much sense) i don't think it wouldn't encourage good (MVC) design 
on the part of the coder contributing to the actionSet, as the menu item itself 
would somehow become a mix of all three MVC elements.

Of course, there may be other users out there who could come up with a 
different scenario. Perhaps they would want to perform some calculation to 
determine the initial checked state. How would you design for that? Sounds like 
you would need to ask users to supply in their extension a class that handles 
this, and you would have to check a method in that class (which will of course 
implement some interface you supplied) to establish the state. This is not what 
I am asking for, but I guess I could see the scenario arise.
Sorry Simon, typed too fast. In the second sentence of my previous comments, I 
of course meant to say "I *do* think the solution you propose for #1 would 
still be sufficient."

So you would be ok with the following scenario...
- User starts up Eclipse first time
- Turns on your toggle action, which causes your delegate (&amp; plug-in) to load
- Your delegate launches the background process
- User exits Eclipse
- User restarts Eclipse

Now at this point, lets assume the workbench was able to remember your action 
being in the "on" toggle state and restores it that way. Lets also assume that 
your plugin was not started (workbench lazy loads a plug-in - that is only when 
the user does something that requires that plug-in's code, like running an 
action, showing a view/editor, etc).

So your action would be in the "on" toggle state, but yet no background process 
would be running since your delegate is not loaded because your plugin is not 
loaded. Is that acceptable? Or would you require that if the action is restored 
in the "on" toggle state, that the delegate be loaded (and therefore the plug-
in also), and call "run" on the delegate?
In my particular case, I need to force plug-in load at startup anyway, so I 
take the extreme but necessary step of extending org.eclipse.ui startup. So 
your first proposal would be acceptable to me.

But I can anticipate someone wanting the behavior in your second proposal. In 
fact, I referred someone from the eclipse.tools newsgroup to this bug; he may 
have a different opinion on this (see today's post by Christian Lemer).
Our problem may be related but could be solved (maybe) in another way. Our problem is also related to the access to the IAction, but we were able to solve the initial status with the XML rules.Our problem is that the status could only be modified during the run or the selectionChanged. Unfortunately, in our case, the connection status could be changed in other situations... Should we fire a fake selectionChanged in some way?
Reassigning to Platform-UI-Inbox (I left IBM 18 months ago..)
Moving Dougs bugs
Assigning to component owner
PW</WithStack>
    <WithOutStack>I'm trying to do something that I thought would be simple, but it
doesn't seem to be. I have an org.eclipse.ui.actionSets extension that I
want to be manifested as a checkbox-menu-item. To do this, apparently, I
have to add a "true" or "false" value to the state attribute of the
action element in my plugin.xml.

However, I really want to be able to control, *dynamically*, whether or
not the menu item is checked when it's first shown. That is, I have a
persisted property that tells me whether or not the checkbox was checked
when the workbench was last shut down, and I want to restore the menu
item to that state.

IWorkbenchWindowActionDelegate does not give the ability to
do this - I don't get a reference to the IAction object until the menu
item actually is selected.

Some notes I took while trying to find a workaround (never did find one) with 
IWorkbenchWindowPulldownDelegate2:

1) There seems to be no way to make my action manifest itself as a
checkbox-menu-item without specifying a "state" attribute. I tried
overriding the Action's getStyle() method, but it never gets called.

2) When I do provide a "state" attribute ("true" or "false"), that is
how the menu item's check shows up. Any calls to Action.setChecked()
that I insert, for example, in delegate's constructor, or in the
constructor of my Action, have no effect. So, for example, if I insert
'state="false"' in my plugin.xml, no call to Action.setChecked(true)
will cause the menu item to be displayed as checked the first time it is
shown.

Perhaps the 'state' attribute should be able to take a 3rd value in addition 
to 'true' and 'false' that indicates that the initial state will be under 
programmatic control. Or maybe it's OK with the 2 that exist, but there should 
exist some way to programmatically override the value given in the plugin 
descriptor.

See the 'Initial selection of an actionSet' thread (~3/5/03) in the 
eclipse.tools newsgroup for more details, and some context on the workarounds I 
attempted.
It's possible that your action delegate class has not yet been loaded.  They 
are lazily loaded when the action is first run.  Action delegates are also 
loaded when the plugin that contributes them is activated.

If that's not the case, try implementing IActionDelegate2, in addition to 
IWorkbenchWindowActionDelegate.  

You mentioned IWorkbenchWindowPulldownDelegate2.  That is not the interface to 
use for check box actions, but pulldowns also support IActionDelegate2.

Can you also provide a simple test plugin to show up this problem. In your 
point #2 above, you say "in delegate's constructor, or in the constructor of my 
Action, have no effect". What do you mean by "in the constructor of my Action"? 
You only need to provide an action delegate.
That's a reference to my failed attempt to use 
IWorkbenchWindowPulldownDelegate2, as was suggested to me on the newsgroup (the 
sample code that served as my basis for that attempt is posted in that thread).

I'll have to try Nick's suggestion of using IActionDelegate2.
As I feared when I saw that it was yet another delegate, implementing 
IActionDelegate2 does not help. The delegate, following the pattern of all the 
delegates, is not even constructed until the menu item is actually selected, so 
I have no Action to which I can programmatically set a checked state.

The IWorkbenchWindowPulldownDelegate2 still seems like the closest I have 
gotten. Using that delegate, I construct my own MenuItem and Action. But, as I 
mentioned, that action does not respond to my attempts to set its initial state.
Before your delegate is loaded, the initial state of the toggle menu item is 
control by the value of the state attribute in the plugin.xml file. There is no 
support nor API to set the initial toggle state via other means. Going the 
IWorkbenchPulldownDelegate route will not work.

Can you describe your use case for this? Having a "real world" example would 
help us understand what support we could add to help with this. If there was a 
mechanism via the plugin.xml to specify the state depends on some persisted 
property, would that be sufficient? Or would the delegate need to be loaded 
when the action is initially set to true or false?
The use case is: I have a checkbox menu item actionSet contribution. A 
persistent property keeps track of the last checked state of the menu item. On 
workbench startup, I wish to restore the menu item's checked state to the state 
it had when the workbench was last shut down.

So the answer to your question, "If there was a 
mechanism via the plugin.xml to specify the state depends on some persisted 
property, would that be sufficient?" is yes!


Just to clarify one more thing... And it would be ok that the delegate may not 
be loaded at the time? Lets look at two "types" of toggle actions.

1 - The toggle action represent only a state which is used by other actions. 
For example, say there was a toggle action "Verbose". Turning it on/off did not 
cause anything to happen. But when the action "Package for runtime" was called, 
it checked the state of the "Verbose" action and wrote more things to the 
console if on.

2 - The toggle action represents a running process. For example, say there was 
a toggle action "New item alert". Turning it on caused a background process to 
run looking for new items and notifying the user when found. Turning it off, no 
background process would be running.

So in case 1, the workbench could set the initial state of the toggle button 
from a persisted property (or better yet, could just remember it betwee 
shutdown/startup of Eclipse). It would not matter whether the delegate it 
loaded or not.

But in case 2, the delegate would need to be loaded if the state was set to 
true, otherwise, the background process would not be running as expected by the 
user.

For your action, which type would best describe it - 1 or 2? Or is there 
another type?

Sorry for all the questions. We just want to fully understand as many of the 
use cases for this so we can determine what solution would be best and still 
only load plugins as late as possible.
Your scenario #2 really describes what I am trying to do, but I don't think the 
solution you propose for #1 would still be sufficient. 

My plug-in has a subsystem that must be launched if my persistent property is 
set to true. However, I must launch that subsystem on a background thread at 
the time my plug-in starts up. The startup wouldn't wait for the first time the 
menu item is shown.

In general, I think the checked state of the menu item would reflect a state of 
affairs that is independent of whether the user has looked at the menu item 
yet, and therefore, up-front construction of the delegate wouldn't be necessary.

I am assuming that you are talking about constructing the delegate when the 
menu item is shown. I may be misunderstanding, and you may be talking about 
constructing the delegate on plug-in startup. That would perhaps make for 
cleaner code, as I can simply detect the state change in the menu item on 
startup and start my subsystem as needed, in lieu of having an independent read 
of the persistent property. But there are good reasons for not going down that 
route: 1) it probably would have a negative impact on workbench startup time. 
2) (this is just a more obscure gut feeling I have, and I apologize if it 
doesn't make much sense) i don't think it wouldn't encourage good (MVC) design 
on the part of the coder contributing to the actionSet, as the menu item itself 
would somehow become a mix of all three MVC elements.

Of course, there may be other users out there who could come up with a 
different scenario. Perhaps they would want to perform some calculation to 
determine the initial checked state. How would you design for that? Sounds like 
you would need to ask users to supply in their extension a class that handles 
this, and you would have to check a method in that class (which will of course 
implement some interface you supplied) to establish the state. This is not what 
I am asking for, but I guess I could see the scenario arise.
Sorry Simon, typed too fast. In the second sentence of my previous comments, I 
of course meant to say "I *do* think the solution you propose for #1 would 
still be sufficient."

So you would be ok with the following scenario...
- User starts up Eclipse first time
- Turns on your toggle action, which causes your delegate (&amp; plug-in) to load
- Your delegate launches the background process
- User exits Eclipse
- User restarts Eclipse

Now at this point, lets assume the workbench was able to remember your action 
being in the "on" toggle state and restores it that way. Lets also assume that 
your plugin was not started (workbench lazy loads a plug-in - that is only when 
the user does something that requires that plug-in's code, like running an 
action, showing a view/editor, etc).

So your action would be in the "on" toggle state, but yet no background process 
would be running since your delegate is not loaded because your plugin is not 
loaded. Is that acceptable? Or would you require that if the action is restored 
in the "on" toggle state, that the delegate be loaded (and therefore the plug-
in also), and call "run" on the delegate?
In my particular case, I need to force plug-in load at startup anyway, so I 
take the extreme but necessary step of extending org.eclipse.ui startup. So 
your first proposal would be acceptable to me.

But I can anticipate someone wanting the behavior in your second proposal. In 
fact, I referred someone from the eclipse.tools newsgroup to this bug; he may 
have a different opinion on this (see today's post by Christian Lemer).
Our problem may be related but could be solved (maybe) in another way. Our problem is also related to the access to the IAction, but we were able to solve the initial status with the XML rules.Our problem is that the status could only be modified during the run or the selectionChanged. Unfortunately, in our case, the connection status could be changed in other situations... Should we fire a fake selectionChanged in some way?
Reassigning to Platform-UI-Inbox (I left IBM 18 months ago..)
Moving Dougs bugs
Assigning to component owner
PW</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35405" />
    <CreationDate amount="2003-03-20 16:00:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.0.2" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="trivial" />
    <Summery>Minor typo in CVS error message</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Major nit: See attached.  An extra period at the end of the sentence.
Created attachment 4270
Minor typo in error message
The message
  EXTServerConnection.ioError

has a single period on the end, but then gets combined with
  NewLocationWizard.validationFailedText={0}. Keep location anyway?

I can understand why we did this with the second message - since the argument 
being replaced is the error message from the exception, we cannot be sure it 
has a period on the end.

So easiest fix is to just remove the period off the end of 
EXTServerConnection.ioError.  I believe this is the only place the exception 
message is displayed.
Fixed. will be in RC4.</WithStack>
    <WithOutStack>Major nit: See attached.  An extra period at the end of the sentence.
Created attachment 4270
Minor typo in error message
The message
  EXTServerConnection.ioError

has a single period on the end, but then gets combined with
  NewLocationWizard.validationFailedText={0}. Keep location anyway?

I can understand why we did this with the second message - since the argument 
being replaced is the error message from the exception, we cannot be sure it 
has a period on the end.

So easiest fix is to just remove the period off the end of 
EXTServerConnection.ioError.  I believe this is the only place the exception 
message is displayed.
Fixed. will be in RC4.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35406" />
    <CreationDate amount="2003-03-20 16:04:00 -0500" />
    <DupId amount="" />
    <classification amount="Tools" />
    <Product amount="GEF" />
    <component amount="GEF (MVC) [GEF 3.x / Zest 1.x]" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P1" />
    <bug_severity amount="major" />
    <Summery>Memory leak in PaletteEditPart imagecache</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>change getImageCache() to be a static method.  Fix resulting comile errors.
Done.</WithStack>
    <WithOutStack>change getImageCache() to be a static method.  Fix resulting comile errors.
Done.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35407" />
    <CreationDate amount="2003-03-20 16:09:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="User Assistance" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Standalone help may hang if started/shutdown randomly</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>RC3 build, win2k

I created two bat files, one to displayHelp and one to shutdown the standalone 
help. I randomly clicked these files, very fast:
I clicked on the displayHelp one a few times in a row (very fast) and then 
clicked on the shutdown bat files a couple of times and then a few more times 
on the displayHelp file.
I ended up with two command windows that were running the displayHelp command, 
but no browser window at all. 

I repeated this (random clicking on the two bat files) and got into a scenario 
with one browser up displaying help, and another one up, but blank.
I am not sure this a valid scenario.  By clicking randomly, don't you ask for 
trouble.  I understand trying to display help different URLs several times in a 
row, by starting and stopping too fast?  Have you tried it with other programs?

Anyway, what are your help preferences, i.e. the brower and port.  Are they 
defult? What are commands you launch from your .bat files?

Did a bit more playing around and got to a situation in which the command 
window was hanging and the browser was showing: "The page cannot be 
displayed..."

I tried both fixed port and predefined ports.
The commands were:
java -cp plugins\org.eclipse.help_2.1.0\help.jar 
org.eclipse.help.standalone.Help -command displayHelp

java -cp plugins\org.eclipse.help_2.1.0\help.jar 
org.eclipse.help.standalone.Help -command shutdown

I agree this is a contrieved scenario. I only opened the bug to raise the 
issue, but don't expect a fix (at least not soon).

Eclipse 2.2 will require minimum version of JDK be 1.4.  1.4 provides file 
locking functionality, that probably be employed to solve startup, shutdown 
synchronization issues, between infocenter or standalone help processes.
According to the plan, the next release will be called 3.0 and run with Java 
1.4.  Presently Eclipse is still being build with 1.3.  After the switch to 
1.4 a new synchronization/file locking can be implemented.
Released code for synchronous starting/stopping/displaying help by stand alone 
help and infocenter.
To achieve inter process synchronization, the code employes file locking 
provided by Java 1.4, so for now is in v20030821_syncStandalone for 
org.eclispe.help and org.eclipse.help.tests plug-ins, until Eclipse build will 
stop using Java 1.3.
Merged fix from v20030821_syncStandalone branch into HEAD and RCP_WORK_1 
branch.
*** Bug 78763 has been marked as a duplicate of this bug. ***</WithStack>
    <WithOutStack>RC3 build, win2k

I created two bat files, one to displayHelp and one to shutdown the standalone 
help. I randomly clicked these files, very fast:
I clicked on the displayHelp one a few times in a row (very fast) and then 
clicked on the shutdown bat files a couple of times and then a few more times 
on the displayHelp file.
I ended up with two command windows that were running the displayHelp command, 
but no browser window at all. 

I repeated this (random clicking on the two bat files) and got into a scenario 
with one browser up displaying help, and another one up, but blank.
I am not sure this a valid scenario.  By clicking randomly, don't you ask for 
trouble.  I understand trying to display help different URLs several times in a 
row, by starting and stopping too fast?  Have you tried it with other programs?

Anyway, what are your help preferences, i.e. the brower and port.  Are they 
defult? What are commands you launch from your .bat files?

Did a bit more playing around and got to a situation in which the command 
window was hanging and the browser was showing: "The page cannot be 
displayed..."

I tried both fixed port and predefined ports.
The commands were:
java -cp plugins\org.eclipse.help_2.1.0\help.jar 
org.eclipse.help.standalone.Help -command displayHelp

java -cp plugins\org.eclipse.help_2.1.0\help.jar 
org.eclipse.help.standalone.Help -command shutdown

I agree this is a contrieved scenario. I only opened the bug to raise the 
issue, but don't expect a fix (at least not soon).

Eclipse 2.2 will require minimum version of JDK be 1.4.  1.4 provides file 
locking functionality, that probably be employed to solve startup, shutdown 
synchronization issues, between infocenter or standalone help processes.
According to the plan, the next release will be called 3.0 and run with Java 
1.4.  Presently Eclipse is still being build with 1.3.  After the switch to 
1.4 a new synchronization/file locking can be implemented.
Released code for synchronous starting/stopping/displaying help by stand alone 
help and infocenter.
To achieve inter process synchronization, the code employes file locking 
provided by Java 1.4, so for now is in v20030821_syncStandalone for 
org.eclispe.help and org.eclipse.help.tests plug-ins, until Eclipse build will 
stop using Java 1.3.
Merged fix from v20030821_syncStandalone branch into HEAD and RCP_WORK_1 
branch.
*** Bug 78763 has been marked as a duplicate of this bug. ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35408" />
    <CreationDate amount="2003-03-20 16:13:00 -0500" />
    <DupId amount="" />
    <classification amount="Tools" />
    <Product amount="GEF" />
    <component amount="Draw2d [GEF 3.x / Zest 1.x]" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P2" />
    <bug_severity amount="major" />
    <Summery>Small scale/zoom settings result in zero height Font</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>ScaledGraphics does not check for zoomed font height of 0.
Is it safe to return 1 in zoomFontHeight() if the zoomed height is actually 0? 
This won't fix the problem in Motif, since a height of 2 will cause the VM to
crash.  Maybe we shouldn't draw text at all when the font height becomes 0.  I
highly doubt anyone will be able to read it anyway.
Why is this marked P1?  It doesn't cause any known problems, does it?

Ideally, we would not draw the text at all. I don't think using 1 instead of 0 
is a necessary change at this point.
Added a boolean to ScaledGraphics so that text is not drawn if font height is
less than 1.</WithStack>
    <WithOutStack>ScaledGraphics does not check for zoomed font height of 0.
Is it safe to return 1 in zoomFontHeight() if the zoomed height is actually 0? 
This won't fix the problem in Motif, since a height of 2 will cause the VM to
crash.  Maybe we shouldn't draw text at all when the font height becomes 0.  I
highly doubt anyone will be able to read it anyway.
Why is this marked P1?  It doesn't cause any known problems, does it?

Ideally, we would not draw the text at all. I don't think using 1 instead of 0 
is a necessary change at this point.
Added a boolean to ScaledGraphics so that text is not drawn if font height is
less than 1.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35409" />
    <CreationDate amount="2003-03-20 16:17:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>RC2 Compiler produces bogus error messages</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="4">
      <source_code type="functioncall">
        <location start="341" end="378" />
        <code>sFac.optional("anyAttribute"))));</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="379" end="438" />
        <code>//Content: (annotation?, ((attribute | attributeGroup)*,</code>
      </source_code>
      <source_code type="functioncall">
        <location start="742" end="779" />
        <code>sFac.optional("anyAttribute"))));</code>
      </source_code>
      <source_code type="assignment">
        <location start="1358" end="1407" />
        <code>private static Exp GROUP_CHILDREN = Exp.Epsilon;</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>The following code snippet compiles without error:

	private static Exp COMPLEXEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.optional(
				sFac.union(new String[] 
{"group","all","choice","sequence"})),
			sFac.concat(
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"})),
				sFac.optional("anyAttribute"))));
	//Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
	private static Exp SIMPLEEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.optional(
				sFac.union(new String[] 
{"group","all","choice","sequence"})),
			sFac.concat(
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"})),
				sFac.optional("anyAttribute"))));

When the following line is added:

	private static Exp GROUP_CHILDREN =

(an incomplete declaration) the compiler erroneously marks each first instance 
of a comma in the String initializers preceding it as an error, with the error 
message:

Syntax error: ",",...expected

The character marked _is_ a ","!

To be perfectly clear, an error after these declarations is incorrectly 
causing bogus errors to be flagged within the declarations, before the actual 
error. The resulting blizzard of error flags makes it very difficult to work.

BTW, change the above line to, e.g.:

	private static Exp GROUP_CHILDREN = Exp.Epsilon;

And all the bogus errors preceding it go away.
It is confusing indeed, we have a few other instances where syntax error 
messages could be improved. Post 2.1
We are considering improving our syntax error messages
Fixed.
Verified.</WithStack>
    <WithOutStack>The following code snippet compiles without error:

	private static Exp COMPLEXEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.optional(
				sFac.union(new String[] 
{"group","all","choice","sequence"})),
			sFac.concat(
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"})),
				sFac.optional("anyAttribute"))));
	//Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
	private static Exp SIMPLEEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.optional(
				sFac.union(new String[] 
{"group","all","choice","sequence"})),
			sFac.concat(
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"})),
				sFac.optional("anyAttribute"))));

When the following line is added:

	private static Exp GROUP_CHILDREN =

(an incomplete declaration) the compiler erroneously marks each first instance 
of a comma in the String initializers preceding it as an error, with the error 
message:

Syntax error: ",",...expected

The character marked _is_ a ","!

To be perfectly clear, an error after these declarations is incorrectly 
causing bogus errors to be flagged within the declarations, before the actual 
error. The resulting blizzard of error flags makes it very difficult to work.

BTW, change the above line to, e.g.:

	private static Exp GROUP_CHILDREN = Exp.Epsilon;

And all the bogus errors preceding it go away.
It is confusing indeed, we have a few other instances where syntax error 
messages could be improved. Post 2.1
We are considering improving our syntax error messages
Fixed.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35410" />
    <CreationDate amount="2003-03-20 16:20:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>VariableView#fExpandedVariables is not always cleaned</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="12">
        <Lines>
          <Line>1. In a selfhost workspace, import EvalNestedTypeTest.java (from</Line>
          <Line>org.eclipse.jdt.debug.tests), set a breakpoint line 65.</Line>
          <Line>2. Switch to the debug prespective, hide the variables view (bring the display</Line>
          <Line>view on top for example).</Line>
          <Line>3. Launch EvalNestedTypeTest in debug mode.</Line>
          <Line>4. When the breakpoint is hit, eval "bb" in the display view.</Line>
          <Line>5. When the evaluation is finished, resume the program, remove all terminate.</Line>
          <Line>6. Switch to the host, add a breakpoint at the first line of</Line>
          <Line>VariablesView#setFocus().</Line>
          <Line>7. In the selfhost workspace, set the focus on the variables view.</Line>
          <Line>8. In the host, when the breakpoint is hit, expand 'this' in the variable view,</Line>
          <Line>fExpandedVariables contains one JDIStackFrame, it should be empty.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>How to see the problem:

1. In a selfhost workspace, import EvalNestedTypeTest.java (from
org.eclipse.jdt.debug.tests), set a breakpoint line 65.
2. Switch to the debug prespective, hide the variables view (bring the display
view on top for example).
3. Launch EvalNestedTypeTest in debug mode.
4. When the breakpoint is hit, eval "bb" in the display view.
5. When the evaluation is finished, resume the program, remove all terminate.
6. Switch to the host, add a breakpoint at the first line of
VariablesView#setFocus().
7. In the selfhost workspace, set the focus on the variables view.
8. In the host, when the breakpoint is hit, expand 'this' in the variable view,
fExpandedVariables contains one JDIStackFrame, it should be empty.

The JDIStackFrame cannot be garbage-collected, so are all element of the java
debug model linked to this JDIStackFrame.
Yes - it appears our cache is "frame -&gt; variables". However, we clear the cache 
when a terminate event occurs, which will remove threads &amp; frames from the 
cache (but not stack frames).
Woops - I take that back. The code accounts for terminate events coming from 
threads &amp; debug targets. Needs more investigation.
Ah. When the view is not visible, we do not handle the debug events (an 
optimization put in during 2.1). Thus, if the termiante event comes when the 
view is not visible, the cache is not cleared. However, I do not believe this 
should not cause a large leak unless the view is being made visible and then 
hidden for each target at is terminates?
The test case can be simplified. Debugging a program with a breakpoint while the
variable view is hidden create the problem.

When the program is resumed, the selection in the debug view is updated.
setViewerInput() is called, and the current state is store in the map.

I think we should always call clearExpandedVariables() for terminate event. We
can do that by using updateForDebugEvents(DebugEvent[])
Yes, the safe fix is to clear the cache on termination, even when the view is 
hidden in #updateForDebugEvents(...).

Adding Erich as CC for heads up. This may be a candidate to fix for 2.1.

Please re-run the tests with the proposed fix to see if this fixes the problem.
Agreed this is a candidate - what is the risk behind the "safe fix"
There is no risk. During 2.1, the debug view event handler hierarchy was 
refactored to *not* update views when they are not visible (as an 
optimization). We would just move the "terminate" event handling in the 
variables view to the location where it is executed no matter if the view is 
visible or not.
I am not yet convinced we need to fix this - the eval test suite still grows 
with this fix in place. We need to investigate further.
Marking as RC4 candidate. Since this is a simple leak to fix, we should do it.
+1
+1
Fixed.
Please verify, Luc.
Verified.</WithStack>
    <WithOutStack>How to see the problem:

1. In a selfhost workspace, import EvalNestedTypeTest.java (from
org.eclipse.jdt.debug.tests), set a breakpoint line 65.
2. Switch to the debug prespective, hide the variables view (bring the display
view on top for example).
3. Launch EvalNestedTypeTest in debug mode.
4. When the breakpoint is hit, eval "bb" in the display view.
5. When the evaluation is finished, resume the program, remove all terminate.
6. Switch to the host, add a breakpoint at the first line of
VariablesView#setFocus().
7. In the selfhost workspace, set the focus on the variables view.
8. In the host, when the breakpoint is hit, expand 'this' in the variable view,
fExpandedVariables contains one JDIStackFrame, it should be empty.

The JDIStackFrame cannot be garbage-collected, so are all element of the java
debug model linked to this JDIStackFrame.
Yes - it appears our cache is "frame -&gt; variables". However, we clear the cache 
when a terminate event occurs, which will remove threads &amp; frames from the 
cache (but not stack frames).
Woops - I take that back. The code accounts for terminate events coming from 
threads &amp; debug targets. Needs more investigation.
Ah. When the view is not visible, we do not handle the debug events (an 
optimization put in during 2.1). Thus, if the termiante event comes when the 
view is not visible, the cache is not cleared. However, I do not believe this 
should not cause a large leak unless the view is being made visible and then 
hidden for each target at is terminates?
The test case can be simplified. Debugging a program with a breakpoint while the
variable view is hidden create the problem.

When the program is resumed, the selection in the debug view is updated.
setViewerInput() is called, and the current state is store in the map.

I think we should always call clearExpandedVariables() for terminate event. We
can do that by using updateForDebugEvents(DebugEvent[])
Yes, the safe fix is to clear the cache on termination, even when the view is 
hidden in #updateForDebugEvents(...).

Adding Erich as CC for heads up. This may be a candidate to fix for 2.1.

Please re-run the tests with the proposed fix to see if this fixes the problem.
Agreed this is a candidate - what is the risk behind the "safe fix"
There is no risk. During 2.1, the debug view event handler hierarchy was 
refactored to *not* update views when they are not visible (as an 
optimization). We would just move the "terminate" event handling in the 
variables view to the location where it is executed no matter if the view is 
visible or not.
I am not yet convinced we need to fix this - the eval test suite still grows 
with this fix in place. We need to investigate further.
Marking as RC4 candidate. Since this is a simple leak to fix, we should do it.
+1
+1
Fixed.
Please verify, Luc.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35411" />
    <CreationDate amount="2003-03-20 16:20:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>CCombo's arrow Button should take height from text widget</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="3">
      <source_code type="assignment">
        <location start="703" end="774" />
        <code>Point arrowSize = arrow.computeSize(SWT.DEFAULT, textSize.y, changed);</code>
      </source_code>
      <source_code type="assignment">
        <location start="894" end="952" />
        <code>Point arrowSize = arrow.computeSize(SWT.DEFAULT, height);</code>
      </source_code>
      <source_code type="assignment">
        <location start="953" end="1000" />
        <code>arrowSize.x = max(arrowSize.x, arrowSize.y-1);</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>CCombo uses a Text and a Button (arrow).  In the CCombo's computeSize() method 
it asks the Text and the Button to computeSize with SWT.DEFAULT height, and 
takes the max of these two sizes.

Thus, if the Text uses a large font, the button will grow vertically to match 
the height needed by the Text, but if the Text uses a small font, the button 
will not shrink below its "default" height.

One effect of this is that a CCombo and a Text widget, side by side and using 
the same font, may be different heights.  On Windows 2000 the CCombo appears to 
be two pixels taller.  The empty space appears below the Text widget.

Suggestion:

In computeSize(), the button should follow the Text's lead, e.g:
	Point arrowSize = arrow.computeSize(SWT.DEFAULT, textSize.y, changed);

Also, perhaps the button's width should be reduced along with its height.  E.g. 
in internalLayout(), something like:
	Point arrowSize = arrow.computeSize(SWT.DEFAULT, height);
	arrowSize.x = max(arrowSize.x, arrowSize.y-1);
The arrow button is using a platform defined arrow appearance.  Shrinking the 
button may have undesired effects.

If you really want to force the CCombo to have the same height as the Text 
widget, don't use the default value for the height in computeSize.</WithStack>
    <WithOutStack>CCombo uses a Text and a Button (arrow).  In the CCombo's computeSize() method 
it asks the Text and the Button to computeSize with SWT.DEFAULT height, and 
takes the max of these two sizes.

Thus, if the Text uses a large font, the button will grow vertically to match 
the height needed by the Text, but if the Text uses a small font, the button 
will not shrink below its "default" height.

One effect of this is that a CCombo and a Text widget, side by side and using 
the same font, may be different heights.  On Windows 2000 the CCombo appears to 
be two pixels taller.  The empty space appears below the Text widget.

Suggestion:

In computeSize(), the button should follow the Text's lead, e.g:
	Point arrowSize = arrow.computeSize(SWT.DEFAULT, textSize.y, changed);

Also, perhaps the button's width should be reduced along with its height.  E.g. 
in internalLayout(), something like:
	Point arrowSize = arrow.computeSize(SWT.DEFAULT, height);
	arrowSize.x = max(arrowSize.x, arrowSize.y-1);
The arrow button is using a platform defined arrow appearance.  Shrinking the 
button may have undesired effects.

If you really want to force the CCombo to have the same height as the Text 
widget, don't use the default value for the height in computeSize.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35412" />
    <CreationDate amount="2003-03-20 16:24:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="User Assistance" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>2.1 RC3; Searh result not loaded/highlighted when browser already opened</Summery>
    <Patches amount="2">
      <Patch>
        <index>MozillaBrowserAdapter.java</index>
        <original_file>MozillaBrowserAdapter.java</original_file>
        <modified_file>MozillaBrowserAdapter.java</modified_file>
        <Hunks>
          <hunk>waitForBrowser();&#xD;
&#xD;
 			if (exitRequested)&#xD;
&#xD;
 				return;&#xD;
&#xD;
-			//workaround for bug 23750, mozilla bug 159092&#xD;
&#xD;
-			// instead of simply -remote openURL(" + url + ")",</hunk>
        </Hunks>
      </Patch>
      <Patch>
        <index>index.jsp</index>
        <original_file>index.jsp</original_file>
        <modified_file>index.jsp</modified_file>
        <Hunks>
          <hunk>function onloadHandler(e)&#xD;
&#xD;
 {&#xD;
&#xD;
+&lt;%&#xD;
&#xD;
+if (data.isMozilla()){&#xD;
&#xD;
+// restore mozilla from minimized&#xD;
&#xD;
+%&gt;&#xD;
&#xD;
+	window.focus();&#xD;
&#xD;
+&lt;%&#xD;
&#xD;
+}&#xD;
&#xD;
+%&gt;&#xD;
&#xD;
 	window.frames["SearchFrame"].document.getElementById("searchWord").focus</hunk>
        </Hunks>
      </Patch>
    </Patches>
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="3">
      <source_code type="functioncall">
        <location start="2479" end="2500" />
        <code>waitForBrowser();</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="3238" end="3325" />
        <code>+if (data.isMozilla()){
+// restore mozilla from minimized
+%&gt;
+	window.focus();
+&lt;%
+}</code>
      </source_code>
      <source_code type="functioncall">
        <location start="3405" end="3408" />
        <code>();</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>RedHat 8.0, Mozilla 1.0.1, Eclipse 2.1 RC3 build.

Performing search from the workbench, and double clicking result opens help,
shows search results in search view, highlight selected topic in the list and
display the topic on the right.  An example of URL displayed in the address is:
http://127.0.0.1:33524/help/index.jsp?tab=search&amp;searchWord=%6a%61%76%61&amp;maxHits=500&amp;lang=en_US&amp;fieldSearch=false&amp;topic=%2Forg.eclipse.platform.doc.isv%2Freference%2Fmisc%2Fhelp_infocenter.html%3Fresultof%3D%2522%256a%2561%2576%2561%2522%2520

Doing the same when browser (mozilla) is already opened results in results being
shown, but the selected topic is not highlighted in the list.  It is not shown
in the content area either (welcome page is displayed).  The URL for the same
hit is displayed by Mozilla as:
http://127.0.0.1:33524/help/index.jsp?tab=search&amp;searchWord=java&amp;maxHits=500&amp;lang=en_US&amp;fieldSearch=false&amp;topic=/org.eclipse.platform.doc.isv/reference/misc/help_infocenter.html?resultof=%22%6a%61%76%61%22%20
which is different then the URL before.  The encoded parameters are somewhat
corrupted.
Sorry Wassim, I think this bug was reported by me, but bugzilla does not let me 
change the reported.

The problem affects Mozilla, but not Netscape 4.
It was introduced in M5 build, with the code for bug 23750 that is intended to 
go around Mozilla bug that does not restore Mozilla from minimized.  We should 
see whether the workaround can be fixed, or consider backing it out as I think 
this bug is more important than 23750 one.
This problem will be more pronounced with search for DBCS words.  The search 
word is encoded in the URL and that would be corrupted.

Rather than completely removing the workaround for bug 23750 to fix this 
problem with Mozilla it is possible to restored the code to open a browser to 
its original state (pre M5) and place the window.focus() javascript call in our 
index.jsp.  It has the same effect on Mozilla - it restores it from minimized, 
without affecting how the browser opens.

The 2 patches to apply to RC3a are:


Index: MozillaBrowserAdapter.java
===================================================================
RCS 
file: /home/eclipse/org.eclipse.help/src/org/eclipse/help/internal/browser/Mozil
laBrowserAdapter.java,v
retrieving revision 1.5
diff -u -r1.5 MozillaBrowserAdapter.java
--- MozillaBrowserAdapter.java	11 Mar 2003 20:38:34 -0000	1.5
+++ MozillaBrowserAdapter.java	21 Mar 2003 18:48:04 -0000
@@ -210,12 +210,7 @@
 			waitForBrowser();
 			if (exitRequested)
 				return;
-			//workaround for bug 23750, mozilla bug 159092
-			// instead of simply -remote openURL(" + url + ")", 
call a javascript
-			if (openBrowser(executable
-				+ " -remote openURL(javascript:window.focus
();window.location=\'"
-				+ url
-				+ "\')")
+			if (openBrowser(executable + " -remote openURL(" + url 
+ ")")
 				== 0) {
 				return;
 			}


Index: index.jsp
===================================================================
RCS file: /home/eclipse/org.eclipse.help.webapp/advanced/index.jsp,v
retrieving revision 1.14
diff -u -r1.14 index.jsp
--- index.jsp	11 Mar 2003 22:05:33 -0000	1.14
+++ index.jsp	21 Mar 2003 18:48:36 -0000
@@ -37,6 +37,14 @@
 
 function onloadHandler(e)
 {
+&lt;%
+if (data.isMozilla()){
+// restore mozilla from minimized
+%&gt;
+	window.focus();
+&lt;%
+}
+%&gt;
 	window.frames["SearchFrame"].document.getElementById("searchWord").focus
();
 }
 



The patch is very safe, as it does not affect Windows in any way, it will 
restore Netscape launching code to the original state, and the line of code 
added to index.jsp will only run on Mozilla (that has the problem).

Please review and approve for releasing into RC4.
I did a code review and tests with the proposed fixed and find it safe for 
releasing into RC4. It is an important fix to have for the Linux platform and 
recommend having it fixed in RC4.
Approved for fixing for RC4.
Since the patch may look a bit unreadable, what the fix is doing is:
replacing the command:

mozilla -remote openURL(javascript:window.focus();window.location=help_url)

by

mozilla -remote openURL(help_url)

and moving the window.focus() inside the url that we open (i.e. inside the 
index.jsp file).



+1
Fixed.
Verified using I20030326 build.</WithStack>
    <WithOutStack>RedHat 8.0, Mozilla 1.0.1, Eclipse 2.1 RC3 build.

Performing search from the workbench, and double clicking result opens help,
shows search results in search view, highlight selected topic in the list and
display the topic on the right.  An example of URL displayed in the address is:
http://127.0.0.1:33524/help/index.jsp?tab=search&amp;searchWord=%6a%61%76%61&amp;maxHits=500&amp;lang=en_US&amp;fieldSearch=false&amp;topic=%2Forg.eclipse.platform.doc.isv%2Freference%2Fmisc%2Fhelp_infocenter.html%3Fresultof%3D%2522%256a%2561%2576%2561%2522%2520

Doing the same when browser (mozilla) is already opened results in results being
shown, but the selected topic is not highlighted in the list.  It is not shown
in the content area either (welcome page is displayed).  The URL for the same
hit is displayed by Mozilla as:
http://127.0.0.1:33524/help/index.jsp?tab=search&amp;searchWord=java&amp;maxHits=500&amp;lang=en_US&amp;fieldSearch=false&amp;topic=/org.eclipse.platform.doc.isv/reference/misc/help_infocenter.html?resultof=%22%6a%61%76%61%22%20
which is different then the URL before.  The encoded parameters are somewhat
corrupted.
Sorry Wassim, I think this bug was reported by me, but bugzilla does not let me 
change the reported.

The problem affects Mozilla, but not Netscape 4.
It was introduced in M5 build, with the code for bug 23750 that is intended to 
go around Mozilla bug that does not restore Mozilla from minimized.  We should 
see whether the workaround can be fixed, or consider backing it out as I think 
this bug is more important than 23750 one.
This problem will be more pronounced with search for DBCS words.  The search 
word is encoded in the URL and that would be corrupted.

Rather than completely removing the workaround for bug 23750 to fix this 
problem with Mozilla it is possible to restored the code to open a browser to 
its original state (pre M5) and place the window.focus() javascript call in our 
index.jsp.  It has the same effect on Mozilla - it restores it from minimized, 
without affecting how the browser opens.

The 2 patches to apply to RC3a are:


Index: MozillaBrowserAdapter.java
===================================================================
RCS 
file: /home/eclipse/org.eclipse.help/src/org/eclipse/help/internal/browser/Mozil
laBrowserAdapter.java,v
retrieving revision 1.5
diff -u -r1.5 MozillaBrowserAdapter.java
--- MozillaBrowserAdapter.java	11 Mar 2003 20:38:34 -0000	1.5
+++ MozillaBrowserAdapter.java	21 Mar 2003 18:48:04 -0000
@@ -210,12 +210,7 @@
 			waitForBrowser();
 			if (exitRequested)
 				return;
-			//workaround for bug 23750, mozilla bug 159092
-			// instead of simply -remote openURL(" + url + ")", 
call a javascript
-			if (openBrowser(executable
-				+ " -remote openURL(javascript:window.focus
();window.location=\'"
-				+ url
-				+ "\')")
+			if (openBrowser(executable + " -remote openURL(" + url 
+ ")")
 				== 0) {
 				return;
 			}


Index: index.jsp
===================================================================
RCS file: /home/eclipse/org.eclipse.help.webapp/advanced/index.jsp,v
retrieving revision 1.14
diff -u -r1.14 index.jsp
--- index.jsp	11 Mar 2003 22:05:33 -0000	1.14
+++ index.jsp	21 Mar 2003 18:48:36 -0000
@@ -37,6 +37,14 @@
 
 function onloadHandler(e)
 {
+&lt;%
+if (data.isMozilla()){
+// restore mozilla from minimized
+%&gt;
+	window.focus();
+&lt;%
+}
+%&gt;
 	window.frames["SearchFrame"].document.getElementById("searchWord").focus
();
 }
 



The patch is very safe, as it does not affect Windows in any way, it will 
restore Netscape launching code to the original state, and the line of code 
added to index.jsp will only run on Mozilla (that has the problem).

Please review and approve for releasing into RC4.
I did a code review and tests with the proposed fixed and find it safe for 
releasing into RC4. It is an important fix to have for the Linux platform and 
recommend having it fixed in RC4.
Approved for fixing for RC4.
Since the patch may look a bit unreadable, what the fix is doing is:
replacing the command:

mozilla -remote openURL(javascript:window.focus();window.location=help_url)

by

mozilla -remote openURL(help_url)

and moving the window.focus() inside the url that we open (i.e. inside the 
index.jsp file).



+1
Fixed.
Verified using I20030326 build.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35413" />
    <CreationDate amount="2003-03-20 16:25:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[resources] path variable manager should use safe runnables when notifying listeners</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>2.1 RC3 

The path variable manager should use safe runnables when notifying listeners 
(see PathVariableManager#fireVariableChangeEvent). Currently, a listener 
throwing a RuntimeException may prevent others of being notified.
Fixed and released to HEAD.</WithStack>
    <WithOutStack>2.1 RC3 

The path variable manager should use safe runnables when notifying listeners 
(see PathVariableManager#fireVariableChangeEvent). Currently, a listener 
throwing a RuntimeException may prevent others of being notified.
Fixed and released to HEAD.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35414" />
    <CreationDate amount="2003-03-20 16:29:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.1" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[runtime] Preferences should use safe runnables when notifying listeners</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>2.1 RC3 

Preferences should use safe runnables when notifying listeners 
(see Preferences#firePropertyChangeEvent). Currently, a listener 
throwing a RuntimeException may prevent others of being notified.
Fixed and released to HEAD.
Modified old and new prefs code.</WithStack>
    <WithOutStack>2.1 RC3 

Preferences should use safe runnables when notifying listeners 
(see Preferences#firePropertyChangeEvent). Currently, a listener 
throwing a RuntimeException may prevent others of being notified.
Fixed and released to HEAD.
Modified old and new prefs code.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35415" />
    <CreationDate amount="2003-03-20 16:32:00 -0500" />
    <DupId amount="31094" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>%linuxFragmentName undefined</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>build 20030319

I was looking at the configuration details in the about dialog. It contains an entry
	org.eclipse.core.resources.linux (2.1.0) "%linuxFragmentName"

I noticed that other fragments have the same problem (update, SWT). Is this
simply an oversight or is there a reason why these are apparently not defined?
Real bug.
Marking as dup.

*** This bug has been marked as a duplicate of 31094 ***</WithStack>
    <WithOutStack>build 20030319

I was looking at the configuration details in the about dialog. It contains an entry
	org.eclipse.core.resources.linux (2.1.0) "%linuxFragmentName"

I noticed that other fragments have the same problem (update, SWT). Is this
simply an oversight or is there a reason why these are apparently not defined?
Real bug.
Marking as dup.

*** This bug has been marked as a duplicate of 31094 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35416" />
    <CreationDate amount="2003-03-20 16:34:00 -0500" />
    <DupId amount="" />
    <classification amount="Tools" />
    <Product amount="GEF" />
    <component amount="GEF (MVC) [GEF 3.x / Zest 1.x]" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P4" />
    <bug_severity amount="minor" />
    <Summery>Clicking on drawer rollover does not assign focus to paletteviewer</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="4">
        <Lines>
          <Line>1) Give focus to the graphical canvas.</Line>
          <Line>2) Place mouse over a truncated palette drawer, and click on the rollover,</Line>
          <Line>expanding hte drawer</Line>
          <Line>3) Press down arrow key.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>1) Give focus to the graphical canvas.
2) Place mouse over a truncated palette drawer, and click on the rollover, 
expanding hte drawer
3) Press down arrow key.

The arrow key goes to the graphical canvas.
This is only P3, not a must fix.
later
reopen
investigate for rc2
For post-3.1
low priority.
LATER and REMIND resolutions will be going away with the upgrade of Bugzilla to the latest Bugzilla 3.4.  They are no longer part of the default Bugzilla installation. See http://dev.eclipse.org/mhonarc/lists/eclipse.org-committers/msg00778.html for the announcement.

As a result 
RESOLVED + REMIND OR LATER 
will be changed to
RESOLVED + WONTFIX

This unfortunately also means I need to REOPEN and then RESOLVE as WONTFIX

Sorry for the inconvenience.
LATER and REMIND resolutions will be going away with the upgrade of Bugzilla to the latest Bugzilla 3.4.  They are no longer part of the default Bugzilla installation. See http://dev.eclipse.org/mhonarc/lists/eclipse.org-committers/msg00778.html for the announcement.

As a result 
RESOLVED + REMIND OR LATER 
will be changed to
RESOLVED + WONTFIX

This unfortunately also means I need to REOPEN and then RESOLVE as WONTFIX

Sorry for the inconvenience.</WithStack>
    <WithOutStack>1) Give focus to the graphical canvas.
2) Place mouse over a truncated palette drawer, and click on the rollover, 
expanding hte drawer
3) Press down arrow key.

The arrow key goes to the graphical canvas.
This is only P3, not a must fix.
later
reopen
investigate for rc2
For post-3.1
low priority.
LATER and REMIND resolutions will be going away with the upgrade of Bugzilla to the latest Bugzilla 3.4.  They are no longer part of the default Bugzilla installation. See http://dev.eclipse.org/mhonarc/lists/eclipse.org-committers/msg00778.html for the announcement.

As a result 
RESOLVED + REMIND OR LATER 
will be changed to
RESOLVED + WONTFIX

This unfortunately also means I need to REOPEN and then RESOLVE as WONTFIX

Sorry for the inconvenience.
LATER and REMIND resolutions will be going away with the upgrade of Bugzilla to the latest Bugzilla 3.4.  They are no longer part of the default Bugzilla installation. See http://dev.eclipse.org/mhonarc/lists/eclipse.org-committers/msg00778.html for the announcement.

As a result 
RESOLVED + REMIND OR LATER 
will be changed to
RESOLVED + WONTFIX

This unfortunately also means I need to REOPEN and then RESOLVE as WONTFIX

Sorry for the inconvenience.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35417" />
    <CreationDate amount="2003-03-20 16:35:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Compare" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>"Replace With" menu is empty when no provider</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="2">
        <Lines>
          <Line>1. Pick a binary project, or an unshared project.</Line>
          <Line>2. In navigator, context menu, pick "Replace With"</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>1. Pick a binary project, or an unshared project.
2. In navigator, context menu, pick "Replace With"

The submenu will be empty.

I guess we moved "From Local History" to now be a top level menu "Restore from 
Local History".  As a result, the submenu is now empty.
Sounds like somebody is contributing the menu unnecessarily.
Simon, please investigate and if an XML change can be made, we should consider 
for RC4.

Replace With / Local History... was not moved up.  It targets only IFile, and 
so does not show up if a project or folder is selected.

Restore from Local History is a different action which restores deleted files.

So was this always empty for project/folders and we just never noticed?
The org.eclipse.compare plugin.xml needs a couple of changes to fix this 
problem.

1) In it's &lt;objectContribution id="org.eclipse.compare.CompareAction" element, 
it has a replaceWithMenu definition which it never uses within that 
objectContribution element. It should be removed. Otherwise, it will show up.

2) In it's &lt;objectContribution id="org.eclipse.compare.AddFromHistoryAction" 
element, the only action in this object contribution has 
menubarPath="replaceWithMenu" but there is no such group. This will cause the 
action to be added at the end of the popup menu (once #1 is take care of). It 
should be replaced with menubarPath="additions"

Moving to compare component for consideration for RC4
Although minor, I think we should fix to match people's expectations of a 2.1 
product.
The "Replace With" menu is shared between Compare and Team.
If I remove it (as suggested by Simon), I break the Team plugin because they depend on 
it and don't create their own if it doesn't exist. I get these error messages:
Invalid Menu Extension (Path is invalid): org.eclipse.team.ccvs.ui.replaceWithTag
Invalid Menu Extension (Path is invalid): org.eclipse.team.ccvs.ui.replace

So if we want to make this problem a RC4 candidate, Team would have to change their 
plugin.xml file too.

&gt;&gt;So if we want to make this problem a RC4 candidate, Team would have to 
change their plugin.xml file too.

That's fine for CVS (although I am unclear on what change you are proposing we 
make), but what happens to other providers?



&gt;&gt;(although I am unclear on what change you are proposing we make
You will have to stop relying on the "Replace With" menu created for you by the Compare 
plugin. Today, I'm creating it for you for every IResource. If I fix this PR, I will create the 
menu only for IFiles (since this is the only thing that is kept in the history). So you will 
have to create it for all other cases yourself.
This means that you will have to create the menu only for projects that are shared.
I'm not sure whether this is possible with the current Object contribution mechanism.


&gt;&gt; That's fine for CVS, but what happens to other providers?
The existence of the "Replace With" submenu is not published API. So all clients
reyling on its existence are sitting in the same boat.

Having said that, I don't think this PR will be fixed for RC4.  If I create the "Replace With" 
menu only for certain selections, I cannot place the "Restore from local History" action 
directly after it, because the menu path leading to it wouldn't be stable. So I could use 
only the menu path "additions". However that would place the action in front of the 
"Compare" and "Replace With" sub menus. I don't think that I can't accept this late UI 
change.




The Compare plugin will stop creating the "Replace With" menu 

Right now, Team is relying on Compare's internal implementation detail existence of a 
"Replace 


That's fine for CVS (although I am unclear on what change you are proposing we 
make), but what happens to other providers?




[OOPS, the three incomplete sentences at the end of my last comment are just "trailing 
garbage" that got posted by accident]
Currently, both Team and Compare define the menu since both could need it. It would be nice if we could clean up this menu definition problem in 3.3 (alhtough I don;t have any good ideas at the moment).
The Replace with menu is never empty now so this is no longer an issue.</WithStack>
    <WithOutStack>1. Pick a binary project, or an unshared project.
2. In navigator, context menu, pick "Replace With"

The submenu will be empty.

I guess we moved "From Local History" to now be a top level menu "Restore from 
Local History".  As a result, the submenu is now empty.
Sounds like somebody is contributing the menu unnecessarily.
Simon, please investigate and if an XML change can be made, we should consider 
for RC4.

Replace With / Local History... was not moved up.  It targets only IFile, and 
so does not show up if a project or folder is selected.

Restore from Local History is a different action which restores deleted files.

So was this always empty for project/folders and we just never noticed?
The org.eclipse.compare plugin.xml needs a couple of changes to fix this 
problem.

1) In it's &lt;objectContribution id="org.eclipse.compare.CompareAction" element, 
it has a replaceWithMenu definition which it never uses within that 
objectContribution element. It should be removed. Otherwise, it will show up.

2) In it's &lt;objectContribution id="org.eclipse.compare.AddFromHistoryAction" 
element, the only action in this object contribution has 
menubarPath="replaceWithMenu" but there is no such group. This will cause the 
action to be added at the end of the popup menu (once #1 is take care of). It 
should be replaced with menubarPath="additions"

Moving to compare component for consideration for RC4
Although minor, I think we should fix to match people's expectations of a 2.1 
product.
The "Replace With" menu is shared between Compare and Team.
If I remove it (as suggested by Simon), I break the Team plugin because they depend on 
it and don't create their own if it doesn't exist. I get these error messages:
Invalid Menu Extension (Path is invalid): org.eclipse.team.ccvs.ui.replaceWithTag
Invalid Menu Extension (Path is invalid): org.eclipse.team.ccvs.ui.replace

So if we want to make this problem a RC4 candidate, Team would have to change their 
plugin.xml file too.

&gt;&gt;So if we want to make this problem a RC4 candidate, Team would have to 
change their plugin.xml file too.

That's fine for CVS (although I am unclear on what change you are proposing we 
make), but what happens to other providers?



&gt;&gt;(although I am unclear on what change you are proposing we make
You will have to stop relying on the "Replace With" menu created for you by the Compare 
plugin. Today, I'm creating it for you for every IResource. If I fix this PR, I will create the 
menu only for IFiles (since this is the only thing that is kept in the history). So you will 
have to create it for all other cases yourself.
This means that you will have to create the menu only for projects that are shared.
I'm not sure whether this is possible with the current Object contribution mechanism.


&gt;&gt; That's fine for CVS, but what happens to other providers?
The existence of the "Replace With" submenu is not published API. So all clients
reyling on its existence are sitting in the same boat.

Having said that, I don't think this PR will be fixed for RC4.  If I create the "Replace With" 
menu only for certain selections, I cannot place the "Restore from local History" action 
directly after it, because the menu path leading to it wouldn't be stable. So I could use 
only the menu path "additions". However that would place the action in front of the 
"Compare" and "Replace With" sub menus. I don't think that I can't accept this late UI 
change.




The Compare plugin will stop creating the "Replace With" menu 

Right now, Team is relying on Compare's internal implementation detail existence of a 
"Replace 


That's fine for CVS (although I am unclear on what change you are proposing we 
make), but what happens to other providers?




[OOPS, the three incomplete sentences at the end of my last comment are just "trailing 
garbage" that got posted by accident]
Currently, both Team and Compare define the menu since both could need it. It would be nice if we could clean up this menu definition problem in 3.3 (alhtough I don;t have any good ideas at the moment).
The Replace with menu is never empty now so this is no longer an issue.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35418" />
    <CreationDate amount="2003-03-20 16:46:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Text" />
    <Version amount="2.0.2" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux" />
    <priority amount="P3" />
    <bug_severity amount="trivial" />
    <Summery>inline comment after else causes following bracket to indent on format</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="4">
      <source_code type="ifstatement">
        <location start="51" end="80" />
        <code>if(true)
{
  //do something
}</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="123" end="145" />
        <code>//do something else</code>
      </source_code>
      <source_code type="ifstatement">
        <location start="255" end="284" />
        <code>if(true)
{
  //do something
}</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="329" end="351" />
        <code>//do something else</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Just FYI: If you have the following type of code:

if(true)
{
  //do something
}
else //and place an inline comment here
{
  //do something else
}


and you place a comment on the same line as the else, when you do a code format
the code looks like this

if(true)
{
  //do something
}
else //and place an inline comment here
  {
  //do something else
}


with the bracket after the else indented with the rest of the code.  If you
remove the comment, it does fine.


Here is my version and build information.

RedHat8.0
Motif version
Version: 2.0.2
Build id: 200211071448
fixed with the new formatter and auto indenting.</WithStack>
    <WithOutStack>Just FYI: If you have the following type of code:

if(true)
{
  //do something
}
else //and place an inline comment here
{
  //do something else
}


and you place a comment on the same line as the else, when you do a code format
the code looks like this

if(true)
{
  //do something
}
else //and place an inline comment here
  {
  //do something else
}


with the bracket after the else indented with the rest of the code.  If you
remove the comment, it does fine.


Here is my version and build information.

RedHat8.0
Motif version
Version: 2.0.2
Build id: 200211071448
fixed with the new formatter and auto indenting.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35419" />
    <CreationDate amount="2003-03-20 17:05:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="major" />
    <Summery>FileNotFoundException opening newly created file</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="functioncall">
        <location start="235" end="273" />
        <code>file_.create(inputStream, true, null);</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="3">
        <Lines>
          <Line>- Are you wrting to a local disk or a mounted network drive?</Line>
          <Line>- Have you tried different java VMs?</Line>
          <Line>- Is the failure consistent or sporadic?</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>I just discovered an interesting problem which has appeared sometime between
builds M4 and RC2 (it didn't happen in M4, does in RC2).

When a user finishes going through one of my wizards, I create a new file, with
the following line:
file_.create(inputStream, true, null);

Now, a couple lines of code later, (but still in the wizard.doFinish() method) I
have a different code package which is attempting to pick up and open this file
through the java.io package (rather than the eclipse resources).

In M4, this worked fine on Windows and Linux.

In RC2, it works fine on windows, but on Redhat Linux 8, I get a
java.io.FileNotFoundException.

A while later, after my wizard closes, if my other packages attempts to pick
this file up again, it works fine.  So I must have a cacheing or timing issue of
some sort, which has developed since M4.

Can anyone suggest a workaround to force the file to get written out to the file
system immediately?
We write the file to disk immediately, if there is caching, it would be in the
Java VM, the O/S, or lower.  I have a couple of questions that might help us
narrow this down:

- Are you wrting to a local disk or a mounted network drive?  
- Have you tried different java VMs?  
- Is the failure consistent or sporadic?

We have reports of problems on, for example, Samba mounted network drives, where
writes are not taking effect immediately, and immediate subsequent reads fail or
report out of sync problems.  There is no change that I know of in Eclipse code
between M4 and RC3 that could be related (although I certainly wouldn't preclude
the possibility).
I have tried it in the following two VM's

java version "1.4.1_02"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_02-b06)
Java HotSpot(TM) Client VM (build 1.4.1_02-b06, mixed mode)


java version "1.4.1_01"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01-b01)
Java HotSpot(TM) Client VM (build 1.4.1_01-b01, mixed mode)

and the failure occurs on both.  If it would help, I could try it on another VM
tomorrow.

The failure is consistant, and the disk is a local disk.

Thanks for the immediate attention.  
I've been trying to find a workaround for this issue, and have discovered that I
don't think this bug is caused by the eclipse platform, but rather by the emf
plugin that we are using... I have not yet finished tracking it down entirely,
but I now suspect that EMF is munging the path on linux somehow.  So don't waste
your time looking at eclipse code anymore... I'll let you know what the final
resolution is.

Thanks.

My problems where actually caused by a bug in EMF (bug # 35601) and how it is
handling URI's.  Marking Invalid.</WithStack>
    <WithOutStack>I just discovered an interesting problem which has appeared sometime between
builds M4 and RC2 (it didn't happen in M4, does in RC2).

When a user finishes going through one of my wizards, I create a new file, with
the following line:
file_.create(inputStream, true, null);

Now, a couple lines of code later, (but still in the wizard.doFinish() method) I
have a different code package which is attempting to pick up and open this file
through the java.io package (rather than the eclipse resources).

In M4, this worked fine on Windows and Linux.

In RC2, it works fine on windows, but on Redhat Linux 8, I get a
java.io.FileNotFoundException.

A while later, after my wizard closes, if my other packages attempts to pick
this file up again, it works fine.  So I must have a cacheing or timing issue of
some sort, which has developed since M4.

Can anyone suggest a workaround to force the file to get written out to the file
system immediately?
We write the file to disk immediately, if there is caching, it would be in the
Java VM, the O/S, or lower.  I have a couple of questions that might help us
narrow this down:

- Are you wrting to a local disk or a mounted network drive?  
- Have you tried different java VMs?  
- Is the failure consistent or sporadic?

We have reports of problems on, for example, Samba mounted network drives, where
writes are not taking effect immediately, and immediate subsequent reads fail or
report out of sync problems.  There is no change that I know of in Eclipse code
between M4 and RC3 that could be related (although I certainly wouldn't preclude
the possibility).
I have tried it in the following two VM's

java version "1.4.1_02"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_02-b06)
Java HotSpot(TM) Client VM (build 1.4.1_02-b06, mixed mode)


java version "1.4.1_01"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01-b01)
Java HotSpot(TM) Client VM (build 1.4.1_01-b01, mixed mode)

and the failure occurs on both.  If it would help, I could try it on another VM
tomorrow.

The failure is consistant, and the disk is a local disk.

Thanks for the immediate attention.  
I've been trying to find a workaround for this issue, and have discovered that I
don't think this bug is caused by the eclipse platform, but rather by the emf
plugin that we are using... I have not yet finished tracking it down entirely,
but I now suspect that EMF is munging the path on linux somehow.  So don't waste
your time looking at eclipse code anymore... I'll let you know what the final
resolution is.

Thanks.

My problems where actually caused by a bug in EMF (bug # 35601) and how it is
handling URI's.  Marking Invalid.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35420" />
    <CreationDate amount="2003-03-20 17:22:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="blocker" />
    <Summery>Reloading a feature removes that feature from the model</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>When feature model is reloaded as a reaction to resource change, during parsing 
we connect plug-in entries with plug-ins in the workspace. While calling to 
resolve plug-in entry in the workspace, 'validate' method validates features as 
well and removes the parsed feature because it still didn't run the validation 
pass on itself. 

This problem is easy to fix by restricting validation to the actual class of 
objects that is needed. For example, when features are needed, validation is 
performed only on features etc.

Fixed and verified.
Fixed.</WithStack>
    <WithOutStack>When feature model is reloaded as a reaction to resource change, during parsing 
we connect plug-in entries with plug-ins in the workspace. While calling to 
resolve plug-in entry in the workspace, 'validate' method validates features as 
well and removes the parsed feature because it still didn't run the validation 
pass on itself. 

This problem is easy to fix by restricting validation to the actual class of 
objects that is needed. For example, when features are needed, validation is 
performed only on features etc.

Fixed and verified.
Fixed.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35421" />
    <CreationDate amount="2003-03-20 17:24:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="trivial" />
    <Summery>[nls] Inconsistencies between properties files and nls strings</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>In 0319, I found what could be inconsistencies between .properties files and nls
strings.
All these entries are never used to nls a string:
ast.variableShouldProvide
element.onlyOneJavaModel
ast.postIncrShouldProvide
ast.missingStatement
element.notPresent
disassembler.methodtitle
option.badFormat
variable.badFormat
element.classpathCycle
element.cannotReconcile
configure.noSourceFile
eval.needBuiltState
disassembler.constructor_method_name
ast.compoundPreShouldProvide
element.projectDoesNotExist
ast.compoundVariableShouldProvide
disassembler.parameternameinmethodinvocation

These entries are incorrectly used:
abort.againstSourceModel  (a space has been added).
convention.classFile.notJavaName should be: convention.classFile.notClassFileName
path.nullpath should be: path.nullPath
status.defaultPackeReadOnly should be replaced with: status.defaultPackageReadOnly

This is trivial to fix.
Not critical for 2.1
Created attachment 4285
Patch to fix these nls issues
Defer
Reopen.
Fixed and released in 2.2 stream.
Verified.</WithStack>
    <WithOutStack>In 0319, I found what could be inconsistencies between .properties files and nls
strings.
All these entries are never used to nls a string:
ast.variableShouldProvide
element.onlyOneJavaModel
ast.postIncrShouldProvide
ast.missingStatement
element.notPresent
disassembler.methodtitle
option.badFormat
variable.badFormat
element.classpathCycle
element.cannotReconcile
configure.noSourceFile
eval.needBuiltState
disassembler.constructor_method_name
ast.compoundPreShouldProvide
element.projectDoesNotExist
ast.compoundVariableShouldProvide
disassembler.parameternameinmethodinvocation

These entries are incorrectly used:
abort.againstSourceModel  (a space has been added).
convention.classFile.notJavaName should be: convention.classFile.notClassFileName
path.nullpath should be: path.nullPath
status.defaultPackeReadOnly should be replaced with: status.defaultPackageReadOnly

This is trivial to fix.
Not critical for 2.1
Created attachment 4285
Patch to fix these nls issues
Defer
Reopen.
Fixed and released in 2.2 stream.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35422" />
    <CreationDate amount="2003-03-20 17:28:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Neutrino" />
    <priority amount="P3" />
    <bug_severity amount="critical" />
    <Summery>j9 launcher times out too fast</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="functioncall">
        <location start="2474" end="2508" />
        <code>Socket.connect(address, timeout);</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="3">
        <Lines>
          <Line>1. lanuch the VM</Line>
          <Line>2. launch the proxy</Line>
          <Line>3. connect to the proxy</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>When debugging on QNX the timeout for waiting for j9 proxy is too short.  It
causes the "Timeout waiting for JVM" dialog to open on almost every debugging
session.
The J9 launcher uses a "SocketAttach" connector when establishing a connection 
to the VM. This type of connetor does not support a timeout value. We use this 
type of connector because we are actually attaching to the debug proxy rather 
than the VM (thus the listening connector that we use with other VMs cannot be 
used). For some reason, the connector is throwing an IOException.

Does this happen every time, or just the first launch after a workspace is 
started? I have noticed this problem with J9, but generally, after J9 has been 
launched once, the problem goes away (at least on Windows).

I just tried with RC3 and it is happening every single time.  The dialog comes
up instantly on each debug session.  Doesn't seem to matter if I start the debug
session from the Java or the Debug perspective.  Anything I could do to help
debug this further?  


It sounds like the proxy must take longer to launch on Neutrino than on Windows 
for some reason. Looking at the implementation, this is what we do (and I'm not 
sure what we can change):

1. lanuch the VM
2. launch the proxy
3. connect to the proxy

In step 3, we simply open a socket on port/host specified in the launch (a port 
is chosen before we launch). If the socket does not open properly, it will 
complain, and you will get the dialog.
Sidenote - the j9 launching plug-in is not part of the Eclipse SDK - so if 
there is something we can do to help, we are not constrained by the 2.1 ship 
date.
I am actually trying to get it included with the 2.1 download for Neutrino since
j9 is the only supported jvm on QNX (in fact, the only jvm on QNX).  But that is
something I am talking about with others.

Can't we loop and try to connect to the proxy a couple of times before putting
up the dialog?  I will nab the j9 launching code and see if that helps.
Were you able to modify the code to help in any way?
Created attachment 4345
Patch to fix proxy timeouts on startup.

This fixes the troubles I have been seeing under QNX.  It attempts to do 10,
500ms sleep loops before throwing up the dialog for user intervention.
How does this patch look?

Sorry, I have not looked at the patch yet. I will look at it for next week's 
integration build.
Looking at the 1.4 APIs for Sockets, we can actually specify a timeout for an 
attach. I.e.

 Socket.connect(address, timeout);

This means we can actually honor the timeout user preference, which I believe 
is a better implementation. However, we have not yet officially moved to a 1.4 
runtime. Can this wait until we move to the 1.4 runtime?
What is the timeframe for j9 moving to a 1.4 level classlib in release form?  I
would certainly like to see this fixed before then since currently we are still
shipping j9 1.5.
It sounds like the timeframe is yet uncertain. This only effects the IDE 
runtime - not target application runtimes. However, since it is unclear, we can 
add support to handle the case in 1.3.
Fixed. I did not use the patch as is. Instead the launcher loops and attemps to 
reconnect until the user specified launch timeout is reached, at which point 
the user is prompted to re-try the launch.

However, I am perplexed by J9 at the moment - it seems I have to specify a 
bootpath even when I just want the default bootpath (but I verified the same 
problem existed with the 2.1 release). I will try a new J9 drop to see if the 
same problem exists.
Chris, can you try this new fix and verify it works for Neutrino? Thanks. 
I am assuming that DarinW meant to mark this as fixed.
Verified code.</WithStack>
    <WithOutStack>When debugging on QNX the timeout for waiting for j9 proxy is too short.  It
causes the "Timeout waiting for JVM" dialog to open on almost every debugging
session.
The J9 launcher uses a "SocketAttach" connector when establishing a connection 
to the VM. This type of connetor does not support a timeout value. We use this 
type of connector because we are actually attaching to the debug proxy rather 
than the VM (thus the listening connector that we use with other VMs cannot be 
used). For some reason, the connector is throwing an IOException.

Does this happen every time, or just the first launch after a workspace is 
started? I have noticed this problem with J9, but generally, after J9 has been 
launched once, the problem goes away (at least on Windows).

I just tried with RC3 and it is happening every single time.  The dialog comes
up instantly on each debug session.  Doesn't seem to matter if I start the debug
session from the Java or the Debug perspective.  Anything I could do to help
debug this further?  


It sounds like the proxy must take longer to launch on Neutrino than on Windows 
for some reason. Looking at the implementation, this is what we do (and I'm not 
sure what we can change):

1. lanuch the VM
2. launch the proxy
3. connect to the proxy

In step 3, we simply open a socket on port/host specified in the launch (a port 
is chosen before we launch). If the socket does not open properly, it will 
complain, and you will get the dialog.
Sidenote - the j9 launching plug-in is not part of the Eclipse SDK - so if 
there is something we can do to help, we are not constrained by the 2.1 ship 
date.
I am actually trying to get it included with the 2.1 download for Neutrino since
j9 is the only supported jvm on QNX (in fact, the only jvm on QNX).  But that is
something I am talking about with others.

Can't we loop and try to connect to the proxy a couple of times before putting
up the dialog?  I will nab the j9 launching code and see if that helps.
Were you able to modify the code to help in any way?
Created attachment 4345
Patch to fix proxy timeouts on startup.

This fixes the troubles I have been seeing under QNX.  It attempts to do 10,
500ms sleep loops before throwing up the dialog for user intervention.
How does this patch look?

Sorry, I have not looked at the patch yet. I will look at it for next week's 
integration build.
Looking at the 1.4 APIs for Sockets, we can actually specify a timeout for an 
attach. I.e.

 Socket.connect(address, timeout);

This means we can actually honor the timeout user preference, which I believe 
is a better implementation. However, we have not yet officially moved to a 1.4 
runtime. Can this wait until we move to the 1.4 runtime?
What is the timeframe for j9 moving to a 1.4 level classlib in release form?  I
would certainly like to see this fixed before then since currently we are still
shipping j9 1.5.
It sounds like the timeframe is yet uncertain. This only effects the IDE 
runtime - not target application runtimes. However, since it is unclear, we can 
add support to handle the case in 1.3.
Fixed. I did not use the patch as is. Instead the launcher loops and attemps to 
reconnect until the user specified launch timeout is reached, at which point 
the user is prompted to re-try the launch.

However, I am perplexed by J9 at the moment - it seems I have to specify a 
bootpath even when I just want the default bootpath (but I verified the same 
problem existed with the 2.1 release). I will try a new J9 drop to see if the 
same problem exists.
Chris, can you try this new fix and verify it works for Neutrino? Thanks. 
I am assuming that DarinW meant to mark this as fixed.
Verified code.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35423" />
    <CreationDate amount="2003-03-20 17:30:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Releng" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Neutrino" />
    <priority amount="P3" />
    <bug_severity amount="critical" />
    <Summery>j9 Launching Plugin</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Right now the j9 launching plugin is not included with the QNX download of
Eclipse.  This plugin is a required part of a QNX install as j9 is the ONLY jvm
supported by Eclipse (or even supported on QNX).  We should really get this
included as part of the Eclipse download for QNX.
Closing.  Should we start rebuilding this port of eclipse and this remains 
pertinent, please reopen.</WithStack>
    <WithOutStack>Right now the j9 launching plugin is not included with the QNX download of
Eclipse.  This plugin is a required part of a QNX install as j9 is the ONLY jvm
supported by Eclipse (or even supported on QNX).  We should really get this
included as part of the Eclipse download for QNX.
Closing.  Should we start rebuilding this port of eclipse and this remains 
pertinent, please reopen.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35424" />
    <CreationDate amount="2003-03-20 17:34:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[OLE] Control.setMenu does not work if the underlying widgets are not owned.</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="NEW" />
    <resolution amount="" />
    <WithStack>The code introduced in Control.WM_CONTEXTMENU to return if the handle does not 
match the wParam prevents the handling of context menus if the underlying 
widgets are not owned/created by the programmer.  In windows if a 
WM_CONTEXTMENU menssage is not processed by a child it propogates up the 
parent tree.  I imagine the code was introduced to prevent this behavior.  
However if the widget in which the message originates is not owned by me(i.e. 
anything that ActiveX components create) I cannot provide any sort of context 
menu because the events don't pass up my way(they do but are ignored at a 
lower level).
*** Bug 35426 has been marked as a duplicate of this bug. ***
Your bug has been moved to triage, visit http://www.eclipse.org/swt/triage.php for more info.</WithStack>
    <WithOutStack>The code introduced in Control.WM_CONTEXTMENU to return if the handle does not 
match the wParam prevents the handling of context menus if the underlying 
widgets are not owned/created by the programmer.  In windows if a 
WM_CONTEXTMENU menssage is not processed by a child it propogates up the 
parent tree.  I imagine the code was introduced to prevent this behavior.  
However if the widget in which the message originates is not owned by me(i.e. 
anything that ActiveX components create) I cannot provide any sort of context 
menu because the events don't pass up my way(they do but are ignored at a 
lower level).
*** Bug 35426 has been marked as a duplicate of this bug. ***
Your bug has been moved to triage, visit http://www.eclipse.org/swt/triage.php for more info.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35425" />
    <CreationDate amount="2003-03-20 17:35:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="minor" />
    <Summery>[misc] Column count does update when pasting text</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="3">
        <Lines>
          <Line>1. Copy some text onto the clipboard.</Line>
          <Line>2. Place the cursor into any Eclipse text editor window.</Line>
          <Line>3. Press Ctrl-V to paste the text.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Sorry if I got the component wrong.  To reproduce:

1. Copy some text onto the clipboard.
2. Place the cursor into any Eclipse text editor window.
3. Press Ctrl-V to paste the text.

Note that the status bar's column indicator is wrong.  It didn't update for 
the paste operation.  Okay, so maybe I'm the only person in the world who 
cares... and I don't care that awfully much, but still... ;)
has been fixed</WithStack>
    <WithOutStack>Sorry if I got the component wrong.  To reproduce:

1. Copy some text onto the clipboard.
2. Place the cursor into any Eclipse text editor window.
3. Press Ctrl-V to paste the text.

Note that the status bar's column indicator is wrong.  It didn't update for 
the paste operation.  Okay, so maybe I'm the only person in the world who 
cares... and I don't care that awfully much, but still... ;)
has been fixed</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35426" />
    <CreationDate amount="2003-03-20 17:41:00 -0500" />
    <DupId amount="35424" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Control.setMenu does not work if the underlying widgets are not owned.</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>The code introduced in Control.WM_CONTEXTMENU to return if the handle does not 
match the wParam prevents the handling of context menus if the underlying 
widgets are not owned/created by the programmer.  In windows if a 
WM_CONTEXTMENU menssage is not processed by a child it propogates up the 
parent tree.  I imagine the code was introduced to prevent this behavior.  
However if the widget in which the message originates is not owned by me(i.e. 
anything that ActiveX components create) I cannot provide any sort of context 
menu because the events don't pass up my way(they do but are ignored at a 
lower level).
I'm not sure how this bug got posted twice.

*** This bug has been marked as a duplicate of 35424 ***</WithStack>
    <WithOutStack>The code introduced in Control.WM_CONTEXTMENU to return if the handle does not 
match the wParam prevents the handling of context menus if the underlying 
widgets are not owned/created by the programmer.  In windows if a 
WM_CONTEXTMENU menssage is not processed by a child it propogates up the 
parent tree.  I imagine the code was introduced to prevent this behavior.  
However if the widget in which the message originates is not owned by me(i.e. 
anything that ActiveX components create) I cannot provide any sort of context 
menu because the events don't pass up my way(they do but are ignored at a 
lower level).
I'm not sure how this bug got posted twice.

*** This bug has been marked as a duplicate of 35424 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35427" />
    <CreationDate amount="2003-03-20 17:51:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="3.2" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="minor" />
    <Summery>[Wizards] Failure to propagate exception due to missing extension id</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>Build: 2.1 RC3

Reported on the newsgroup...

- if you define a "newWizard" whose extension has no "id" attribute, and there
is an exception while initializing your wizard, the error message gets lost. 
This is because the code in UI fails when trying to create a status object using
the ID of the extension.  The Status constructor throws an assertion failure if
you try to create a status with null or empty id.  Here is the guilty code in
WorkbenchWizardNode (line 101):

statuses[0] = 
	new Status(
		IStatus.ERROR, 
wizardElement.getConfigurationElement().getDeclaringExtension().getUniqueIdentifier(),
		IStatus.OK, 
		e.getMessage(), 
		e);	

NOTE: the status constructor argument is supposed to be the plugin Id, not the
extension id (which in many cases people don't bother to provide since it's not
used anywhere else).  I think the correct code would be:

wizardElement.getConfigurationElement().getDeclaringExtension().getDeclaringPluginDescriptor().getUniqueIdentifier()
Is this still an issue in 3.2?
Yep, still an issue.
I'll fix it.
Fix released.
Marking verified</WithStack>
    <WithOutStack>Build: 2.1 RC3

Reported on the newsgroup...

- if you define a "newWizard" whose extension has no "id" attribute, and there
is an exception while initializing your wizard, the error message gets lost. 
This is because the code in UI fails when trying to create a status object using
the ID of the extension.  The Status constructor throws an assertion failure if
you try to create a status with null or empty id.  Here is the guilty code in
WorkbenchWizardNode (line 101):

statuses[0] = 
	new Status(
		IStatus.ERROR, 
wizardElement.getConfigurationElement().getDeclaringExtension().getUniqueIdentifier(),
		IStatus.OK, 
		e.getMessage(), 
		e);	

NOTE: the status constructor argument is supposed to be the plugin Id, not the
extension id (which in many cases people don't bother to provide since it's not
used anywhere else).  I think the correct code would be:

wizardElement.getConfigurationElement().getDeclaringExtension().getDeclaringPluginDescriptor().getUniqueIdentifier()
Is this still an issue in 3.2?
Yep, still an issue.
I'll fix it.
Fix released.
Marking verified</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35428" />
    <CreationDate amount="2003-03-20 18:02:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Source Outline Page does not update properly</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="7">
        <Lines>
          <Line>1. Open a plugin.xml using the manifest editor and switch to the source page.</Line>
          <Line>2. Go to Window-&gt;Preferences-&gt;Plug-in Development.</Line>
          <Line>3. Choose the 'Show plug-in objects using Presentation names' option.  OK.</Line>
          <Line>4. The source outline page does not update. You have to switch to a different</Line>
          <Line>page and come back to the source page for the changes to take effect.</Line>
          <Line>Probably - source outline does not react to preference store property changes</Line>
          <Line>(unlike forms).</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Build: I-20030219
1. Open a plugin.xml using the manifest editor and switch to the source page.
2. Go to Window-&gt;Preferences-&gt;Plug-in Development.
3. Choose the 'Show plug-in objects using Presentation names' option.  OK.
4. The source outline page does not update. You have to switch to a different 
page and come back to the source page for the changes to take effect.
Probably - source outline does not react to preference store property changes 
(unlike forms).

A nice 2.2 defect.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>Build: I-20030219
1. Open a plugin.xml using the manifest editor and switch to the source page.
2. Go to Window-&gt;Preferences-&gt;Plug-in Development.
3. Choose the 'Show plug-in objects using Presentation names' option.  OK.
4. The source outline page does not update. You have to switch to a different 
page and come back to the source page for the changes to take effect.
Probably - source outline does not react to preference store property changes 
(unlike forms).

A nice 2.2 defect.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35429" />
    <CreationDate amount="2003-03-20 18:23:00 -0500" />
    <DupId amount="28343" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P2" />
    <bug_severity amount="major" />
    <Summery>[Wizards] 1 minute wait cursor in New Folder dialog</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>In the Resource perspective, right-click on a nested folder in a Project, 
right-click on a dir node and choose New Folder... The NF dialog opens but the 
wait cursor sits there and makes you wait for a minute or so. I am on a 1+Ghz 
Thinkpad A31 laptop. This happens pretty consistently. Let me know if you need 
more info.

Version: 2.1.0
Build id: 200303071024
Do you have CVS decorations turned on (Window &gt; Preferences &gt; Workbench &gt; 
Label Decorations)?  If so, does the situation improve if you turn them off?
If so, can you try again with the RC3a build?

Also, how many projects do you have in your workspace?
When the wizard finally responds, how many items are shown?

Well, now it's fast, same version. I'll pay attention to this area when I move 
to RC3a and 4. I wonder what could have happened...
So it got faster without you changing any settings?
Was it on the same project/folder?

Yes, I tried it on the same folder that used to be very slow and on a 
different folder in a different project. The dialog becomes responsive right 
away now. The only UI detail I notice is that the folder decorators 
(for 'modified' for example) show up a fraction of time after the normal 
folder icons are displayed. I do not recall what the behavior of decorators 
was when the dialog was slow to respond, sorry.
I suspect this is a dup of a problem we had with decorator slowness in RC2, 
which was fixed for RC3.  Tod, can you please verify?
What could have caused the slowness in the first place?
Yes - this was specifically the case that spawned the reopening on Bug 28343 
that was fixed in RC3. Marking as dup.

*** This bug has been marked as a duplicate of 28343 ***</WithStack>
    <WithOutStack>In the Resource perspective, right-click on a nested folder in a Project, 
right-click on a dir node and choose New Folder... The NF dialog opens but the 
wait cursor sits there and makes you wait for a minute or so. I am on a 1+Ghz 
Thinkpad A31 laptop. This happens pretty consistently. Let me know if you need 
more info.

Version: 2.1.0
Build id: 200303071024
Do you have CVS decorations turned on (Window &gt; Preferences &gt; Workbench &gt; 
Label Decorations)?  If so, does the situation improve if you turn them off?
If so, can you try again with the RC3a build?

Also, how many projects do you have in your workspace?
When the wizard finally responds, how many items are shown?

Well, now it's fast, same version. I'll pay attention to this area when I move 
to RC3a and 4. I wonder what could have happened...
So it got faster without you changing any settings?
Was it on the same project/folder?

Yes, I tried it on the same folder that used to be very slow and on a 
different folder in a different project. The dialog becomes responsive right 
away now. The only UI detail I notice is that the folder decorators 
(for 'modified' for example) show up a fraction of time after the normal 
folder icons are displayed. I do not recall what the behavior of decorators 
was when the dialog was slow to respond, sorry.
I suspect this is a dup of a problem we had with decorator slowness in RC2, 
which was fixed for RC3.  Tod, can you please verify?
What could have caused the slowness in the first place?
Yes - this was specifically the case that spawned the reopening on Bug 28343 
that was fixed in RC3. Marking as dup.

*** This bug has been marked as a duplicate of 28343 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35430" />
    <CreationDate amount="2003-03-20 18:27:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[.properties file editor] list icon disapears on selection</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Double-click on a .properties file to bring up the (nice!) editor. 
Select a key in the LHS.
The icon next to the key disapears.
Select another key, the previously gone icon reapears but the new row's icon 
disapears, etc.
Please indicate the build number in bug reports (available via Help &gt; About).
Which icons are you referring to? I don't see any icons on the left when 
simply opening a .properties file, e.g. the plugin.properties file for 
org.eclipse.ui.
Are they search result match icons?
Could you attach a screen shot?


The properties file editor is contributed by JDT UI.
Gary, about which editor are you talking. As far as I know eclipse doesn't 
have a special properties editor (it is a normal text editor). Do you use some 
sort of third party product.
Ah, somehow I invoked the "Build Properties Editor" (See screenshot). You can 
do this on purpose form the Java Perspective by right-clicking on 
a .properties file and choosing that editor. Just double clicking usually 
opens Notepad or the e text editor. Sorry, I should have been more precise.
Created attachment 4291
Screenshot describing the problem
Editor is PDE/UI.
The icon dissapears because entry goes into the 'edit' mode. If you press 'Esc' 
key, it will get out of the edit mode. You can edit variable and token names 
directly by typing.</WithStack>
    <WithOutStack>Double-click on a .properties file to bring up the (nice!) editor. 
Select a key in the LHS.
The icon next to the key disapears.
Select another key, the previously gone icon reapears but the new row's icon 
disapears, etc.
Please indicate the build number in bug reports (available via Help &gt; About).
Which icons are you referring to? I don't see any icons on the left when 
simply opening a .properties file, e.g. the plugin.properties file for 
org.eclipse.ui.
Are they search result match icons?
Could you attach a screen shot?


The properties file editor is contributed by JDT UI.
Gary, about which editor are you talking. As far as I know eclipse doesn't 
have a special properties editor (it is a normal text editor). Do you use some 
sort of third party product.
Ah, somehow I invoked the "Build Properties Editor" (See screenshot). You can 
do this on purpose form the Java Perspective by right-clicking on 
a .properties file and choosing that editor. Just double clicking usually 
opens Notepad or the e text editor. Sorry, I should have been more precise.
Created attachment 4291
Screenshot describing the problem
Editor is PDE/UI.
The icon dissapears because entry goes into the 'edit' mode. If you press 'Esc' 
key, it will get out of the edit mode. You can edit variable and token names 
directly by typing.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35431" />
    <CreationDate amount="2003-03-20 18:43:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[CVS Core] Hang caused by unstable VPN connection?</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Version: 2.1.0
Build id: 200303071024

My VPN connection to our CVS server goes down from time to time. I connect 
using pserver. This time it hung eclipse, in Windows XP, XP places a "(Not 
Responding)" postfix in the Window and Dialog title bars. E is unresponsive of 
course. 

Here is exactly what happened:

o I created a new sub-folder of an existing versioned folder in a plain 
project.
o I added some text files (no extension) and one jar file in the folder. 
(Please do not ask my a jar file in going into CVS...)
o I selected all of the files in the new folder (not the folder) and choose 
Team-&gt;Add to repository. It did that.
o I de-selected the jar and choose Team-&gt;Change ASCII/Binary and choose 
text/no subs. Click ok.
o My VPN connection went down and XP gave me the option to reconnect now or in 
a minute. I choose to reconnect now.
o After 30 seconds or so eclipse came back and marked my text files with the 
ASCII suffix, good.
o Then I did a Team-&gt;Commit on the new containing directory.
o My VPN connection went down again, I told it to reconnect now.
o Eclipse stayed wedged ("Not Responding"), during which my connection went 
down and up twice again.

I killed e after about 15 minutes.
Get a better service provider?
Ah ah. My internet connection is fine (Cable). It's just the VPN from L.A. to 
our office in the Netherlands that's flaky, sometimes. Other times, it'll stay 
up for 9 hours. Whatever.
This is caused by the same issue of (incorrectly) doing network i/o in UI thread
as reported in 34611.
This bug has not been touched for 2 years. Closing as WONTFIX. Please reopen if 
you feel this is still an important issue.</WithStack>
    <WithOutStack>Version: 2.1.0
Build id: 200303071024

My VPN connection to our CVS server goes down from time to time. I connect 
using pserver. This time it hung eclipse, in Windows XP, XP places a "(Not 
Responding)" postfix in the Window and Dialog title bars. E is unresponsive of 
course. 

Here is exactly what happened:

o I created a new sub-folder of an existing versioned folder in a plain 
project.
o I added some text files (no extension) and one jar file in the folder. 
(Please do not ask my a jar file in going into CVS...)
o I selected all of the files in the new folder (not the folder) and choose 
Team-&gt;Add to repository. It did that.
o I de-selected the jar and choose Team-&gt;Change ASCII/Binary and choose 
text/no subs. Click ok.
o My VPN connection went down and XP gave me the option to reconnect now or in 
a minute. I choose to reconnect now.
o After 30 seconds or so eclipse came back and marked my text files with the 
ASCII suffix, good.
o Then I did a Team-&gt;Commit on the new containing directory.
o My VPN connection went down again, I told it to reconnect now.
o Eclipse stayed wedged ("Not Responding"), during which my connection went 
down and up twice again.

I killed e after about 15 minutes.
Get a better service provider?
Ah ah. My internet connection is fine (Cable). It's just the VPN from L.A. to 
our office in the Netherlands that's flaky, sometimes. Other times, it'll stay 
up for 9 hours. Whatever.
This is caused by the same issue of (incorrectly) doing network i/o in UI thread
as reported in 34611.
This bug has not been touched for 2 years. Closing as WONTFIX. Please reopen if 
you feel this is still an important issue.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35432" />
    <CreationDate amount="2003-03-20 18:49:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>No swtsrc.zip in RC3</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="5">
        <Lines>
          <Line>1) Load up RC3, linux-gtk</Line>
          <Line>2) import all external plugins</Line>
          <Line>3) open up the package explorer</Line>
          <Line>4) open up org.eclipse.swt.gtk</Line>
          <Line>5) look at swt.jar, note that it doesn't have source attached.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>I didn't find a report on this yet, so I'm reporting that there is no swtsrc.zip
in RC3 as far as I can tell (swt-pisrc.zip is there, however).
What a bad bug report, sorry. I looked deeper into it. Here's how to reproduce:

1) Load up RC3, linux-gtk
2) import all external plugins
3) open up the package explorer
4) open up org.eclipse.swt.gtk
5) look at swt.jar, note that it doesn't have source attached.

Here's one of the problems:
the org.eclipse.swt.gtk contains a swt-pisrc.zip, but no swtsrc.zip, however
org.eclipse.platform.linux.gtk.source does contain both. This should probably be
fixed in the build.
This is not an SWT issue.  Moving to PDE.
This regression is still active in the 2.1 release.
Bug was clearly not a stop-ship, and reported too late in the cycle to be 
contained in the 2.1 release.
Fixed now.
Simple workaround is to manually edit the source attachment location of the jar 
and give it the value:
D:/gtk/eclipse/plugins/org.eclipse.platform.linux.gtk.source_2.1.0/src/org.eclip
se.swt.gtk_2.1.0/ws/gtk/swtsrc.zip
if your Eclipse install is at D:/gtk/eclipse</WithStack>
    <WithOutStack>I didn't find a report on this yet, so I'm reporting that there is no swtsrc.zip
in RC3 as far as I can tell (swt-pisrc.zip is there, however).
What a bad bug report, sorry. I looked deeper into it. Here's how to reproduce:

1) Load up RC3, linux-gtk
2) import all external plugins
3) open up the package explorer
4) open up org.eclipse.swt.gtk
5) look at swt.jar, note that it doesn't have source attached.

Here's one of the problems:
the org.eclipse.swt.gtk contains a swt-pisrc.zip, but no swtsrc.zip, however
org.eclipse.platform.linux.gtk.source does contain both. This should probably be
fixed in the build.
This is not an SWT issue.  Moving to PDE.
This regression is still active in the 2.1 release.
Bug was clearly not a stop-ship, and reported too late in the cycle to be 
contained in the 2.1 release.
Fixed now.
Simple workaround is to manually edit the source attachment location of the jar 
and give it the value:
D:/gtk/eclipse/plugins/org.eclipse.platform.linux.gtk.source_2.1.0/src/org.eclip
se.swt.gtk_2.1.0/ws/gtk/swtsrc.zip
if your Eclipse install is at D:/gtk/eclipse</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35433" />
    <CreationDate amount="2003-03-20 18:55:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Simple Feature Request - Code Formatter Enhancement</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="2">
      <source_code type="functioncall">
        <location start="173" end="195" />
        <code>functionName (params);</code>
      </source_code>
      <source_code type="functioncall">
        <location start="209" end="230" />
        <code>functionName(params);</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>Eclipse Dev Team,

    For Preferences/Java/Code Formatter, would it be possible to have the
options "Insert space before parenthesis always"?  I personally use the
style:

functionName (params);

instead of

functionName(params);

    I use this style because it spaces things out and keeps space-beginning
parenthesis use consistent with the if, for, and the while constructs, e.g.

for (init; condition; increment) statement

not

for(init; condition; increment)

Cheers,

Nicholaus
Formatter is JDT/Core
Formatter issues will be reconsidered post 2.1
Resurrecting for 3.0
Reopen for 3.0 consideration.
This is addressed in the new formatter.
Fixed and released in HEAD.
Regression test added.
Verified.</WithStack>
    <WithOutStack>Eclipse Dev Team,

    For Preferences/Java/Code Formatter, would it be possible to have the
options "Insert space before parenthesis always"?  I personally use the
style:

functionName (params);

instead of

functionName(params);

    I use this style because it spaces things out and keeps space-beginning
parenthesis use consistent with the if, for, and the while constructs, e.g.

for (init; condition; increment) statement

not

for(init; condition; increment)

Cheers,

Nicholaus
Formatter is JDT/Core
Formatter issues will be reconsidered post 2.1
Resurrecting for 3.0
Reopen for 3.0 consideration.
This is addressed in the new formatter.
Fixed and released in HEAD.
Regression test added.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35434" />
    <CreationDate amount="2003-03-20 19:13:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-Motif" />
    <priority amount="P2" />
    <bug_severity amount="blocker" />
    <Summery>[Motif] GC.getFontMetrics() causes VM to crash when font is really small.</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="5">
      <source_code type="import">
        <location start="2866" end="2896" />
        <code>import org.eclipse.swt.SWT;</code>
      </source_code>
      <source_code type="import">
        <location start="2897" end="2931" />
        <code>import org.eclipse.swt.graphics.*;</code>
      </source_code>
      <source_code type="import">
        <location start="2932" end="2973" />
        <code>import org.eclipse.swt.layout.FillLayout;</code>
      </source_code>
      <source_code type="import">
        <location start="2974" end="3007" />
        <code>import org.eclipse.swt.widgets.*;</code>
      </source_code>
      <source_code type="class">
        <location start="3009" end="3512" />
        <code>public class FontTest {

public static void main(String[] args) {
	Shell shell = new Shell();
	shell.setLayout(new FillLayout());
	
	Canvas canvas = new Canvas(shell, SWT.NONE);
	GC gc = new GC(canvas);
	FontData data = gc.getFont().getFontData()[0];
	data.setHeight(2);
	Font f = new Font(Display.getDefault(), data);
	gc.setFont(f);
	gc.getFontMetrics();
		
	shell.open();
	Display display = Display.getDefault();
	while (!shell.isDisposed())
		if (!display.readAndDispatch())
			display.sleep();
}

}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>In Motif, with a very small font (height ~= 2), GC.getFontMetrics() causes the
VM to crash (stack trace below).  I debugged this method and found that
OS.memmove() is being called with src = 0 because the XFontStruct.per_char = 0.
 GTK and Windows don't seem to be affected.




An unexpected exception has been detected in native code outside the VM.
Unexpected Signal : 11 occurred at PC=0x4207BDE5
Function=memmove+0x35
Library=/usr/java/j2sdk1.4.1_02/bin/java

Current Java thread:
	at org.eclipse.swt.internal.motif.OS.memmove(Native Method)
	at org.eclipse.swt.graphics.GC.getFontMetrics(GC.java:1939)
	at org.eclipse.draw2d.SWTGraphics.getFontMetrics(SWTGraphics.java:278)
	at org.eclipse.draw2d.ScaledGraphics.zoomTextPoint(ScaledGraphics.java:426)
	at org.eclipse.draw2d.ScaledGraphics.drawText(ScaledGraphics.java:239)
	at org.eclipse.draw2d.Graphics.drawText(Graphics.java:107)
	at org.eclipse.draw2d.Label.paintFigure(Label.java:445)
	at org.eclipse.draw2d.Figure.paint(Figure.java:921)
	at org.eclipse.draw2d.Figure.paintChildren(Figure.java:959)
	at org.eclipse.draw2d.Figure.paintClientArea(Figure.java:993)
	at org.eclipse.draw2d.Figure.paint(Figure.java:923)
	at org.eclipse.draw2d.Figure.paintChildren(Figure.java:959)
	at org.eclipse.draw2d.Figure.paintClientArea(Figure.java:989)
	at org.eclipse.draw2d.Figure.paint(Figure.java:923)
	at org.eclipse.draw2d.Figure.paintChildren(Figure.java:959)
	at org.eclipse.draw2d.Figure.paintClientArea(Figure.java:989)
	at org.eclipse.draw2d.Figure.paint(Figure.java:923)
	at org.eclipse.draw2d.parts.Thumbnail$ThumbnailUpdater.run(Thumbnail.java:157)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)
	- locked &lt;0x44405e28&gt; (a org.eclipse.swt.widgets.RunnableLock)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1940)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1731)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
	at
org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
	at org.eclipse.core.launcher.Main.run(Main.java:747)
	at org.eclipse.core.launcher.Main.main(Main.java:583)
Eric- can we provide a test snippet?
Here's a simple test case.  If you set the FontData's height to 2 (as below),
the VM crashes.  Set it to 3 and all is well.



import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.*;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.*;

public class FontTest {

public static void main(String[] args) {
	Shell shell = new Shell();
	shell.setLayout(new FillLayout());
	
	Canvas canvas = new Canvas(shell, SWT.NONE);
	GC gc = new GC(canvas);
	FontData data = gc.getFont().getFontData()[0];
	data.setHeight(2);
	Font f = new Font(Display.getDefault(), data);
	gc.setFont(f);
	gc.getFontMetrics();
		
	shell.open();
	Display display = Display.getDefault();
	while (!shell.isDisposed())
		if (!display.readAndDispatch())
			display.sleep();
}

}

This was found on both RC3 and RC3a.
Thank you for the detailed information and the snippet.  Assigning to Grant.  
Although the occurence of this condition should be quite low, we should 
consider this for 2.1 if the fix is quite safe.
The occurence is not low for GEF.  It happens regularly as part of our Overview 
window, which scales everything that is being painted.

If we knew that this was limited to a certain size, such as 2 or smaller, we 
could probably put in a check.  But currently we don't understand what causes 
the error.
An XFontStruct with per_char = 0 is a valid case; it means that all glyphs in 
the set have the same width as the XFontStruct (so in our specific case, the 
font struct's max_bounds_width).  I'm not sure which fonts this will be the 
case for, but it may not just be ones with size = 2.  We should handle this 
case in general.

The fix seems pretty easy: detect the per_char = 0 case and if it happens then 
don't do the averaging dance, instead take the font struct's max_bounds_width 
as is.  Adding Veronika to CC to see if this can be released for 2.1.

Requesting approval from KH + NE for submission in 2.1.
Danger assessment: should not be dangerous since the worst that can happen is 
we'll compute the average character width to be the max width of the font 
struct, which is the expected result anyways

Adding McQ too...
I believe we need to handle this case. Approved by McQ.
+1
Released the fix to GC.getFontMetrics() in 2 places.  So this will be in this 
afternoon's 2:00p build.  Checked by Silenio, reviewed with Steve and Felipe.  
This fixes the provided test snippet.

However, note that I found 8 other occurrences of this problem in GC: 4 in 
getAdvanceWidth() and 4 in getCharWidth().  Given the late stage we do not plan 
to address these occurrences until after 2.1, unless they're also causing 
GP's.  Eric/Randy, does GEF use either of these other GC methods in a context 
similar to what caused the GC.getFontMetrics() problem?

Go ahead and release the fix (SN + MCQ + KH = 3TL's).  Mark this PR as closed 
but open another one, assigned to GG to remind you to fix the other places in 
the code.  Thanks.
Released, logged bug 35588.

GEF doesn't call getAdvanceWidth() or getCharWidth(), so we should be fine.  Thanks.</WithStack>
    <WithOutStack>In Motif, with a very small font (height ~= 2), GC.getFontMetrics() causes the
VM to crash (stack trace below).  I debugged this method and found that
OS.memmove() is being called with src = 0 because the XFontStruct.per_char = 0.
 GTK and Windows don't seem to be affected.




An unexpected exception has been detected in native code outside the VM.
Unexpected Signal : 11 occurred at PC=0x4207BDE5
Function=memmove+0x35
Library=/usr/java/j2sdk1.4.1_02/bin/java

Current Java thread:
	at org.eclipse.swt.internal.motif.OS.memmove(Native Method)
	at org.eclipse.swt.graphics.GC.getFontMetrics(GC.java:1939)
	at org.eclipse.draw2d.SWTGraphics.getFontMetrics(SWTGraphics.java:278)
	at org.eclipse.draw2d.ScaledGraphics.zoomTextPoint(ScaledGraphics.java:426)
	at org.eclipse.draw2d.ScaledGraphics.drawText(ScaledGraphics.java:239)
	at org.eclipse.draw2d.Graphics.drawText(Graphics.java:107)
	at org.eclipse.draw2d.Label.paintFigure(Label.java:445)
	at org.eclipse.draw2d.Figure.paint(Figure.java:921)
	at org.eclipse.draw2d.Figure.paintChildren(Figure.java:959)
	at org.eclipse.draw2d.Figure.paintClientArea(Figure.java:993)
	at org.eclipse.draw2d.Figure.paint(Figure.java:923)
	at org.eclipse.draw2d.Figure.paintChildren(Figure.java:959)
	at org.eclipse.draw2d.Figure.paintClientArea(Figure.java:989)
	at org.eclipse.draw2d.Figure.paint(Figure.java:923)
	at org.eclipse.draw2d.Figure.paintChildren(Figure.java:959)
	at org.eclipse.draw2d.Figure.paintClientArea(Figure.java:989)
	at org.eclipse.draw2d.Figure.paint(Figure.java:923)
	at org.eclipse.draw2d.parts.Thumbnail$ThumbnailUpdater.run(Thumbnail.java:157)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)
	- locked &lt;0x44405e28&gt; (a org.eclipse.swt.widgets.RunnableLock)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1940)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1731)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
	at
org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
	at org.eclipse.core.launcher.Main.run(Main.java:747)
	at org.eclipse.core.launcher.Main.main(Main.java:583)
Eric- can we provide a test snippet?
Here's a simple test case.  If you set the FontData's height to 2 (as below),
the VM crashes.  Set it to 3 and all is well.



import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.*;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.*;

public class FontTest {

public static void main(String[] args) {
	Shell shell = new Shell();
	shell.setLayout(new FillLayout());
	
	Canvas canvas = new Canvas(shell, SWT.NONE);
	GC gc = new GC(canvas);
	FontData data = gc.getFont().getFontData()[0];
	data.setHeight(2);
	Font f = new Font(Display.getDefault(), data);
	gc.setFont(f);
	gc.getFontMetrics();
		
	shell.open();
	Display display = Display.getDefault();
	while (!shell.isDisposed())
		if (!display.readAndDispatch())
			display.sleep();
}

}

This was found on both RC3 and RC3a.
Thank you for the detailed information and the snippet.  Assigning to Grant.  
Although the occurence of this condition should be quite low, we should 
consider this for 2.1 if the fix is quite safe.
The occurence is not low for GEF.  It happens regularly as part of our Overview 
window, which scales everything that is being painted.

If we knew that this was limited to a certain size, such as 2 or smaller, we 
could probably put in a check.  But currently we don't understand what causes 
the error.
An XFontStruct with per_char = 0 is a valid case; it means that all glyphs in 
the set have the same width as the XFontStruct (so in our specific case, the 
font struct's max_bounds_width).  I'm not sure which fonts this will be the 
case for, but it may not just be ones with size = 2.  We should handle this 
case in general.

The fix seems pretty easy: detect the per_char = 0 case and if it happens then 
don't do the averaging dance, instead take the font struct's max_bounds_width 
as is.  Adding Veronika to CC to see if this can be released for 2.1.

Requesting approval from KH + NE for submission in 2.1.
Danger assessment: should not be dangerous since the worst that can happen is 
we'll compute the average character width to be the max width of the font 
struct, which is the expected result anyways

Adding McQ too...
I believe we need to handle this case. Approved by McQ.
+1
Released the fix to GC.getFontMetrics() in 2 places.  So this will be in this 
afternoon's 2:00p build.  Checked by Silenio, reviewed with Steve and Felipe.  
This fixes the provided test snippet.

However, note that I found 8 other occurrences of this problem in GC: 4 in 
getAdvanceWidth() and 4 in getCharWidth().  Given the late stage we do not plan 
to address these occurrences until after 2.1, unless they're also causing 
GP's.  Eric/Randy, does GEF use either of these other GC methods in a context 
similar to what caused the GC.getFontMetrics() problem?

Go ahead and release the fix (SN + MCQ + KH = 3TL's).  Mark this PR as closed 
but open another one, assigned to GG to remind you to fix the other places in 
the code.  Thanks.
Released, logged bug 35588.

GEF doesn't call getAdvanceWidth() or getCharWidth(), so we should be fine.  Thanks.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35435" />
    <CreationDate amount="2003-03-20 19:17:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="Other" />
    <op_sys amount="HP-UX" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Styled Text example missing from SWT Controls</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="9">
        <Lines>
          <Line>1. make sure that the Eclipse examples package has been installed</Line>
          <Line />
          <Line>2. Start Eclipse, and use Window-&gt;Show View-&gt;Other to select SWT Examples-&gt;SWT</Line>
          <Line>Controls.</Line>
          <Line />
          <Line>3. Double-click on the SWT Controls title bar to maximize it.</Line>
          <Line />
          <Line>4. Click on the "Text" tab. !BUG! Note that the "Styled Text" and "Styled Text</Line>
          <Line>Styles" boxes are missing.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="CLOSED" />
    <resolution amount="WONTFIX" />
    <WithStack>Problem Description:
The "Styled Text" box is missing from the Text tab of the SWT Controls view 
(from the examples archive). Only the "Text" box is present. The "Styled Text 
Styles" box is also missing.

Steps to reproduce:
1. make sure that the Eclipse examples package has been installed

2. Start Eclipse, and use Window-&gt;Show View-&gt;Other to select SWT Examples-&gt;SWT 
Controls.

3. Double-click on the SWT Controls title bar to maximize it.

4. Click on the "Text" tab. !BUG! Note that the "Styled Text" and "Styled Text 
Styles" boxes are missing.

Found in:
OS: HP-UX 11.11, Eclipse V2.1 Build ID: 200303192032 (RC3)
It has been moved to the CustomControlsExample.
Right-o</WithStack>
    <WithOutStack>Problem Description:
The "Styled Text" box is missing from the Text tab of the SWT Controls view 
(from the examples archive). Only the "Text" box is present. The "Styled Text 
Styles" box is also missing.

Steps to reproduce:
1. make sure that the Eclipse examples package has been installed

2. Start Eclipse, and use Window-&gt;Show View-&gt;Other to select SWT Examples-&gt;SWT 
Controls.

3. Double-click on the SWT Controls title bar to maximize it.

4. Click on the "Text" tab. !BUG! Note that the "Styled Text" and "Styled Text 
Styles" boxes are missing.

Found in:
OS: HP-UX 11.11, Eclipse V2.1 Build ID: 200303192032 (RC3)
It has been moved to the CustomControlsExample.
Right-o</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35436" />
    <CreationDate amount="2003-03-20 21:02:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Automated tests cannot prompt</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="3">
      <source_code type="multicomment">
        <location start="2160" end="2562" />
        <code>/**
 * Registers the status handler for the given status, replacing any existing
 * status handler. When set to &lt;code&gt;null&lt;/code&gt;, any existing status handler
 * is removed.
 * 
 * @param pluginIdentifier unique identifier of the plug-in the status handler
 *   is registering for
 * @param code status code
 * @param statusHandler the status handler to register or &lt;code&gt;null&lt;/code&gt;
 * @since 2.1
 */</code>
      </source_code>
      <source_code type="assignment">
        <location start="3449" end="3484" />
        <code>ErrorDialog.AUTOMATED_MODE = true;</code>
      </source_code>
      <source_code type="functioncall">
        <location start="3485" end="3521" />
        <code>SafeRunnable.setIgnoreErrors(true);</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>RC3

While running the jdt debug automated tests, I occasionally see Timeout/Retry 
messages.  I also have seen internal errors.  There needs to be an unattended 
mode option that keeps these messages from being presented to the user (and 
requesting feedback).  

This looks like it requires a change in the debugger to handle the timeout 
message and to the workbench for the internal error.  
(Hypothesis: it looks like we need an unattendedMode state in the Workbench.)
There are two main places where the workbench can bring up an error dialog.

When we invoke code from other plugins, we wrap that call in a Platform.run
(ISafeRunnable).
We have a default implementation in org.eclipse.jface.util.SafeRunnable whose 
handleException method brings up a MessageDialog.  This can be disabled using 
SafeRunnable.setIgnoreErrors(true).  The error is still logged by core, but no 
dialog is brought up.  

I thought we were setting this in the test harness, e.g. in UITestApplication.  
We added the flag for exactly this purpose, but I can no longer find any 
references even with org.eclipse.test loaded.

A dialog can also be brought up in our event loop error handler.
JFace lets you specify an error handler for uncaught exceptions and errors that 
occur when spinning the event loop.  See Window.setExceptionHandler.  The 
default JFace one just prints a stack trace to the console.  The Workbench sets 
another one, defined in org.eclipse.ui.internal.ExceptionHandler, which gives 
the error dialog we often see.
Currently this is not replaced by the test harness either, but it probably 
should be.



The workbench should have a single "test mode" flag, so that it can set up the 
various error handlers appropriately.

I believe the simplest fix will be to add an API to the Debug plug-in to set a 
status handler, for an IStatus. Currently, the "prompter" causing trouble in 
the debugger, is a status hanlder registered for the connect timeout. By 
allowing clients to set a status hanlder programmatically, we could have the 
test suite provide it's own handler, or "null out" the exising handler.
I have added (proposed) API to the DebugPlugin:

/**
 * Registers the status handler for the given status, replacing any existing
 * status handler. When set to &lt;code&gt;null&lt;/code&gt;, any existing status handler
 * is removed.
 * 
 * @param pluginIdentifier unique identifier of the plug-in the status handler
 *   is registering for
 * @param code status code
 * @param statusHandler the status handler to register or &lt;code&gt;null&lt;/code&gt;
 * @since 2.1
 */
public void setStatusHandler(String pluginIdentifier, int code, IStatusHandler 
statusHandler) {...}

The test suite simple replaces the known status handlers with null handlers, 
except for the "connection timeout" handler, which is replaced with a handler 
that attempts to re-connect a maximum of five times before giving up.
Marking as RC4 candidate. Awaiting approval from John W for suggested fix.
Risk is low: The new API is on DebugPlugin is only used by the test suite.
+1
+1
+1
This is worth fixing, but it is important that we try to understand the 
failures.  Dean, Jed, and I are trying to get more insight into why the 
failures are occurring (and hopefully this will help with the fix)
Removing RC4 tag. No changes planned for 2.1. The test suite failures appear to 
be associated with rshell.
I have updated the test suite to set the following before each test is run:

	ErrorDialog.AUTOMATED_MODE = true;
	SafeRunnable.setIgnoreErrors(true);

This should prevent the tests from opening error dialogs which hang the 
workbench.
Sonia concurrs that the debug tests have not caused their famed "hang" in the 
last couple of nightly builds. Marking as fixed.
Marking as verified.</WithStack>
    <WithOutStack>RC3

While running the jdt debug automated tests, I occasionally see Timeout/Retry 
messages.  I also have seen internal errors.  There needs to be an unattended 
mode option that keeps these messages from being presented to the user (and 
requesting feedback).  

This looks like it requires a change in the debugger to handle the timeout 
message and to the workbench for the internal error.  
(Hypothesis: it looks like we need an unattendedMode state in the Workbench.)
There are two main places where the workbench can bring up an error dialog.

When we invoke code from other plugins, we wrap that call in a Platform.run
(ISafeRunnable).
We have a default implementation in org.eclipse.jface.util.SafeRunnable whose 
handleException method brings up a MessageDialog.  This can be disabled using 
SafeRunnable.setIgnoreErrors(true).  The error is still logged by core, but no 
dialog is brought up.  

I thought we were setting this in the test harness, e.g. in UITestApplication.  
We added the flag for exactly this purpose, but I can no longer find any 
references even with org.eclipse.test loaded.

A dialog can also be brought up in our event loop error handler.
JFace lets you specify an error handler for uncaught exceptions and errors that 
occur when spinning the event loop.  See Window.setExceptionHandler.  The 
default JFace one just prints a stack trace to the console.  The Workbench sets 
another one, defined in org.eclipse.ui.internal.ExceptionHandler, which gives 
the error dialog we often see.
Currently this is not replaced by the test harness either, but it probably 
should be.



The workbench should have a single "test mode" flag, so that it can set up the 
various error handlers appropriately.

I believe the simplest fix will be to add an API to the Debug plug-in to set a 
status handler, for an IStatus. Currently, the "prompter" causing trouble in 
the debugger, is a status hanlder registered for the connect timeout. By 
allowing clients to set a status hanlder programmatically, we could have the 
test suite provide it's own handler, or "null out" the exising handler.
I have added (proposed) API to the DebugPlugin:

/**
 * Registers the status handler for the given status, replacing any existing
 * status handler. When set to &lt;code&gt;null&lt;/code&gt;, any existing status handler
 * is removed.
 * 
 * @param pluginIdentifier unique identifier of the plug-in the status handler
 *   is registering for
 * @param code status code
 * @param statusHandler the status handler to register or &lt;code&gt;null&lt;/code&gt;
 * @since 2.1
 */
public void setStatusHandler(String pluginIdentifier, int code, IStatusHandler 
statusHandler) {...}

The test suite simple replaces the known status handlers with null handlers, 
except for the "connection timeout" handler, which is replaced with a handler 
that attempts to re-connect a maximum of five times before giving up.
Marking as RC4 candidate. Awaiting approval from John W for suggested fix.
Risk is low: The new API is on DebugPlugin is only used by the test suite.
+1
+1
+1
This is worth fixing, but it is important that we try to understand the 
failures.  Dean, Jed, and I are trying to get more insight into why the 
failures are occurring (and hopefully this will help with the fix)
Removing RC4 tag. No changes planned for 2.1. The test suite failures appear to 
be associated with rshell.
I have updated the test suite to set the following before each test is run:

	ErrorDialog.AUTOMATED_MODE = true;
	SafeRunnable.setIgnoreErrors(true);

This should prevent the tests from opening error dialogs which hang the 
workbench.
Sonia concurrs that the debug tests have not caused their famed "hang" in the 
last couple of nightly builds. Marking as fixed.
Marking as verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35437" />
    <CreationDate amount="2003-03-20 21:08:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>can't call protected methods from derived classes in other pkg</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="6">
      <source_code type="package">
        <location start="145" end="174" />
        <code>package javaoverview.methods;</code>
      </source_code>
      <source_code type="class">
        <location start="176" end="338" />
        <code>public class MethodAccessibilityBase
{   
    protected void protectedMethod ()
    {
        System.out.println ("Can be invoked by subclasses");        
    }
}</code>
      </source_code>
      <source_code type="package">
        <location start="351" end="395" />
        <code>package javaoverview.methods.anotherpackage;</code>
      </source_code>
      <source_code type="import">
        <location start="396" end="449" />
        <code>import javaoverview.methods.MethodAccessibilityBase;</code>
      </source_code>
      <source_code type="functioncall">
        <location start="658" end="661" />
        <code>();</code>
      </source_code>
      <source_code type="functioncall">
        <location start="662" end="706" />
        <code>lClassToCallMethodOn.protectedMethod();</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>(RC2) Eclipse will throw a compilation error when you try to invoke a protected 
method from a derived class in another pkg.

i.e. Base Class = 
package javaoverview.methods;

public class MethodAccessibilityBase
{   
    protected void protectedMethod ()
    {
        System.out.println ("Can be invoked by subclasses");        
    }
}

Derived = 
package javaoverview.methods.anotherpackage;

import javaoverview.methods.MethodAccessibilityBase;

public class MethodAccessibilityDerivedAnotherPackage extends 
MethodAccessibilityBase
{
    public void invokeMethods()
    {
     MethodAccessibilityBase lClassToCallMethodOn = new MethodAccessibilityBase
();
     lClassToCallMethodOn.protectedMethod();
    }
}
Whoops, guess I should doublecheck my work, and not submit bug reports when I 
am up for 20 hours straight... Sorry
Set milestone.</WithStack>
    <WithOutStack>(RC2) Eclipse will throw a compilation error when you try to invoke a protected 
method from a derived class in another pkg.

i.e. Base Class = 
package javaoverview.methods;

public class MethodAccessibilityBase
{   
    protected void protectedMethod ()
    {
        System.out.println ("Can be invoked by subclasses");        
    }
}

Derived = 
package javaoverview.methods.anotherpackage;

import javaoverview.methods.MethodAccessibilityBase;

public class MethodAccessibilityDerivedAnotherPackage extends 
MethodAccessibilityBase
{
    public void invokeMethods()
    {
     MethodAccessibilityBase lClassToCallMethodOn = new MethodAccessibilityBase
();
     lClassToCallMethodOn.protectedMethod();
    }
}
Whoops, guess I should doublecheck my work, and not submit bug reports when I 
am up for 20 hours straight... Sorry
Set milestone.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35438" />
    <CreationDate amount="2003-03-20 23:28:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>CastExpression resolution departs from JLS section 6.5.1</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="class">
        <location start="63" end="308" />
        <code>public class Flitsch {

    public static float BRATSCH = 42;
    public static class BRATSCH {
    }
    
    public Object o;
    
    public void sozzle() {
        Flitsch.BRATSCH = 43;
        Flitsch.BRATSCH b = (Flitsch.BRATSCH)o;
    }
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>2.1.0-RC3 200303192032; problem persists from earlier builds.

public class Flitsch {

    public static float BRATSCH = 42;
    public static class BRATSCH {
    }
    
    public Object o;
    
    public void sozzle() {
        Flitsch.BRATSCH = 43;
        Flitsch.BRATSCH b = (Flitsch.BRATSCH)o;
    }
}

In this code, the cast will be squiggled with the message "Flitsch.BRATSCH
cannot be resolved." None of the other occurrences of Flitsch.BRATSCH will be
squiggled, so the compiler is able to disambiguate the type from the field in
other contexts, but not in a CastExpression. javac accepts the code.

JLS section 6.5.1 provides: A name is syntactically classified as a TypeName in
these contexts:
...
As the type mentioned in the cast operator of a cast expression (15.16)
...

Interestingly, if the unqualified typename is used in the cast, Flitsch.BRATSCH
b = (BRATSCH)o, it is accepted. Only the qualified form gives trouble.
Reproduced. Indeed, this is a bug.
Created attachment 4278
patch for BlockScope
Kent - pls verify patch
In this particular case, a workaround is to not qualify, however in general, 
when accessing from some external code, this isn't possible.

However, this isn't a new bug.
Not critical for 2.1
Thanks for the quick patch! I'll give it a try.

I'm not sure I understand the last couple of comments. If this is not a new bug,
is it an old bug?  I did search first, but I didn't find it. Sorry if I missed it.

As you point out, the workaround of using an unqualified name is not feasible in
the general case.  Also, as you would guess, the problem is most likely to be
apparent in generated code, where the member names are constrained by some
external design requirement; otherwise one would just use different names and
never see the problem.

That means in the practical situations where this bug is likely to bite, there
may be no really practical workaround--one that doesn't require redesign of a
code generator and a number of related components.
By old bug, I meant it isn't a recent regression but rather a long standing bug.
I agree this isn't trivial to workaround, but since we are in strict release 
mode (see Eclipse end game plan), only stop ship bugs are to be addressed at 
this stage.

Such a collision scenario isn't very frequent to make it critical (we had it 
wrong in 2.0 as well, and nobody noticed until today).
Patch looks good.
Defer
Reopening
Fixed
Backported to 2.1 maintenance stream.
Fixed in 2.2 stream as well.
Verified.
Verified in 3.0M1</WithStack>
    <WithOutStack>2.1.0-RC3 200303192032; problem persists from earlier builds.

public class Flitsch {

    public static float BRATSCH = 42;
    public static class BRATSCH {
    }
    
    public Object o;
    
    public void sozzle() {
        Flitsch.BRATSCH = 43;
        Flitsch.BRATSCH b = (Flitsch.BRATSCH)o;
    }
}

In this code, the cast will be squiggled with the message "Flitsch.BRATSCH
cannot be resolved." None of the other occurrences of Flitsch.BRATSCH will be
squiggled, so the compiler is able to disambiguate the type from the field in
other contexts, but not in a CastExpression. javac accepts the code.

JLS section 6.5.1 provides: A name is syntactically classified as a TypeName in
these contexts:
...
As the type mentioned in the cast operator of a cast expression (15.16)
...

Interestingly, if the unqualified typename is used in the cast, Flitsch.BRATSCH
b = (BRATSCH)o, it is accepted. Only the qualified form gives trouble.
Reproduced. Indeed, this is a bug.
Created attachment 4278
patch for BlockScope
Kent - pls verify patch
In this particular case, a workaround is to not qualify, however in general, 
when accessing from some external code, this isn't possible.

However, this isn't a new bug.
Not critical for 2.1
Thanks for the quick patch! I'll give it a try.

I'm not sure I understand the last couple of comments. If this is not a new bug,
is it an old bug?  I did search first, but I didn't find it. Sorry if I missed it.

As you point out, the workaround of using an unqualified name is not feasible in
the general case.  Also, as you would guess, the problem is most likely to be
apparent in generated code, where the member names are constrained by some
external design requirement; otherwise one would just use different names and
never see the problem.

That means in the practical situations where this bug is likely to bite, there
may be no really practical workaround--one that doesn't require redesign of a
code generator and a number of related components.
By old bug, I meant it isn't a recent regression but rather a long standing bug.
I agree this isn't trivial to workaround, but since we are in strict release 
mode (see Eclipse end game plan), only stop ship bugs are to be addressed at 
this stage.

Such a collision scenario isn't very frequent to make it critical (we had it 
wrong in 2.0 as well, and nobody noticed until today).
Patch looks good.
Defer
Reopening
Fixed
Backported to 2.1 maintenance stream.
Fixed in 2.2 stream as well.
Verified.
Verified in 3.0M1</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35439" />
    <CreationDate amount="2003-03-20 23:37:00 -0500" />
    <DupId amount="35440" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="major" />
    <Summery>RC3 creates classpath cycles importing fragments</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="2">
      <Enumeration lines="9">
        <Lines>
          <Line>1. import as binary with linking</Line>
          <Line>2. import as binary without linking</Line>
          <Line>3. import with source.</Line>
          <Line>My development environment is Eclipse 2.1, and target environment is</Line>
          <Line>internal WSAD V5.x build which use WSWB 2.1 official release as base.</Line>
          <Line>What I did:</Line>
          <Line>1. File-&gt;import</Line>
          <Line>2. External plugins and fragments</Line>
          <Line>3. In the wizard, I chose my target env. path as a "plugin location".</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="3">
        <Lines>
          <Line>1. File-&gt;import</Line>
          <Line>2. External plugins and fragments</Line>
          <Line>3. In the wizard, I chose my target env. path as a "plugin location".</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>When you use RC3 to import a plugins that contain both plugins and nl 
fragments, it creates projects that fail to compile because they all have 
classpath cycles.
This only happens when you import with source, and is OK. What you need to do 
is turn the cycle warning off and rebuild until all the errors are gone. Cycles 
are caused by plug-ins and fragments cross-referencing each other, which is 
necessary in order to simulate run-time situation.

At run-time, a fragment references a plug-in and can 'see' all the classes in 
the plug-in. At the same time, libraries that belong to the fragment are added 
to the list of libraries of the plug-in during the registry resolution phase. 
Therefore, plug-in 'sees' all the classes of its fragments. This kind of cross-
reference causes cycles when modeled by PDE at compile time.

Wassim, did I make sense here?
I did not import with source but maybe this is related to the other defect that 
I opened where the project is added as a source container when it shouldn't.  I 
tried changing the cycle warning off but I stopped the compile before it 
finished because it was over 10,000 compile errors.  This same target imports 
and builds fine with RC1 and all past drivers.


*** This bug has been marked as a duplicate of 35440 ***
I'm still getting the same error with official Eclipse 2.1.
Please be more specific as to what plug-ins you were trying to import, so that 
I would be able to reproduce the problem.
any eclipse's nl1 plugins or WSAD's nl plugins.
I just imported the following plug-ins into my workspace from WSADIE 5 without 
error or classpath cycles:
com.ibm.etools.ctc.bind.http.ui and its nl1 fragment
com.ibm.etools.emf.mapping.ui and its nl1 fragment
org.eclipse.pde.ui and its nl1 fragment.

Could you please be more specific as to which specific plug-ins you are 
importing.
I just imported "org.eclipse.pde.ui" plugin and required plugins,
then I got:

Kind	Status	Priority	Description	Resource	In Folder
	Location
Error			A cycle was detected in the classpath of project: 
org.apache.ant	org.apache.ant		Build path
Error			A cycle was detected in the classpath of project: 
org.apache.lucene	org.apache.lucene		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ant.core	org.eclipse.ant.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ant.core.nl1	org.eclipse.ant.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.compare	org.eclipse.compare		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.compare.nl1	org.eclipse.compare.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.boot.nl1	org.eclipse.core.boot.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.resources	org.eclipse.core.resources		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.resources.nl1	org.eclipse.core.resources.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.runtime	org.eclipse.core.runtime		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.runtime.nl1	org.eclipse.core.runtime.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.debug.core	org.eclipse.debug.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.debug.core.nl1	org.eclipse.debug.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.debug.ui	org.eclipse.debug.ui		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.debug.ui.nl1	org.eclipse.debug.ui.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.help	org.eclipse.help		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.help.appserver	org.eclipse.help.appserver		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.help.nl1	org.eclipse.help.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.core	org.eclipse.jdt.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.core.nl1	org.eclipse.jdt.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.debug	org.eclipse.jdt.debug		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.debug.nl1	org.eclipse.jdt.debug.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.debug.ui	org.eclipse.jdt.debug.ui		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.debug.ui.nl1	org.eclipse.jdt.debug.ui.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.launching	org.eclipse.jdt.launching		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.launching.nl1	org.eclipse.jdt.launching.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.ui	org.eclipse.jdt.ui		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.ui.nl1	org.eclipse.jdt.ui.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jface	org.eclipse.jface		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jface.text	org.eclipse.jface.text		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde	org.eclipse.pde		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.build	org.eclipse.pde.build		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.build.nl1	org.eclipse.pde.build.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.core	org.eclipse.pde.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.core.nl1	org.eclipse.pde.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.nl1	org.eclipse.pde.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.ui	org.eclipse.pde.ui		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.ui.nl1	org.eclipse.pde.ui.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.search	org.eclipse.search		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.search.nl1	org.eclipse.search.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.swt	org.eclipse.swt		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.swt.nl1	org.eclipse.swt.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.team.core	org.eclipse.team.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.team.core.nl1	org.eclipse.team.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.text	org.eclipse.text		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui	org.eclipse.ui		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.editors	org.eclipse.ui.editors		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.nl1	org.eclipse.ui.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.views	org.eclipse.ui.views		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.win32	org.eclipse.ui.win32		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.workbench	org.eclipse.ui.workbench		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.workbench.texteditor	org.eclipse.ui.workbench.texteditor
		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.update.core	org.eclipse.update.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.update.core.nl1	org.eclipse.update.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.update.ui.forms	org.eclipse.update.ui.forms		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.update.ui.forms.nl1	org.eclipse.update.ui.forms.nl1		Build 
path
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.apache.ant		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.apache.lucene		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ant.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ant.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.compare		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.compare.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.boot.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.resources	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.resources.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.runtime	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.runtime.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.debug.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.debug.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.debug.ui		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.debug.ui.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.help		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.help.appserver	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.help.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.debug		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.debug.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.debug.ui	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.debug.ui.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.launching	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.launching.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.ui		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.ui.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jface		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jface.text		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.build		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.build.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.ui		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.ui.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.search		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.search.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.swt		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.swt.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.team.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.team.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.text		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.editors		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.views		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.win32		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.workbench	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.workbench.texteditor
		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.update.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.update.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.update.ui.forms	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.update.ui.forms.nl1	
	

Using Eclipse 2.1 as development environment and WSADIE 5.0 GA as target 
platform on a fresh workspace, I was able to import org.eclipse.pde.ui and all 
its required plug-ins/fragments without error or classpath cycles in three 
different scenarios:
1. import as binary with linking
2. import as binary without linking
3. import with source.
My development environment is Eclipse 2.1, and target environment is 
internal WSAD V5.x build which use WSWB 2.1 official release as base.
What I did:
1. File-&gt;import
2. External plugins and fragments
3. In the wizard, I chose my target env. path as a "plugin location".

Also, I know at least three other person who got the same errors with Eclipse 
2.1. 

Please specify the exact build that you are using so that I could download it.
Any update? Did you try any of WSAD build which I specified the URL in the 
mail?</WithStack>
    <WithOutStack>When you use RC3 to import a plugins that contain both plugins and nl 
fragments, it creates projects that fail to compile because they all have 
classpath cycles.
This only happens when you import with source, and is OK. What you need to do 
is turn the cycle warning off and rebuild until all the errors are gone. Cycles 
are caused by plug-ins and fragments cross-referencing each other, which is 
necessary in order to simulate run-time situation.

At run-time, a fragment references a plug-in and can 'see' all the classes in 
the plug-in. At the same time, libraries that belong to the fragment are added 
to the list of libraries of the plug-in during the registry resolution phase. 
Therefore, plug-in 'sees' all the classes of its fragments. This kind of cross-
reference causes cycles when modeled by PDE at compile time.

Wassim, did I make sense here?
I did not import with source but maybe this is related to the other defect that 
I opened where the project is added as a source container when it shouldn't.  I 
tried changing the cycle warning off but I stopped the compile before it 
finished because it was over 10,000 compile errors.  This same target imports 
and builds fine with RC1 and all past drivers.


*** This bug has been marked as a duplicate of 35440 ***
I'm still getting the same error with official Eclipse 2.1.
Please be more specific as to what plug-ins you were trying to import, so that 
I would be able to reproduce the problem.
any eclipse's nl1 plugins or WSAD's nl plugins.
I just imported the following plug-ins into my workspace from WSADIE 5 without 
error or classpath cycles:
com.ibm.etools.ctc.bind.http.ui and its nl1 fragment
com.ibm.etools.emf.mapping.ui and its nl1 fragment
org.eclipse.pde.ui and its nl1 fragment.

Could you please be more specific as to which specific plug-ins you are 
importing.
I just imported "org.eclipse.pde.ui" plugin and required plugins,
then I got:

Kind	Status	Priority	Description	Resource	In Folder
	Location
Error			A cycle was detected in the classpath of project: 
org.apache.ant	org.apache.ant		Build path
Error			A cycle was detected in the classpath of project: 
org.apache.lucene	org.apache.lucene		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ant.core	org.eclipse.ant.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ant.core.nl1	org.eclipse.ant.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.compare	org.eclipse.compare		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.compare.nl1	org.eclipse.compare.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.boot.nl1	org.eclipse.core.boot.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.resources	org.eclipse.core.resources		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.resources.nl1	org.eclipse.core.resources.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.runtime	org.eclipse.core.runtime		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.core.runtime.nl1	org.eclipse.core.runtime.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.debug.core	org.eclipse.debug.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.debug.core.nl1	org.eclipse.debug.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.debug.ui	org.eclipse.debug.ui		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.debug.ui.nl1	org.eclipse.debug.ui.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.help	org.eclipse.help		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.help.appserver	org.eclipse.help.appserver		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.help.nl1	org.eclipse.help.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.core	org.eclipse.jdt.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.core.nl1	org.eclipse.jdt.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.debug	org.eclipse.jdt.debug		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.debug.nl1	org.eclipse.jdt.debug.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.debug.ui	org.eclipse.jdt.debug.ui		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.debug.ui.nl1	org.eclipse.jdt.debug.ui.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.launching	org.eclipse.jdt.launching		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.launching.nl1	org.eclipse.jdt.launching.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.ui	org.eclipse.jdt.ui		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jdt.ui.nl1	org.eclipse.jdt.ui.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jface	org.eclipse.jface		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.jface.text	org.eclipse.jface.text		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde	org.eclipse.pde		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.build	org.eclipse.pde.build		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.build.nl1	org.eclipse.pde.build.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.core	org.eclipse.pde.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.core.nl1	org.eclipse.pde.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.nl1	org.eclipse.pde.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.ui	org.eclipse.pde.ui		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.pde.ui.nl1	org.eclipse.pde.ui.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.search	org.eclipse.search		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.search.nl1	org.eclipse.search.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.swt	org.eclipse.swt		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.swt.nl1	org.eclipse.swt.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.team.core	org.eclipse.team.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.team.core.nl1	org.eclipse.team.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.text	org.eclipse.text		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui	org.eclipse.ui		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.editors	org.eclipse.ui.editors		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.nl1	org.eclipse.ui.nl1		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.views	org.eclipse.ui.views		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.win32	org.eclipse.ui.win32		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.workbench	org.eclipse.ui.workbench		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.ui.workbench.texteditor	org.eclipse.ui.workbench.texteditor
		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.update.core	org.eclipse.update.core		Build path
Error			A cycle was detected in the classpath of project: 
org.eclipse.update.core.nl1	org.eclipse.update.core.nl1		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.update.ui.forms	org.eclipse.update.ui.forms		Build 
path
Error			A cycle was detected in the classpath of project: 
org.eclipse.update.ui.forms.nl1	org.eclipse.update.ui.forms.nl1		Build 
path
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.apache.ant		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.apache.lucene		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ant.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ant.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.compare		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.compare.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.boot.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.resources	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.resources.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.runtime	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.core.runtime.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.debug.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.debug.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.debug.ui		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.debug.ui.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.help		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.help.appserver	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.help.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.debug		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.debug.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.debug.ui	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.debug.ui.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.launching	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.launching.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.ui		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jdt.ui.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jface		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.jface.text		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.build		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.build.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.ui		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.pde.ui.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.search		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.search.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.swt		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.swt.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.team.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.team.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.text		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.editors		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.nl1		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.views		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.win32		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.workbench	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.ui.workbench.texteditor
		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.update.core		
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.update.core.nl1	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.update.ui.forms	
	
Error			The project was not built due to classpath errors 
(incomplete or involved in cycle).	org.eclipse.update.ui.forms.nl1	
	

Using Eclipse 2.1 as development environment and WSADIE 5.0 GA as target 
platform on a fresh workspace, I was able to import org.eclipse.pde.ui and all 
its required plug-ins/fragments without error or classpath cycles in three 
different scenarios:
1. import as binary with linking
2. import as binary without linking
3. import with source.
My development environment is Eclipse 2.1, and target environment is 
internal WSAD V5.x build which use WSWB 2.1 official release as base.
What I did:
1. File-&gt;import
2. External plugins and fragments
3. In the wizard, I chose my target env. path as a "plugin location".

Also, I know at least three other person who got the same errors with Eclipse 
2.1. 

Please specify the exact build that you are using so that I could download it.
Any update? Did you try any of WSAD build which I specified the URL in the 
mail?</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35440" />
    <CreationDate amount="2003-03-21 00:12:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P1" />
    <bug_severity amount="critical" />
    <Summery>RC3 failing to import binary projects properly</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="5">
      <source_code type="functioncall">
        <location start="2268" end="2321" />
        <code>JavaCore.create(project).getPackageFragmentRoots();</code>
      </source_code>
      <source_code type="functiondef">
        <location start="2322" end="2530" />
        <code>for (int i = 0; i &lt; roots.length; i++) {
		IPackageFragmentRoot root = roots[i];
		if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {
			result.add(JavaCore.newSourceEntry(root.getPath()));
		}
	}</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="2802" end="2837" />
        <code>// keep existing source folders</code>
      </source_code>
      <source_code type="functioncall">
        <location start="2925" end="2928" />
        <code>();</code>
      </source_code>
      <source_code type="functiondef">
        <location start="2929" end="3144" />
        <code>for (int i = 0; i &lt; roots.length; i++) {
				IPackageFragmentRoot root = roots[i];
				if (root.getKind() == 
IPackageFragmentRoot.K_SOURCE) {
					result.add(JavaCore.newSourceEntry
(root.getPath()));
				}
			}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>When importing plugins from another target, pde in RC3 is adding the project as 
the source container.  This is not valid for binary projects and actually 
causes compile errors if the plugin project contains a folder that contains 
their source exploded out.  So, these plugins ship a "src" directory that 
contains their source.  In RC3, these plugins are imported as projects and the 
packages under "src" have "src" included in the package name since the project 
is added as the source container.  There should not be any source containers 
for a binary project.
I don't quite follow. Can you provide more details?
For example, a plugin with the following structure is imported (without source).

com.some.plugin
  runtime
    runtime.jar
  src
    com
      test
        me
          Foo.java
  plugin.xml

When this is imported, PDE sets the project as the source container.  Then when 
you you compile there will be compile errors because the package statement for 
the Foo.java file does not match what is in the workbench 
(src.com.test.me.Foo).  By definition, this project is no longer a binary 
project since there is a source container (namely the project).  I noticed this 
for all plugins but it is only the plugins with the "src" that are really giving 
us the problems.  Past Eclipse drivers did not do this.

This happens when importing org.eclipse.pde.ui as binary project - the 
JavaBuilder tries to compile all *.java files under 
org.eclipse.pde.ui/templates.

Removing the project root from the build path fixes the problem.
Yes, I realize that removing the project root from the build path will fix the 
problem but we have over 200 plugins that I would need to do this.  This would 
be extremely painful and a waste of time.

Why is this just now happening in RC3 and it wasn't in RC1?
Sorry, I didn't mean it as an workaround for you. I was just trying to add more 
context to the PR (since I faced the same problem).
I can confirm that project is not added as a source container in RC1 and RC2. 
We have to check if this is added automatically by JDT or PDE adds it.
*** Bug 35439 has been marked as a duplicate of this bug. ***
I think that the following code changed in 20030319b is causing the problem:

	IPackageFragmentRoot[] roots = 
		JavaCore.create(project).getPackageFragmentRoots();
        for (int i = 0; i &lt; roots.length; i++) {
		IPackageFragmentRoot root = roots[i];
		if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {
			result.add(JavaCore.newSourceEntry(root.getPath()));
		}
	}

I think that this adds project as a source container to the classpath.
Builds before this one (I checked 20030316) didn't exibit this problem.
The fix is simple and effective:

--&gt;		if (!WorkspaceModelManager.isJavaPluginProject(project) &amp;&amp; 
buildEntries.length == 0) {
			// keep existing source folders
			IPackageFragmentRoot[] roots = 
				JavaCore.create(project).getPackageFragmentRoots
();
			for (int i = 0; i &lt; roots.length; i++) {
				IPackageFragmentRoot root = roots[i];
				if (root.getKind() == 
IPackageFragmentRoot.K_SOURCE) {
					result.add(JavaCore.newSourceEntry
(root.getPath()));
				}
			}
		}

By adding !WorkspaceModelManager.isBinaryPluginProject(project)
to the branch condition, we avoid entering the branch completely for
pure binary projects. This branch was added to preserve source entries
for Java project that have been converted to PDE projects in case there
is no build.properties file. Recent changes to classpath computation during
import (i.e. not clearing the classpath due to other Java indexer problems),
caused the initial project container entry to find its way into the
classpath of fresh binary projects. The added check will prevent
pure binary projects (those that should never have any source entries).


The last sentence should read:

The added check will prevent pure binary projects (those that should never have 
any source entries) from having project as the source container.

Above you say in one place that the change is:
  if (!WorkspaceModelManager.isJavaPluginProject(project)) ...
but in another place you say:
!WorkspaceModelManager.isBinaryPluginProject(project)

I assume you mean the latter.

You are correct - we want to call 'isBinaryPluginProject' and not enter the 
branch if the returned value is true. Sorry.
I did a code review for the proposed change and found the fix safe for 
releasing into RC4.
Reviewed code and approved the fix for releasing in RC4.
Should fix for RC4.
Have reviewed the above code with Dejan.
PDE team has ran tests to confirm fix.
Additionally, PDE team has exported JARs and run with the code to ensure issue 
is fixed.

Confirmed as fixed in RC3b.</WithStack>
    <WithOutStack>When importing plugins from another target, pde in RC3 is adding the project as 
the source container.  This is not valid for binary projects and actually 
causes compile errors if the plugin project contains a folder that contains 
their source exploded out.  So, these plugins ship a "src" directory that 
contains their source.  In RC3, these plugins are imported as projects and the 
packages under "src" have "src" included in the package name since the project 
is added as the source container.  There should not be any source containers 
for a binary project.
I don't quite follow. Can you provide more details?
For example, a plugin with the following structure is imported (without source).

com.some.plugin
  runtime
    runtime.jar
  src
    com
      test
        me
          Foo.java
  plugin.xml

When this is imported, PDE sets the project as the source container.  Then when 
you you compile there will be compile errors because the package statement for 
the Foo.java file does not match what is in the workbench 
(src.com.test.me.Foo).  By definition, this project is no longer a binary 
project since there is a source container (namely the project).  I noticed this 
for all plugins but it is only the plugins with the "src" that are really giving 
us the problems.  Past Eclipse drivers did not do this.

This happens when importing org.eclipse.pde.ui as binary project - the 
JavaBuilder tries to compile all *.java files under 
org.eclipse.pde.ui/templates.

Removing the project root from the build path fixes the problem.
Yes, I realize that removing the project root from the build path will fix the 
problem but we have over 200 plugins that I would need to do this.  This would 
be extremely painful and a waste of time.

Why is this just now happening in RC3 and it wasn't in RC1?
Sorry, I didn't mean it as an workaround for you. I was just trying to add more 
context to the PR (since I faced the same problem).
I can confirm that project is not added as a source container in RC1 and RC2. 
We have to check if this is added automatically by JDT or PDE adds it.
*** Bug 35439 has been marked as a duplicate of this bug. ***
I think that the following code changed in 20030319b is causing the problem:

	IPackageFragmentRoot[] roots = 
		JavaCore.create(project).getPackageFragmentRoots();
        for (int i = 0; i &lt; roots.length; i++) {
		IPackageFragmentRoot root = roots[i];
		if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {
			result.add(JavaCore.newSourceEntry(root.getPath()));
		}
	}

I think that this adds project as a source container to the classpath.
Builds before this one (I checked 20030316) didn't exibit this problem.
The fix is simple and effective:

--&gt;		if (!WorkspaceModelManager.isJavaPluginProject(project) &amp;&amp; 
buildEntries.length == 0) {
			// keep existing source folders
			IPackageFragmentRoot[] roots = 
				JavaCore.create(project).getPackageFragmentRoots
();
			for (int i = 0; i &lt; roots.length; i++) {
				IPackageFragmentRoot root = roots[i];
				if (root.getKind() == 
IPackageFragmentRoot.K_SOURCE) {
					result.add(JavaCore.newSourceEntry
(root.getPath()));
				}
			}
		}

By adding !WorkspaceModelManager.isBinaryPluginProject(project)
to the branch condition, we avoid entering the branch completely for
pure binary projects. This branch was added to preserve source entries
for Java project that have been converted to PDE projects in case there
is no build.properties file. Recent changes to classpath computation during
import (i.e. not clearing the classpath due to other Java indexer problems),
caused the initial project container entry to find its way into the
classpath of fresh binary projects. The added check will prevent
pure binary projects (those that should never have any source entries).


The last sentence should read:

The added check will prevent pure binary projects (those that should never have 
any source entries) from having project as the source container.

Above you say in one place that the change is:
  if (!WorkspaceModelManager.isJavaPluginProject(project)) ...
but in another place you say:
!WorkspaceModelManager.isBinaryPluginProject(project)

I assume you mean the latter.

You are correct - we want to call 'isBinaryPluginProject' and not enter the 
branch if the returned value is true. Sorry.
I did a code review for the proposed change and found the fix safe for 
releasing into RC4.
Reviewed code and approved the fix for releasing in RC4.
Should fix for RC4.
Have reviewed the above code with Dejan.
PDE team has ran tests to confirm fix.
Additionally, PDE team has exported JARs and run with the code to ensure issue 
is fixed.

Confirmed as fixed in RC3b.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35441" />
    <CreationDate amount="2003-03-21 00:49:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Refactor Convert nested type... fails, loses data [refactoring]</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="16">
      <source_code type="class">
        <location start="118" end="885" />
        <code>public abstract static class Exp {
		public static final int STAR = 1;
		public static final int UNION = 2;
		public static final int CONCAT = 3;
		public static final int ELEMENT = 4;
		public static final int EPSILON = 5;
		public static final int NULL = 6;
	
		protected int hash = Integer.MAX_VALUE;
		private static int unique = 0;
		public int id = unique++;
		public static final Exp Epsilon = new Eps();
		public static final Exp Null = new Exp() {
			public boolean nullable() {
				return false;
			}
			public Exp visit(ExpVisitor visitor) {
				return visitor.onNull(this);
			}
			public int getKind() {
				return NULL;
			}
		};
		public abstract boolean nullable();
		public abstract Exp visit(ExpVisitor visitor);
		public abstract int getKind();
	}</code>
      </source_code>
      <source_code type="class">
        <location start="886" end="1153" />
        <code>public static class Eps extends Exp {
		public Eps() {
			id = Integer.MAX_VALUE;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onEpsilon(this);
		}
		public int getKind() {
			return EPSILON;
		}
	}</code>
      </source_code>
      <source_code type="class">
        <location start="1154" end="1506" />
        <code>public static class ExpVisitor {
		public Exp onEpsilon(Exp exp) { return Exp.Null; }
		public Exp onNull(Exp exp) { return Exp.Null; }
		public Exp onStar(Star exp) { return Exp.Null; }
		public Exp onUnion(UnionExp exp) { return Exp.Null; }
		public Exp onConcat(Concat exp) { return Exp.Null; }
		public Exp onElem(Elem exp) { return Exp.Null; }
	}</code>
      </source_code>
      <source_code type="import">
        <location start="1620" end="1688" />
        <code>import com.objfac.xmleditor.schema.extmodel.CheckSchemaVisitor.Eps;</code>
      </source_code>
      <source_code type="import">
        <location start="1689" end="1763" />
        <code>import com.objfac.xmleditor.schema.extmodel.CheckSchemaVisitor.ExpVisitor;</code>
      </source_code>
      <source_code type="multicomment">
        <location start="2954" end="3024" />
        <code>/*
 * (c) Copyright 2003 Object Factory Inc. All rights reserved.
 */</code>
      </source_code>
      <source_code type="package">
        <location start="3025" end="3070" />
        <code>package com.objfac.xmleditor.schema.extmodel;</code>
      </source_code>
      <source_code type="import">
        <location start="3071" end="3096" />
        <code>import java.util.BitSet;</code>
      </source_code>
      <source_code type="import">
        <location start="3097" end="3122" />
        <code>import java.util.HashMap;</code>
      </source_code>
      <source_code type="import">
        <location start="3123" end="3148" />
        <code>import java.util.HashSet;</code>
      </source_code>
      <source_code type="import">
        <location start="3149" end="3177" />
        <code>import java.util.LinkedList;</code>
      </source_code>
      <source_code type="import">
        <location start="3178" end="3214" />
        <code>import com.objfac.xml.XMLCharacter;</code>
      </source_code>
      <source_code type="import">
        <location start="3215" end="3260" />
        <code>import com.objfac.xml.schema.SchemaConstants;</code>
      </source_code>
      <source_code type="multicomment">
        <location start="3261" end="3291" />
        <code>/**
 * @author Bob Foster
 */</code>
      </source_code>
      <source_code type="class">
        <location start="3292" end="61375" />
        <code>public class CheckSchemaVisitor extends Visitor {

	public String fRequiredNamespace;
	public ExtParser fParser;
	public HashSet fIds = new HashSet();
	public HashMap fAttributes = new HashMap();
	public HashMap fAttrGroups = new HashMap();
	public HashMap fElements = new HashMap();
	public HashMap fGroups = new HashMap();
	public HashMap fTypeNames = new HashMap();
	public HashMap fKeys = new HashMap();
	public HashMap fIdentities = new HashMap();
	public HashMap fNotations = new HashMap();
	public HashMap fSimpleTypes = new HashMap();
	
	/*
	 * References to these namespaces allowed by import.
	 */
	public HashSet fAllowRefs = new HashSet();

	/*
	 * These are simple refs through ref attribute in like item
	 */
	public LinkedList fAttributeRefs = new LinkedList();
	public LinkedList fAttrGroupRefs = new LinkedList();
	public LinkedList fElementRefs = new LinkedList();
	public LinkedList fGroupRefs = new LinkedList();
	
	/*
	 * These are type references through type attribute in CommonType item.
	 */
	public LinkedList fTypeRefs = new LinkedList();

	/*
	 * These are type references through base attributes in CommonBase 
item.
	 */
	public LinkedList fBaseRefs = new LinkedList();
	
	/*
	 * These are key references through refer attributes in KeyRef item
	 */
	public LinkedList fKeyRefs = new LinkedList();
	
	/*
	 * These are simple type references through xxx attributes in List 
item.
	 */
	public LinkedList fSimpleTypeRefs = new LinkedList();
	
	/*
	 * These lists of simple type refs through memberTypes attribute in 
Union item
	 */
	public LinkedList fUnionRefs = new LinkedList();

	private static Factory sFac = new Factory();
	private Factory fFac = new Factory();
	private DerivVisitor fDeriv = new DerivVisitor(fFac);
	private RequiredVisitor fRequired = new RequiredVisitor();
	
	private static final String INVALID_ATTR_VALUE = "invalid {0} value 
{0}";
	private static final String MISSING_ATTR = "missing required {0} 
attribute";
	
	public static final int STAR = 1;
	public static final int UNION = 2;
	public static final int CONCAT = 3;
	public static final int ELEMENT = 4;
	public static final int EPSILON = 5;
	public static final int NULL = 6;
	
	public abstract static class Exp {
		protected int hash = Integer.MAX_VALUE;
		private static int unique = 0;
		public int id = unique++;
		public static final Exp Epsilon = new Eps();
		public static final Exp Null = new Exp() {
			public boolean nullable() {
				return false;
			}
			public Exp visit(ExpVisitor visitor) {
				return visitor.onNull(this);
			}
			public int getKind() {
				return NULL;
			}
		};
		public abstract boolean nullable();
		public abstract Exp visit(ExpVisitor visitor);
		public abstract int getKind();
	}
	public static class Eps extends Exp {
		public Eps() {
			id = Integer.MAX_VALUE;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onEpsilon(this);
		}
		public int getKind() {
			return EPSILON;
		}
	}
	public abstract static class UnaryExp extends Exp {
		public Exp exp;
	}
	public abstract static class BinaryExp extends Exp {
		public Exp exp1, exp2;
	}
	public static class Star extends UnaryExp {
		public Star(Exp exp) {
			this.exp = exp;
		}
		public boolean equals(Object o) {
			return o instanceof Star
			&amp;&amp; ((Star)o).exp.equals(exp);
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp.hashCode() + STAR;
			return hash;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onStar(this);
		}
		public int getKind() {
			return STAR;
		}
	}
	public static class UnionExp extends BinaryExp {
		public UnionExp(Exp exp1, Exp exp2) {
			this.exp1 = exp1;
			this.exp2 = exp2;
		}
		public boolean equals(Object o) {
			if (!(o instanceof UnionExp)) return false;
			UnionExp other = (UnionExp) o;
			return (exp1.equals(other.exp1) &amp;&amp; exp2.equals
(other.exp2))
			|| (exp1.equals(other.exp2) &amp;&amp; exp2.equals
(other.exp1));
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp1.hashCode() + exp2.hashCode() + 
UNION;
			return hash;
		}
		public boolean nullable() {
			return exp1.nullable() || exp2.nullable();
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onUnion(this);
		}
		public int getKind() {
			return UNION;
		}
	}
	public static class Concat extends BinaryExp {
		public Concat(Exp exp1, Exp exp2) {
			this.exp1 = exp1;
			this.exp2 = exp2;
		}
		public boolean equals(Object o) {
			if (!(o instanceof Concat)) return false;
			Concat other = (Concat) o;
			return (exp1.equals(other.exp1) &amp;&amp; exp2.equals
(other.exp2));
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp1.hashCode() + exp2.hashCode() + 
CONCAT;
			return hash;
		}
		public boolean nullable() {
			return exp1.nullable() &amp;&amp; exp2.nullable();
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onConcat(this);
		}
		public int getKind() {
			return CONCAT;
		}
	}
	public static class Elem extends Exp {
		private String fNamespace;
		private String fLocalname;
		public Elem(String namespace, String localname) {
			fNamespace = namespace;
			fLocalname = localname;
		}
		public boolean equals(Object o) {
			if (!(o instanceof Elem)) return false;
			Elem other = (Elem) o;
			return fNamespace.equals(other.fNamespace) &amp;&amp; 
fLocalname.equals(other.fLocalname);
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = fNamespace.hashCode() + 
fLocalname.hashCode() + ELEMENT;
			return hash;
		}
		public boolean nullable() {
			return false;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onElem(this);
		}
		public int getKind() {
			return ELEMENT;
		}
	}
	public static class Factory {
		HashMap map = new HashMap();
		public Exp optional(Exp exp) {
			UnionExp union = new UnionExp(exp, Exp.Epsilon);
			return unique(union);
		}
		public Exp optional(String name) {
			return optional(element(name));
		}
		public Exp unique(Exp exp) {
			Exp result = (Exp) map.get(exp);
			if (result == null) {
				result = exp;
				map.put(result, result);
			}
			return result;
		}
		public Exp star(Exp exp) {
			if (exp == Exp.Epsilon || exp == Exp.Null)
				return exp;
			if (exp instanceof Star)
				return exp;
			Star star = new Star(exp);
			return unique(star);
		}
		public Exp star(String name) {
			return star(element(name));
		}
		public Exp plus(Exp exp) {
			Concat concat = new Concat(exp, star(exp));
			return unique(concat);
		}
		public Exp plus(String name) {
			return plus(element(name));
		}
		public Exp concat(Exp exp1, Exp exp2) {
			if (exp1 == Exp.Epsilon)
				return exp2;
			if (exp2 == Exp.Epsilon)
				return exp1;
			if (exp1 == Exp.Null || exp2 == Exp.Null)
				return Exp.Null;
			return unique(new Concat(exp1,exp2));
		}
		public Exp union(String[] names) {
			Exp result = Exp.Null;
			for (int i = 0; i &lt; names.length; i++) {
				Exp element = element(names[i]);
				result = union(result, element);
			}
			return result;
		}
		public Exp union(Exp exp1, Exp exp2) {
			if (exp1 == Exp.Epsilon &amp;&amp; exp2.nullable())
				return exp2;
			if (exp2 == Exp.Epsilon &amp;&amp; exp1.nullable())
				return exp1;
			if (exp1 == Exp.Null)
				return exp2;
			if (exp2 == Exp.Null)
				return exp1;
			UnionExp union = null;
			int kind1 = exp1.getKind();
			int kind2 = exp2.getKind();
			if (kind1 == UNION &amp;&amp; kind2 != UNION) {
				union = addToUnion((UnionExp)exp1, exp2);
			}
			else if (kind1 != UNION &amp;&amp; kind2 == UNION) {
				union = addToUnion((UnionExp)exp2, exp1);
			}
			else if (kind1 == UNION &amp;&amp; kind2 == UNION) {
				union = addAllToUnion((UnionExp)exp1, 
(UnionExp)exp2);
			}
			else {
				if (exp1.hashCode() &gt; exp2.hashCode()) {
					Exp tmp = exp1;
					exp1 = exp2;
					exp2 = tmp;
				}
				union = new UnionExp(exp1, exp2);
			}
			return unique(new UnionExp(exp1,exp2));
		}
		private UnionExp addAllToUnion(UnionExp union1, UnionExp 
union2) {
			int kind = union2.exp1.getKind();
			UnionExp union = addToUnion(union1, union2.exp2);
			if (kind == UNION) {
				return addAllToUnion(union, (UnionExp)
union2.exp1);
			}
			return addToUnion(union, union2.exp1);
		}
		private UnionExp addToUnion(UnionExp union, Exp exp) {
			int kind1 = union.exp1.getKind();
			int kind2 = union.exp2.getKind();
			if (kind1 != UNION) {
				int id1 = union.exp1.id;
				int id2 = union.exp2.id;
				int id3 = exp.id;
				if (id3 &lt; id1) {
					return new UnionExp(new UnionExp(exp, 
union.exp1), union.exp2);
				}
				if (id3 &lt; id2) {
					return new UnionExp(new UnionExp
(union.exp1, exp), union.exp2);
				}
				else {
					return new UnionExp(union, exp);
				}
			}
			int id2 = union.exp2.id;
			int id3 = exp.id;
			if (id3 &lt; id2) {
				return new UnionExp(addToUnion((UnionExp)
union.exp1, exp), union.exp2);
			}
			return new UnionExp(union, exp);
		}
		public Exp element(String namespace, String localname) {
			return unique(new Elem(namespace, localname));
		}
		public Exp element(String localname) {
			return unique(new Elem(SchemaConstants.XS_NAMESPACE, 
localname));
		}
	}
	public static class ExpVisitor {
		public Exp onEpsilon(Exp exp) { return Exp.Null; }
		public Exp onNull(Exp exp) { return Exp.Null; }
		public Exp onStar(Star exp) { return Exp.Null; }
		public Exp onUnion(UnionExp exp) { return Exp.Null; }
		public Exp onConcat(Concat exp) { return Exp.Null; }
		public Exp onElem(Elem exp) { return Exp.Null; }
	}
	public static class DerivVisitor extends ExpVisitor {
		private Factory fac;
		private Exp exp;
		private Exp wrt;
		public DerivVisitor(Factory factory) {
			this.fac = factory;
		}
		public Exp deriv(Exp exp, Exp wrt) {
			this.exp = exp;
			this.wrt = wrt;
			return exp.visit(this);
		}
		public Exp onStar(Star exp) {
			return fac.union(exp.exp.visit(this), exp);
		}
		public Exp onUnion(UnionExp exp) {
			return fac.union(exp.exp1.visit(this), exp.exp2.visit
(this));
		}
		public Exp onConcat(Concat exp) {
			if (exp.exp1.nullable())
				return fac.union(exp.exp1.visit(this), 
exp.exp2.visit(this));
			return fac.concat(exp.exp1.visit(this), exp.exp2);
		}
		public Exp onElem(Elem exp) {
			if (exp.equals(wrt))
				return Exp.Epsilon;
			return Exp.Null;
		}
	}
	public static class RequiredVisitor extends ExpVisitor {
		private LinkedList list;
		public String[] getRequired(Exp exp) {
			list = new LinkedList();
			exp.visit(this);
			return (String[]) list.toArray(new String[list.size
()]);
		}
		public Exp onConcat(Concat exp) {
			if (exp.exp1.nullable()) {
				//don't need to visit exp1
				if (!exp.exp2.nullable())
					return exp.exp2.visit(this);
			}
			return exp.exp1.visit(this);
		}

		public Exp onElem(Elem exp) {
			list.add(exp.fLocalname);
			return null;
		}

		public Exp onStar(Star exp) {
			return null;
		}

		public Exp onUnion(UnionExp exp) {
			// if either choice is nullable the union is nullable
			if (!exp.nullable()) {
				exp.exp1.visit(this);
				exp.exp2.visit(this);
			}
			return null;
		}
	}
	
	private Exp fAllowChild = sFac.element("schema");
	
	private static final String XSNS = SchemaConstants.XS_NAMESPACE;
	private static Exp ALLOW_NONE = Exp.Null;
	private static Exp ALLOW_ANNOTATION = sFac.optional(sFac.element
("annotation"));
	private static Exp REQUIRE_SIMPLETYPE =
	sFac.concat(
		sFac.optional(sFac.element("annotation")),
		sFac.element("simpleType"));
	
	//Content: ((include | import | redefine | annotation)*, (((simpleType 
| complexType | group | attributeGroup) | element | attribute | notation), 
annotation*)*)
	private static Exp SCHEMA_CHILDREN = 
		sFac.concat(
			sFac.star(
				sFac.union(new String[] 
{"include","import","redefine","annotation"})),
			sFac.star(
				sFac.concat(
					sFac.union(new String[] 
{"simpleType","complexType","group","attributeGroup","element","attribute","not
ation"}),
					sFac.star("annotation"))));
					
	//Content: (appinfo | documentation)*
	private static Exp ANNOTATION_CHILDREN =
		sFac.star(
			sFac.union(new String[] {"appinfo","documentation"}));
			
	//Content: (annotation?, (simpleType?))
	private static Exp ATTRIBUTE_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.optional("simpleType"));
			
	//Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
	private static Exp ATTRIBUTEGROUP_CHILDREN =
		sFac.concat(
			sFac.concat(
				sFac.optional("annotation"),
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"}))),
			sFac.optional("anyAttribute"));
			
	//Content: (annotation?, (element | group | choice | sequence | any)*)
	private static Exp CHOICE_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.star(
				sFac.union(new String[] 
{"element","group","choice","sequence","any"})));
				
	//Content: (annotation?, (restriction | extension))
	private static Exp COMPLEXCONTENT_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.union(new String[] {"restriction","extension"}));
	
	//Content: (annotation?, (restriction | extension))
	private static Exp SIMPLECONTENT_CHILDREN = COMPLEXCONTENT_CHILDREN;
			
	//Content: (annotation?, 
	//          (simpleContent | complexContent | ((group | all | choice | 
sequence)?, ((attribute | attributeGroup)*, anyAttribute?))))
	private static Exp COMPLEXTYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(
			sFac.union(new String[] 
{"simpleContent","complexContent"}),
			sFac.concat(
				sFac.optional(
					sFac.union(new String[] 
{"group","all","choice","sequence"})),
				sFac.concat(
					sFac.star(
						sFac.union(new String[] 
{"attribute","attributeGroup"})),
					sFac.optional("anyAttribute")))));
					
	//Content: (annotation?, ((simpleType | complexType)?, (unique | key | 
keyref)*))
	private static Exp ELEMENT_CHILDREN =
	sFac.concat(
		sFac.concat(
			sFac.optional("annotation"),
			sFac.optional(
				sFac.union(new String[] 
{"simpleType","complexType"}))),
		sFac.star(
			sFac.union(new String[] {"unique","key","keyref"})));
			
	//Content: (annotation?, (unique | key | keyref)*) ???
	private static Exp ELEMENTNOTYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.star(
			sFac.union(new String[] {"unique","key","keyref"})));
			
	//Content: (annotation?, ((group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?)))
	private static Exp COMPLEXEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.optional(
				sFac.union(new String[] 
{"group","all","choice","sequence"})),
			sFac.concat(
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"})),
				sFac.optional("anyAttribute"))));
				
	//Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
	private static Exp SIMPLEEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.star(
				sFac.union(new String[] 
{"attribute","attributeGroup"})),
			sFac.optional("anyAttribute")));
	
	//Content: (annotation?, (all | choice | sequence))
	private static Exp GROUP_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(new String[] {"all","choice","sequence"}));
	
	//Content: (annotation | (simpleType | complexType | group | 
attributeGroup))*
	private static Exp REDEFINE_CHILDREN =
	sFac.star(
		sFac.union(new String[] 
{"annotation","simpleType","complexType","group","attributeGroup"}));
	
	//Content: (annotation?, (selector, field+))
	private static Exp KEY_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.element("selector"),
			sFac.plus("field")));
	
	//Content: (annotation?, element*)
	private static Exp ALL_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.star("element"));
	
	//Content: (annotation?, (restriction | list | union))
	private static Exp SIMPLETYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(new String[] {"restriction","list","union"}));
	
	//Content: (annotation?, (simpleType*))
	//Content: (annotation?, (simpleType+)) -- used only in simpleType 
required context
	private static Exp UNION_CHILDREN =
	sFac.concat(
		sFac.optional(sFac.element("annotation")),
		sFac.plus("simpleType"));
	
	/**
	 * Constructor.
	 */
	public CheckSchemaVisitor(ExtParser parser, String requiredNamespace) {
		fParser = parser;
		fRequiredNamespace = requiredNamespace;
	}
	
	/*
	 * &lt;all 
		  id = ID 
		  maxOccurs = 1 : 1
		  minOccurs = (0 | 1) : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, element*)
		&lt;/all&gt;
	 */
	public Object visitAll(All item) {
		checkId(item);
		int max = checkMinMax(item);
		if (max != 1)
			error(item, "maxOccurs must be 1");
		Exp saveAllow = checkAllow(item, ALL_CHILDREN);
		item.visitChildren(this);
		checkEnd(item, saveAllow);
		return null;
	}

	/*
	 * &lt;annotation 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (appinfo | documentation)*
		&lt;/annotation&gt;
	 */
	public Object visitAnnotation(Annotation item) {
		Exp saveAllow = checkAllow(item, ANNOTATION_CHILDREN);
		item.visitChildren(this);
		checkEnd(item, saveAllow);
		return null;
	}

	/*
	 * &lt;any 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  namespace = ((##any | ##other) | List of (anyURI | 
(##targetNamespace | ##local)) )  : ##any
		  processContents = (lax | skip | strict) : strict
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/any&gt;
	 */
	public Object visitAny(Any item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			int max = checkMinMax(item);
			checkNamespace(item);
			checkProcessContents(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private int checkMinMax(CommonMinMax item) {
		int max = checkMaxOccurs(item);
		int min = checkMinOccurs(item);
		if (max &gt;= 0 &amp;&amp; min &gt;= 0 &amp;&amp; max &lt; min) {
			error(item, "minOccurs({0}) greater than maxOccurs
({1})",
				new Integer(min), new Integer(max));
			return 0;
		}
		else if (max == 0)
			item.setSkip(true);
		return max;
	}

	private int checkMinOccurs(CommonMinMax item) {
		String min = item.getMinOccurs();
		if (min == null) {
			item.setMinOccurs("1");
			return 1;
		}
		else {
			Common c = (Common) item;
			Common parent = c.getParent();
			if (parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE)
				error(c, "minOccurs not allowed for top-level 
item");
			int m = getInt(min);
			if (m &lt; 0) {
				error(item, "{1} is not a valid minOccurs 
value", min);
				item.setMinOccurs("0");
			}
			return m;
		}
	}

	private int checkMaxOccurs(CommonMinMax item) {
		String max = item.getMaxOccurs();
		if (max == null) {
			item.setMaxOccurs("1");
			return 1;
		}
		else {
			Common c = (Common) item;
			Common parent = c.getParent();
			if (parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE)
				error(c, "minOccurs not allowed for top-level 
item");
			if (!max.equals("unbounded")) {
				int m = getInt(max);
				if (m &lt; 0) {
					error(item, "{1} is not a valid 
maxOccurs value", max);
					item.setMaxOccurs("0");
				}
				return m;
			}
			else
				return Integer.MAX_VALUE;
		}
	}

	private int getInt(String s) {
		try {
			return Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return -1;
		}
	}

	private void checkId(Common item) {
		String id = item.getId();
		if (id != null) {
			if (fIds.contains(id))
				error(item, "element {0} id is not unique", 
id);
			else
				fIds.add(id);
		}
	}

	/*
	 * &lt;anyAttribute 
		  id = ID 
		  namespace = ((##any | ##other) | List of (anyURI | 
(##targetNamespace | ##local)) )  : ##any
		  processContents = (lax | skip | strict) : strict
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/anyAttribute&gt;
	 */
	public Object visitAnyAttribute(AnyAttribute item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkNamespace(item);
			checkProcessContents(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkProcessContents(CommonAny item) {
		String pc = item.getProcessContents();
		if (pc == null)
			item.setProcessContents("strict");
		else if (!pc.equals("lax") &amp;&amp; !pc.equals("skip") &amp;&amp; !pc.equals
("strict")) {
			error(item, "invalid processContents value {0}", pc);
			item.setProcessContents("strict");
		}
	}

	private void checkNamespace(CommonAny item) {
		String ns = item.getNamespace();
		if (ns == null) {
			item.setNamespace("##any");
		}
		else if (!ns.equals("##any") &amp;&amp; !ns.equals("##other")) {
			int pos = 0;
			while ((pos = ns.indexOf("##", pos)) &gt;= 0) {
				StringBuffer buf = new StringBuffer();
				for (int i = pos+2; i &lt; ns.length(); i++)
					if (XMLCharacter.isWhitespace(ns.charAt
(i)))
						break;
				String key = buf.toString();
				if (!key.equals("targetNamespace") &amp;&amp; !
key.equals("local"))
					error(item, "invalid namespace keyword 
##", key);
			}
		}
	}

	public Object visitAppInfo(AppInfo item) {
		// don't look at children
		return null;
	}

	/*
	 * &lt;attribute 
		  default = string 
		  fixed = string 
		  form = (qualified | unqualified)
		  id = ID 
		  name = NCName 
		  ref = QName 
		  type = QName 
		  use = (optional | prohibited | required) : optional
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?))
		&lt;/attribute&gt;
	 */
	public Object visitAttribute(Attribute item) {
		boolean havetype = item.getType() != null;
		boolean haveref = item.getRef() != null;
		Exp saveAllow = checkAllow(item, havetype || haveref ? 
ALLOW_ANNOTATION : ATTRIBUTE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			boolean isElement = false;
			checkForm(item, isElement);
			checkNameRef(item);
			checkUse(item);
			String type = item.getType();
			if (type != null) {
				if (haveref)
					error(item, "cannot specify type 
attribute with ref");
				String prefix = getPrefix(type);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in type name {0}", type);
				}
				else {
					fTypeRefs.add(item);
				}
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}
	
	private final QName QNAME = new QName("","");
	private QName qname(String ns, String ln) {
		QNAME.namespace = ns;
		QNAME.localname = ln;
		return QNAME;
	}

	private boolean checkNameRef(CommonNameRef item) {
		boolean haveref = false;
		Common parent = ((Common)item).getParent();
		String target = parent.getTargetNamespace();
		boolean requireName = parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE;
		if (requireName) {
			String name = item.getName();
			if (name == null) {
				error((Common)item, "missing required name 
attribute");
			}
			else if (fAttributes.containsKey(qname(target, name))) 
{
				error((Common)item, "attribute {0} declared 
more than once", name);
			}
			else if (checkNCName((Common) item, "name", name)) {
				Common c = (Common) item;
				QName qn = new QName(target, name);
				if (c.getKind() == Visitor.ATTRIBUTE) {
					fAttributes.put(qn, item);
				}
				else if (c.getKind() == 
Visitor.ATTRIBUTEGROUP) {
					fAttrGroups.put(qn, item);
				}
				else if (c.getKind() == Visitor.ELEMENT) {
					fElements.put(qn, item);
				}
				else if (c.getKind() == Visitor.GROUP)
					fGroups.put(qn, item);
			}
			String ref = item.getRef();
			if (ref != null)
				error((Common)item, "cannot specify ref 
attribute on top-level item");
		}
		else {
			String name = item.getName();
			String ref = item.getRef();
			if (name == null &amp;&amp; ref == null) {
				error((Common)item, "missing name or ref 
attribute");
			}
			else if (name != null &amp;&amp; ref != null) {
				error((Common)item, "can't specify both name 
and ref attributes");
			}
			else if (ref != null)
				haveref = true;
			else if (name == null)
				error((Common)item, "missing required ref 
attribute");
		}
		if (haveref) {
			Common c = (Common) item;
			if (c.getKind() == Visitor.ATTRIBUTE) {
				fAttributeRefs.add(item);
			}
			else if (c.getKind() == Visitor.ATTRIBUTEGROUP) {
				fAttrGroupRefs.add(item);
			}
			else if (c.getKind() == Visitor.ELEMENT) {
				fElementRefs.add(item);
			}
			else if (c.getKind() == Visitor.GROUP) {
				fGroupRefs.add(item);
			}
		}
		return haveref;
	}
	
	private void checkUse(CommonUse item) {
		String use = item.getUse();
		if (use == null)
			item.setUse("optional"); //$NON-NLS-1$
		else {
			if (!use.equals("optional") &amp;&amp; !use.equals("required") 
&amp;&amp; !use.equals("prohibited")) { //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
				error((Common)item, "invalid use attribute 
value {0}", use);
			}
		}
		
	}

	private void checkForm(CommonForm item, boolean isElement) {
		String form = item.getForm();
		if (form == null)
			setFormToDefault(item, isElement);
		else if (!checkFormValue((Common)item, "form", form)) //$NON-
NLS-1$
			setFormToDefault(item, isElement);
	}
	
	private void setFormToDefault(CommonForm item, boolean isElement) {
		Common c = (Common) item;
		item.setForm(isElement ? c.getElementFormDefault() : 
c.getAttributeFormDefault());
	}
	
	private boolean checkFormValue(Common item, String attrName, String 
value) {
		if (!value.equals("qualified") &amp;&amp; !value.equals
("unqualified")) { //$NON-NLS-1$//$NON-NLS-2$
			error(item, INVALID_ATTR_VALUE, attrName, value);
			return false;
		}
		return true;
	}

	/*
	 * &lt;attributeGroup 
		  id = ID 
		  name = NCName 
		  ref = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
		&lt;/attributeGroup&gt;
	 * &lt;attributeGroup 
		  id = ID 
		  ref = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/attributeGroup&gt;
	 */
	public Object visitAttributeGroup(AttributeGroup item) {
		Common parent = item.getParent();
		boolean top = parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE;
		Exp saveAllow = checkAllow(item, top ? 
ATTRIBUTEGROUP_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkNameRef(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;choice 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (element | group | choice | sequence 
| any)*)
		&lt;/choice&gt;
	 */
	public Object visitChoice(Choice item) {
		Exp saveAllow = checkAllow(item, CHOICE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;complexContent 
		  id = ID 
		  mixed = boolean 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | extension))
		&lt;/complexContent&gt;
	 */
	public Object visitComplexContent(ComplexContent item) {
		Exp saveAllow = checkAllow(item, COMPLEXCONTENT_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String mixed = item.getMixed();
			if (mixed == null)
				item.setMixed("false");
			else {
				boolean m = checkBoolean(item, "mixed", mixed);
				item.setMixed(m ? "true" : "false");
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkBoolean(Common item, String attname, String 
value) {
		boolean m = value.equals("true") || value.equals("0");
		if (!value.equals("true") &amp;&amp; !value.equals("false") &amp;&amp; !
value.equals("0") &amp;&amp; !value.equals("1"))
			error(item, "invalid value {0} for boolean attribute 
{1}", value, attname);
		return m;
	}

	/*
	 * &lt;complexType 
		  abstract = boolean : false
		  block = (#all | List of (extension | restriction)) 
		  final = (#all | List of (extension | restriction)) 
		  id = ID 
		  mixed = boolean : false
		  name = NCName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleContent | complexContent | 
((group | all | choice | sequence)?, ((attribute | attributeGroup)*, 
anyAttribute?))))
		&lt;/complexType&gt;
	 */
	public Object visitComplexType(ComplexType item) {
		Exp saveAllow = checkAllow(item, COMPLEXTYPE_CHILDREN);
		if (!item.getSkip()) {
			String abs = item.getAbstract();
			if (abs == null)
				item.setAbstract("false");
			else {
				boolean a = checkBoolean(item, "abstract", 
abs);
				item.setAbstract(a ? "true" : "false");
			}
			String block = item.getBlock();
			if (block != null) {
				if (!checkExtensionRestriction(item, "block", 
block))
					item.setBlock(null);
			}
			String fin = item.getFinal();
			if (fin != null) {
				if (!checkExtensionRestriction(item, "final", 
fin))
					item.setFinal(null);
			}
			checkId(item);
			String mixed = item.getMixed();
			if (mixed == null)
				item.setMixed("false");
			else {
				boolean m = checkBoolean(item, "mixed", mixed);
				item.setMixed(m ? "true" : "false");
			}
			String name = item.getName();
			Common parent = item.getParent();
			if (name == null) {
				if (parent.getKind() == Visitor.SCHEMA)
					error(item, "top-level complex type 
must have name");
			}
			else if (fTypeNames.containsKey(name)) {
				error(item, "complex type name {0} is already 
defined", name);
			}
			else {
				fTypeNames.put(new QName
(parent.getTargetNamespace(), name), item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkExtensionRestriction(Common item, String attname, 
String value) {
		if (value.equals("#all"))
			return true;
		String[] list = getList(value);
		if (list.length == 0)
			error(item, "attribute {0} must not be empty list", 
attname);
		for (int i = 0; i &lt; list.length; i++) {
			String v = list[i];
			if (!v.equals("extension") &amp;&amp; !v.equals
("restriction")) {
				error(item, "attribute {0} must be list of 
extension or restriction, not {1}", attname, v);
				return false;
			}
		}
		return true;
	}

	private boolean checkExtensionRestrictionSubstitution(Common item, 
String attname, String value) {
		if (value.equals("#all"))
			return true;
		String[] list = getList(value);
		if (list.length == 0)
			error(item, "attribute {0} must not be empty list", 
attname);
		for (int i = 0; i &lt; list.length; i++) {
			String v = list[i];
			if (!v.equals("extension") &amp;&amp; !v.equals("restriction") 
&amp;&amp; !v.equals("substitution")) {
				error(item, "attribute {0} must be list of 
extension or restriction, not {1}", attname, v);
				return false;
			}
		}
		return true;
	}

	private String[] getList(String value) {
		StringBuffer buf = new StringBuffer();
		LinkedList list = new LinkedList();
		for (int i = 0, n = value.length(); i &lt; n; i++) {
			char c = value.charAt(i);
			if (XMLCharacter.isWhitespace(c)) {
				if (buf.length() &gt; 0) {
					list.add(buf.toString());
					buf.setLength(0);
				}
			}
			else
				buf.append(c);
		}
		if (buf.length() &gt; 0) {
			list.add(buf.toString());
		}
		return (String[]) list.toArray(new String[list.size()]);
	}

	public Object visitDocumentation(Documentation item) {
		// don't visit children
		return null;
	}

	/*
	 * &lt;element 
		  abstract = boolean : false
		  block = (#all | List of (extension | restriction | 
substitution)) 
		  default = string 
		  final = (#all | List of (extension | restriction)) 
		  fixed = string 
		  form = (qualified | unqualified)
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  name = NCName 
		  nillable = boolean : false
		  ref = QName 
		  substitutionGroup = QName 
		  type = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((simpleType | complexType)?, (unique 
| key | keyref)*))
		&lt;/element&gt;
	 */
	public Object visitElement(Element item) {
		boolean havetype = item.getType() != null;
		boolean haveref = item.getRef() != null;
		Exp saveAllow = checkAllow(item, haveref || havetype ? 
ELEMENTNOTYPE_CHILDREN : ELEMENT_CHILDREN);
		if (!item.getSkip()) {
			String abs = item.getAbstract();
			if (abs == null)
				item.setAbstract("false");
			else {
				boolean a = checkBoolean(item, "abstract", 
abs);
				item.setAbstract(a ? "true" : "false");
			}
			String block = item.getBlock();
			if (block != null) {
				if (!checkExtensionRestrictionSubstitution
(item, "block", block))
					item.setBlock(null);
			}
			String fin = item.getFinal();
			if (fin != null) {
				if (!checkExtensionRestriction(item, "final", 
fin))
					item.setFinal(null);
			}
			boolean hasvalue = false;
			String def = item.getDefault();
			if (def != null) {
				hasvalue = true;
			}
			String fix = item.getFixed();
			if (fix != null) {
				hasvalue = true;
			}
			checkId(item);
			boolean isElement = true;
			checkForm(item, isElement);
			checkMinMax(item);
			String nil = item.getNillable();
			if (nil == null)
				item.setNillable("false");
			else {
				boolean a = checkBoolean(item, "nillable", 
nil);
				item.setNillable(a ? "true" : "false");
			}
			checkNameRef(item);
			String type = item.getType();
			if (type != null) {
				String prefix = getPrefix(type);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in type name {0}", type);
				}
				else {
					fTypeRefs.add(item);
				}
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private String getPrefix(String name) {
		int pos = name.indexOf(':');
		if (pos &gt;= 0)
			return name.substring(0, pos);
		return "";
	}

	/*
	 * &lt;enumeration 
		  id = ID 
		  value = anySimpleType 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/enumeration&gt;
	 */
	public Object visitEnumeration(Enumeration item) {
		visitValueItem(item);
		return null;
	}

	/*
	 * &lt;extension 
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
		&lt;/extension&gt;
	 * &lt;extension 
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?)))
		&lt;/extension&gt;
	 */
	public Object visitExtension(Extension item) {
		Common parent = item.getParent();
		if (parent == null) {
			error(item, "&lt;extension&gt; cannot be root element");
			return null;
		}
		boolean isComplex = parent.getKind() == Visitor.COMPLEXCONTENT;
		Exp saveAllow = checkAllow(item, isComplex ? 
COMPLEXEXTENSION_CHILDREN : SIMPLEEXTENSION_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String base = item.getBase();
			if (base == null) {
				error(item, "&lt;extension&gt; must specify base 
type");
			}
			else if (isComplex) {
				String prefix = getPrefix(base);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in base {0}", base);
				}
				else {
					fBaseRefs.add(item);
				}
			}
			else {
				checkSimpleType(item, "base", base);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;field 
		  id = ID 
		  xpath = a subset of XPath expression, see below 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/field&gt;
	 */
	public Object visitField(Field item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkXpath(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkXpath(CommonXpath item) {
		String xpath = item.getXpath();
		if (xpath == null) {
			error((Common)item, "missing required xpath 
attribute");
		}
		else
			checkXpathValue(item, xpath);
	}

	private void checkXpathValue(CommonXpath item, String xpath) {
		// TODO Auto-generated method stub
	}

	/*
	 * &lt;fractionDigits 
		  fixed = boolean : false
		  id = ID 
		  value = nonNegativeInteger 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/fractionDigits&gt;
	 */
	public Object visitFractionDigits(FractionDigits item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			String fixed = item.getFixed();
			if (fixed == null)
				item.setFixed("false");
			else {
				boolean b = checkBoolean(item, "fixed", fixed);
				item.setFixed(b ? "true" : "false");
			}
			checkId(item);
			String value = item.getValue();
			if (value == null) {
				error(item, "missing required value 
attribute");
			}
			else {
				int v = getInt(value);
				if (v &lt; 0)
					error(item, 
INVALID_ATTR_VALUE, "value", value);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;group (as child of schema or redefine)
		  name = NCName&gt;
		  Content: (annotation?, (all | choice | sequence))
		&lt;/group&gt;
		&lt;group (otherwise???)
		  ref = QName
		  minOccurs = integer : 1
		  maxOccurs = { integer | "unbounded" } : 1
		  Content: (annotation?)
		&lt;/group&gt;
	 */
	public Object visitGroup(Group item) {
		Exp saveAllow = checkAllow(item, isTopLevel(item) ? 
GROUP_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkNameRef(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}
	
	private boolean isTopLevel(Common item) {
		Common parent = item.getParent();
		return parent == null ||
			parent.getKind() == Visitor.SCHEMA || parent.getKind() 
== Visitor.REDEFINE;	
	}

	/*
	 * &lt;import 
		  id = ID 
		  namespace = anyURI 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/import&gt;
	 */
	public Object visitImport(Import item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String loc = item.getSchemaLocation();
			String ns = item.getNamespace();
			fAllowRefs.add(ns == null ? "" : ns);
			if (loc != null) {
				include(loc, ns == null ? "" : ns);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;include 
		  id = ID 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/include&gt;
	 */
	public Object visitInclude(Include item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String loc = item.getSchemaLocation();
			if (loc == null) {
				error(item, MISSING_ATTR, "schemaLocation");
			}
			else {
				include(loc, item.getTargetNamespace());
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void include(String loc, String namespace) {
		// recursively parse include
		String saveRequiredNamespace = fRequiredNamespace;
		fRequiredNamespace = namespace;
		try {
			fParser.parseInclude(loc, this);
		}
		finally {
			fRequiredNamespace = saveRequiredNamespace;
		}
	}

	/*
	 * &lt;key 
		  id = ID 
		  name = NCName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/key&gt;
	 */
	public Object visitKey(Key item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null) {
				error(item, MISSING_ATTR, "name");
			}
			else {
				String ns = item.getTargetNamespace();
				if (fKeys.containsKey(qname(ns, name))) {
					error(item, "key name {0} is already 
defined",name);
				}
				else
					fKeys.put(new QName(ns, name), item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;keyref 
		  id = ID 
		  name = NCName (required)
		  refer = QName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/keyref&gt;
	 */
	public Object visitKeyRef(KeyRef item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String ns = item.getTargetNamespace();
			String name = item.getName();
			if (name == null) {
				error(item, MISSING_ATTR, "name");
			}
			else  if (checkNCName(item, "name", name)) {
				QName qn = new QName(ns, name);
				if (fIdentities.containsKey(qn) || 
fKeys.containsKey(qn))
					error(item, "identity constraint name 
{0} is already defined", name);
				else
					fIdentities.put(qn, item);
			}
			String refer = item.getRefer();
			if (refer == null)
				error(item, MISSING_ATTR, "refer");
			else {
				fKeyRefs.add(item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;length 
		  fixed = boolean : false
		  id = ID 
		  value = nonNegativeInteger 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/length&gt;
	 */
	public Object visitLength(Length item) {
		visitFixedValueItem(item);
		return null;
	}

	private void visitFixedValueItem(CommonFixedValue item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkFixedValueItem(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
	}

	private void visitValueItem(CommonValue item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkValueItem(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
	}

	private void checkFixedValueItem(CommonFixedValue item) {
		checkId(item);
		String fixed = item.getFixed();
		if (fixed == null)
			fixed = "false";
		else
			checkBoolean(item, "fixed", fixed);
		checkValueItem(item);
	}

	private void checkValueItem(CommonValue item) {
		String value = item.getValue();
		if (value == null)
			error(item, MISSING_ATTR, "value");
		else {
			int v = getInt(value);
			if (v &lt; 0) {
				error(item, "value=\"{0}\" is not a number or 
negative");
			}
		}
	}

	/*
	 * &lt;list 
		  id = ID 
		  itemType = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?))
		&lt;/list&gt;
	 */
	public Object visitList(List item) {
		Exp saveAllow = checkAllow(item, item.getItemType() == null ? 
REQUIRE_SIMPLETYPE : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			String itemType = item.getItemType();
			if (itemType != null) {
				checkSimpleType(item, "itemType", itemType);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkSimpleType(Common item, String attrName, String 
type) {
		QName qn = getQName(item, type);
		if (qn.namespace != "?" &amp;&amp; qn.localname != "?") {
			if (qn.namespace.equals(XSNS)) {
				if (!SimpleType.TYPE.contains(qn.localname)) {
					error(item, "unknown standard type 
\"{0}\"", type);
				}
			}
			else {
				fSimpleTypeRefs.add(item);
			}
		}
	}

	private void checkSimpleTypeDef(SimpleType item, String name) {
		QName qn = getQName(item, name);
		if (qn.namespace != "?" &amp;&amp; qn.localname != "?") {
			// allow definitions in XS namespace iff they are 
predefined
			// this allows to parse schema for schemas
			if (qn.namespace.equals(XSNS)) {
				if (!SimpleType.TYPE.contains(qn.localname)) {
					error(item, "unknown standard type 
\"{0}\"", name);
				}
			}
			else if (fSimpleTypes.containsKey(qn)){
				error(item, "duplicate definition of 
simpleType {0}", name);
			}
			else {
				fSimpleTypes.put(qn, item);
			}
		}
	}

	private QName getQName(Common item, String name) {
		int pos = name.indexOf(':');
		String prefix = "";
		String localname = name;
		if (pos &gt; 0) {
			prefix = name.substring(0, pos);
			localname = name.substring(pos+1);
		}
		if (localname.length() == 0) {
			error(item, "zero-length localname \"{0}\"", name);
			localname = "?";
		}
		String namespace = item.getNamespace(prefix);
		if (namespace == null) {
			error(item, "unknown namespace for \"{0}\"", name);
			namespace = "?";
		}
		return new QName(namespace, localname);
	}

	/*
	 * 
	 */
	public Object visitMaxExclusive(MaxExclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMaxInclusive(MaxInclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMaxLength(MaxLength item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinExclusive(MinExclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinInclusive(MinInclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinLength(MinLength item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * &lt;notation 
		  id = ID 
		  name = NCName (required)
		  public = anyURI (required)
		  system = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/notation&gt;
	 */
	public Object visitNotation(Notation item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null)
				error(item, MISSING_ATTR, "name");
			else {
				if (fNotations.containsKey(name))
					error(item, "notation {0} is 
previously defined", name);
				else
					fNotations.put(name, item);
			}
			String pubid = item.getPublic();
			if (pubid == null)
				error(item, MISSING_ATTR, "public");
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * 
	 */
	public Object visitPattern(Pattern item) {
		visitValueItem(item);
		return null;
	}

	/*
	 * &lt;redefine 
		  id = ID 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation | (simpleType | complexType | group | 
attributeGroup))*
		&lt;/redefine&gt;
	 */
	public Object visitRedefine(Redefine item) {
		checkId(item);
		String loc = item.getSchemaLocation();
		if (loc == null) {
			error(item, MISSING_ATTR, "schemaLocation");
		}
		else {
			include(loc, item.getTargetNamespace());
			Exp saveAllow = checkAllow(item, REDEFINE_CHILDREN);
			if (!item.getSkip()) {
			
				item.visitChildren(this);
				checkEnd(item, saveAllow);
			}
			else
				forceEnd(saveAllow);
			return null;
		}
		return null;
	}

	/*
	 * &lt;restriction (child of SimpleContent or SimpleType)
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?, (minExclusive | 
minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | 
length | minLength | maxLength | enumeration | whiteSpace | pattern)*)?, 
((attribute | attributeGroup)*, anyAttribute?))
		&lt;/restriction&gt;
		&lt;restriction (child of ComplexContent)
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?))
		&lt;/restriction&gt;	 */
	public Object visitRestriction(Restriction item) {
		Common parent = item.getParent();
		if (parent == null) {
			error(item, "&lt;restriction&gt; cannot be root element");
			return null;
		}
		boolean isComplex = parent.getKind() == Visitor.COMPLEXCONTENT;
		Exp saveAllow = checkAllow(item, isComplex ? 
COMPLEXEXTENSION_CHILDREN : SIMPLEEXTENSION_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String base = item.getBase();
			if (base == null) {
				error(item, "&lt;restriction&gt; must specify base 
type");
			}
			else if (isComplex){
				String prefix = getPrefix(base);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in base {0}", base);
				}
				else {
					fBaseRefs.add(item);
				}
			}
			else {
				checkSimpleType(item, "base", base);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;schema 
		  attributeFormDefault = (qualified | unqualified) : 
unqualified
		  blockDefault = (#all | List of (extension | restriction | 
substitution))  : ''
		  elementFormDefault = (qualified | unqualified) : unqualified
		  finalDefault = (#all | List of (extension | 
restriction))  : ''
		  id = ID 
		  targetNamespace = anyURI 
		  version = token 
		  xml:lang = language 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: ((include | import | redefine | annotation)*, 
(((simpleType | complexType | group | attributeGroup) | element | attribute | 
notation), annotation*)*)
		&lt;/schema&gt;
	 */
	public Object visitSchema(Schema item) {
		Exp saveAllow = checkAllow(item, SCHEMA_CHILDREN);
		if (!item.getSkip()) {
			String tn = item.getTargetNamespace();
			if (tn == null || (fRequiredNamespace != null &amp;&amp; !
tn.equals(fRequiredNamespace))) {
				if (fRequiredNamespace != null) {
					if (tn != null)
						error
(item, "targetNamespace=\"{0}\" must be \"{1}\"", tn, fRequiredNamespace);
					else {
						error(item, "targetNamespace 
must be specified as {0}", fRequiredNamespace);
						tn = "";
					}
					item.setTargetNamespace
(fRequiredNamespace);
				}
				else if (tn == null) {
					tn = "";
					item.setTargetNamespace("");
				}
			}
			String prefix = item.getPrefix(tn);
			if (prefix != null &amp;&amp; fRequiredNamespace != null &amp;&amp; !
tn.equals(fRequiredNamespace)) {
				// this will mask any previous definition
				item.addNamespace(prefix, fRequiredNamespace);
			}
			String attrForm = item.getAttributeFormDefault();
			if (attrForm == null || !checkFormValue
(item, "attributeFormDefault", attrForm))
				item.setAttributeFormDefault("unqualified");
			String elemForm = item.getElementFormDefault();
			if (elemForm == null || !checkFormValue
(item, "elementFormDefault", elemForm))
				item.setElementFormDefault("unqualified");
			String block = item.getBlockDefault();
			if (block == null || !checkBlockValue
(item, "blockDefault", block))
				item.setBlockDefault("");
			String fin = item.getFinalDefault();
			if (fin == null || !checkFinalValue
(item, "finalDefault", fin))
				item.setFinalDefault("");
			checkId(item);
			String version = item.getVersion();
			if (version != null &amp;&amp; !version.equals("1.0"))
				error(item, "version=\"{0}\" must be 1.0", 
version);
			String xmlLang = item.getXmlLang();
			if (xmlLang == null)
				item.setXmlLang("EN");
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkFinalValue(Schema item, String attrName, String 
fin) {
		if (!fin.equals("#all")) {
			String[] list = getList(fin);
			for (int i = 0; i &lt; list.length; i++) {
				String value = list[i];
				if (!value.equals("extension")
				&amp;&amp; !value.equals("restriction")) {
					error(item, INVALID_ATTR_VALUE, 
attrName, fin);
					return false;
				}
			}
		}
		return true;
	}

	private boolean checkBlockValue(Common item, String attrName, String 
block) {
		if (!block.equals("#all")) {
			String[] list = getList(block);
			for (int i = 0; i &lt; list.length; i++) {
				String value = list[i];
				if (!value.equals("extension")
				&amp;&amp; !value.equals("restriction")
				&amp;&amp; !value.equals("substitution")) {
					error(item, INVALID_ATTR_VALUE, 
attrName, block);
					return false;
				}
			}
		}
		return true;
	}

	private Exp checkAllow(Common item, Exp allowChild) {
		Exp deriv = fDeriv.deriv(fAllowChild, fFac.element
(item.getElementName()));
		if (fAllowChild != Exp.Null &amp;&amp; deriv == Exp.Null) {
			Common parent = item.getParent();
			if (parent != null)
				error(item, "{0} is not allowed as child of 
{1}",
					"&lt;"+item.getElementName()+"&gt;",
					"&lt;"+parent.getElementName()+"&gt;");
			else
				error(item, "{0} is not allowed as root 
element",
					"&lt;"+item.getElementName()+"&gt;");
		}
		fAllowChild = allowChild;
		return deriv;
	}
	
	private void checkEnd(Common item, Exp saveAllow) {
		if (fAllowChild != Exp.Null &amp;&amp; !fAllowChild.nullable()) {
			String [] required = fRequired.getRequired
(fAllowChild);
			String requiredList = getCommaList(required);
			error(item, "{0} missing children {1}",
				"&lt;"+item.getElementName()+"&gt;",
				requiredList);
		}
		fAllowChild = saveAllow;
	}

	private void forceEnd(Exp saveAllow) {
		fAllowChild = saveAllow;
	}

	private String getCommaList(String[] array) {
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i &lt; array.length; i++) {
			if (i &gt; 0)
				buf.append(", ");
			buf.append(array[i]);
		}
		return buf.toString();
	}

	private void error(Common item, String msg, Object arg1, Object arg2) {
		fParser.error(item.getOffset(), msg, arg1, arg2);
		item.setSkip(true);
	}

	private void error(Common item, String msg, Object arg) {
		fParser.error(item.getOffset(), msg, arg);
		item.setSkip(true);
	}

	private void error(Common item, String msg) {
		fParser.error(item.getOffset(), msg);
		item.setSkip(true);
	}

	/*
	 * &lt;selector 
		  id = ID 
		  xpath = a subset of XPath expression, see below 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/selector&gt;
	 */
	public Object visitSelector(Selector item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkXpath(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;sequence 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (element | group | choice | sequence 
| any)*)
		&lt;/sequence&gt;
	 */
	public Object visitSequence(Sequence item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;simpleContent 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | extension))
		&lt;/simpleContent&gt;
	 */
	public Object visitSimpleContent(SimpleContent item) {
		Exp saveAllow = checkAllow(item, SIMPLECONTENT_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;simpleType 
		  final = (#all | (list | union | restriction)) 
		  id = ID 
		  name = NCName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | list | union))
		&lt;/simpleType&gt;
	 */
	public Object visitSimpleType(SimpleType item) {
		Exp saveAllow = checkAllow(item, SIMPLETYPE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String fin = item.getFinal();
			if (fin != null)
				checkFinal(item, fin);
			String name = item.getName();
			boolean top = isTopLevel(item);
			if (name == null &amp;&amp; top)
				error(item, MISSING_ATTR, "name");
			else if (name != null &amp;&amp; !top)
				error(item, "name allowed only in top-level 
definition");
			else if (name != null) {
				checkSimpleTypeDef(item, name);
			}
			
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkFinal(Common item, String fin) {
		if (!fin.equals("#all") &amp;&amp; !fin.equals("list") &amp;&amp; !fin.equals
("union") &amp;&amp; !fin.equals("restriction"))
			error(item, INVALID_ATTR_VALUE, "final", fin);
	}

	/*
	 * 
	 */
	public Object visitTotalDigits(TotalDigits item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * &lt;union 
		  id = ID 
		  memberTypes = List of QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType*))
		&lt;/union&gt;
	 */
	public Object visitUnion(Union item) {
		Exp saveAllow = checkAllow(item, item.getMemberTypes() == 
null ? UNION_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String mem = item.getMemberTypes();
			if (mem != null) {
				// since list can contain both standard and 
user-defined types
				// defer all checking to ref checking phase
				fUnionRefs.add(item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;unique 
		  id = ID 
		  name = NCName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/unique&gt;
	 */
	public Object visitUnique(Unique item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null)
				error(item, MISSING_ATTR, "name");
			else if (checkNCName(item, "name", name)){
				String ns = item.getTargetNamespace();
				QName qn = new QName(ns, name);
				if (fIdentities.containsKey(qn) || 
fKeys.containsKey(qn))
					error(item, "identity constraint name 
{0} is already defined", name);
				else
					fIdentities.put(qn, item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkNCName(Common item, String attrName, String name) 
{
		if (name.indexOf(':') &gt;= 0) {
			error(item, "{0}=\"{1}\" must not contain a colon", 
attrName, name);
			return false;
		}
		return true;
	}

	/*
	 * 
	 */
	public Object visitWhiteSpace(WhiteSpace item) {
		visitFixedValueItem(item);
		return null;
	}

}</code>
      </source_code>
      <source_code type="class">
        <location start="61869" end="61915" />
        <code>public class Junk extends CheckSchemaVisitor {</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="2">
      <Enumeration lines="8">
        <Lines>
          <Line>1. It begins with:</Line>
          <Line />
          <Line />
          <Line />
          <Line>where CheckSchemaVisitor is the same as the file I supplied except that the</Line>
          <Line>inner classes have all been exported (by hand).</Line>
          <Line />
          <Line>2. It has a pass-through constructor to satisfy CheckSchemaVisitor.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="8">
        <Lines>
          <Line>- Team &gt; Show in Version Histroy.</Line>
          <Line>- pick the version with the appropriate date (around 2003-03-21)</Line>
          <Line>Thanks. But damn. Bugzilla is acting oddly. Every time I try any operation it</Line>
          <Line>asks me to re-login, and in the case of adding an attachment it loses the name</Line>
          <Line>of the attached file every time I log in. So please excuse me, but below is</Line>
          <Line>the original file where I saw the problem. There is probably more here than</Line>
          <Line>you need; removing all but the static class declarations beginning with STAR</Line>
          <Line>should compile and should be sufficient.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Given the following nested classes, I attempted to Refactor &gt; Convert nested 
type to top-level... on the Exp class.

	public abstract static class Exp {
		public static final int STAR = 1;
		public static final int UNION = 2;
		public static final int CONCAT = 3;
		public static final int ELEMENT = 4;
		public static final int EPSILON = 5;
		public static final int NULL = 6;
	
		protected int hash = Integer.MAX_VALUE;
		private static int unique = 0;
		public int id = unique++;
		public static final Exp Epsilon = new Eps();
		public static final Exp Null = new Exp() {
			public boolean nullable() {
				return false;
			}
			public Exp visit(ExpVisitor visitor) {
				return visitor.onNull(this);
			}
			public int getKind() {
				return NULL;
			}
		};
		public abstract boolean nullable();
		public abstract Exp visit(ExpVisitor visitor);
		public abstract int getKind();
	}
	public static class Eps extends Exp {
		public Eps() {
			id = Integer.MAX_VALUE;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onEpsilon(this);
		}
		public int getKind() {
			return EPSILON;
		}
	}
	public static class ExpVisitor {
		public Exp onEpsilon(Exp exp) { return Exp.Null; }
		public Exp onNull(Exp exp) { return Exp.Null; }
		public Exp onStar(Star exp) { return Exp.Null; }
		public Exp onUnion(UnionExp exp) { return Exp.Null; }
		public Exp onConcat(Concat exp) { return Exp.Null; }
		public Exp onElem(Elem exp) { return Exp.Null; }
	}

The result was that the Exp class was removed and a new Exp.java file was 
created with the following contents:

import com.objfac.xmleditor.schema.extmodel.CheckSchemaVisitor.Eps;
import com.objfac.xmleditor.schema.extmodel.CheckSchemaVisitor.ExpVisitor;

That's it! Where'd my class go? Thank heavens for undo.
Adam, can you please comment on this.
i cannot reproduce this problem - it creates the correct thing for me
i tried on 20030318 but this code has not been touched recently
Bob, any additional hints to reproduce ?
I would have been happy to share the source file with you, but since filing the
bug report I have refactored the code manually. My ignorance is such that I am
unable to recover the previous version from CVS and the local history has never
done anything for me. If you can suggest a way I might recapture that version
from the repository I will send it along.
Here is what I normally do:

- Team &gt; Show in Version Histroy. 
- pick the version with the appropriate date (around 2003-03-21)
Thanks. But damn. Bugzilla is acting oddly. Every time I try any operation it 
asks me to re-login, and in the case of adding an attachment it loses the name 
of the attached file every time I log in. So please excuse me, but below is 
the original file where I saw the problem. There is probably more here than 
you need; removing all but the static class declarations beginning with STAR 
should compile and should be sufficient.

/*
 * (c) Copyright 2003 Object Factory Inc. All rights reserved.
 */
package com.objfac.xmleditor.schema.extmodel;

import java.util.BitSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;

import com.objfac.xml.XMLCharacter;
import com.objfac.xml.schema.SchemaConstants;

/**
 * @author Bob Foster
 */
public class CheckSchemaVisitor extends Visitor {

	public String fRequiredNamespace;
	public ExtParser fParser;
	public HashSet fIds = new HashSet();
	public HashMap fAttributes = new HashMap();
	public HashMap fAttrGroups = new HashMap();
	public HashMap fElements = new HashMap();
	public HashMap fGroups = new HashMap();
	public HashMap fTypeNames = new HashMap();
	public HashMap fKeys = new HashMap();
	public HashMap fIdentities = new HashMap();
	public HashMap fNotations = new HashMap();
	public HashMap fSimpleTypes = new HashMap();
	
	/*
	 * References to these namespaces allowed by import.
	 */
	public HashSet fAllowRefs = new HashSet();

	/*
	 * These are simple refs through ref attribute in like item
	 */
	public LinkedList fAttributeRefs = new LinkedList();
	public LinkedList fAttrGroupRefs = new LinkedList();
	public LinkedList fElementRefs = new LinkedList();
	public LinkedList fGroupRefs = new LinkedList();
	
	/*
	 * These are type references through type attribute in CommonType item.
	 */
	public LinkedList fTypeRefs = new LinkedList();

	/*
	 * These are type references through base attributes in CommonBase 
item.
	 */
	public LinkedList fBaseRefs = new LinkedList();
	
	/*
	 * These are key references through refer attributes in KeyRef item
	 */
	public LinkedList fKeyRefs = new LinkedList();
	
	/*
	 * These are simple type references through xxx attributes in List 
item.
	 */
	public LinkedList fSimpleTypeRefs = new LinkedList();
	
	/*
	 * These lists of simple type refs through memberTypes attribute in 
Union item
	 */
	public LinkedList fUnionRefs = new LinkedList();

	private static Factory sFac = new Factory();
	private Factory fFac = new Factory();
	private DerivVisitor fDeriv = new DerivVisitor(fFac);
	private RequiredVisitor fRequired = new RequiredVisitor();
	
	private static final String INVALID_ATTR_VALUE = "invalid {0} value 
{0}";
	private static final String MISSING_ATTR = "missing required {0} 
attribute";
	
	public static final int STAR = 1;
	public static final int UNION = 2;
	public static final int CONCAT = 3;
	public static final int ELEMENT = 4;
	public static final int EPSILON = 5;
	public static final int NULL = 6;
	
	public abstract static class Exp {
		protected int hash = Integer.MAX_VALUE;
		private static int unique = 0;
		public int id = unique++;
		public static final Exp Epsilon = new Eps();
		public static final Exp Null = new Exp() {
			public boolean nullable() {
				return false;
			}
			public Exp visit(ExpVisitor visitor) {
				return visitor.onNull(this);
			}
			public int getKind() {
				return NULL;
			}
		};
		public abstract boolean nullable();
		public abstract Exp visit(ExpVisitor visitor);
		public abstract int getKind();
	}
	public static class Eps extends Exp {
		public Eps() {
			id = Integer.MAX_VALUE;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onEpsilon(this);
		}
		public int getKind() {
			return EPSILON;
		}
	}
	public abstract static class UnaryExp extends Exp {
		public Exp exp;
	}
	public abstract static class BinaryExp extends Exp {
		public Exp exp1, exp2;
	}
	public static class Star extends UnaryExp {
		public Star(Exp exp) {
			this.exp = exp;
		}
		public boolean equals(Object o) {
			return o instanceof Star
			&amp;&amp; ((Star)o).exp.equals(exp);
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp.hashCode() + STAR;
			return hash;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onStar(this);
		}
		public int getKind() {
			return STAR;
		}
	}
	public static class UnionExp extends BinaryExp {
		public UnionExp(Exp exp1, Exp exp2) {
			this.exp1 = exp1;
			this.exp2 = exp2;
		}
		public boolean equals(Object o) {
			if (!(o instanceof UnionExp)) return false;
			UnionExp other = (UnionExp) o;
			return (exp1.equals(other.exp1) &amp;&amp; exp2.equals
(other.exp2))
			|| (exp1.equals(other.exp2) &amp;&amp; exp2.equals
(other.exp1));
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp1.hashCode() + exp2.hashCode() + 
UNION;
			return hash;
		}
		public boolean nullable() {
			return exp1.nullable() || exp2.nullable();
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onUnion(this);
		}
		public int getKind() {
			return UNION;
		}
	}
	public static class Concat extends BinaryExp {
		public Concat(Exp exp1, Exp exp2) {
			this.exp1 = exp1;
			this.exp2 = exp2;
		}
		public boolean equals(Object o) {
			if (!(o instanceof Concat)) return false;
			Concat other = (Concat) o;
			return (exp1.equals(other.exp1) &amp;&amp; exp2.equals
(other.exp2));
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp1.hashCode() + exp2.hashCode() + 
CONCAT;
			return hash;
		}
		public boolean nullable() {
			return exp1.nullable() &amp;&amp; exp2.nullable();
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onConcat(this);
		}
		public int getKind() {
			return CONCAT;
		}
	}
	public static class Elem extends Exp {
		private String fNamespace;
		private String fLocalname;
		public Elem(String namespace, String localname) {
			fNamespace = namespace;
			fLocalname = localname;
		}
		public boolean equals(Object o) {
			if (!(o instanceof Elem)) return false;
			Elem other = (Elem) o;
			return fNamespace.equals(other.fNamespace) &amp;&amp; 
fLocalname.equals(other.fLocalname);
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = fNamespace.hashCode() + 
fLocalname.hashCode() + ELEMENT;
			return hash;
		}
		public boolean nullable() {
			return false;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onElem(this);
		}
		public int getKind() {
			return ELEMENT;
		}
	}
	public static class Factory {
		HashMap map = new HashMap();
		public Exp optional(Exp exp) {
			UnionExp union = new UnionExp(exp, Exp.Epsilon);
			return unique(union);
		}
		public Exp optional(String name) {
			return optional(element(name));
		}
		public Exp unique(Exp exp) {
			Exp result = (Exp) map.get(exp);
			if (result == null) {
				result = exp;
				map.put(result, result);
			}
			return result;
		}
		public Exp star(Exp exp) {
			if (exp == Exp.Epsilon || exp == Exp.Null)
				return exp;
			if (exp instanceof Star)
				return exp;
			Star star = new Star(exp);
			return unique(star);
		}
		public Exp star(String name) {
			return star(element(name));
		}
		public Exp plus(Exp exp) {
			Concat concat = new Concat(exp, star(exp));
			return unique(concat);
		}
		public Exp plus(String name) {
			return plus(element(name));
		}
		public Exp concat(Exp exp1, Exp exp2) {
			if (exp1 == Exp.Epsilon)
				return exp2;
			if (exp2 == Exp.Epsilon)
				return exp1;
			if (exp1 == Exp.Null || exp2 == Exp.Null)
				return Exp.Null;
			return unique(new Concat(exp1,exp2));
		}
		public Exp union(String[] names) {
			Exp result = Exp.Null;
			for (int i = 0; i &lt; names.length; i++) {
				Exp element = element(names[i]);
				result = union(result, element);
			}
			return result;
		}
		public Exp union(Exp exp1, Exp exp2) {
			if (exp1 == Exp.Epsilon &amp;&amp; exp2.nullable())
				return exp2;
			if (exp2 == Exp.Epsilon &amp;&amp; exp1.nullable())
				return exp1;
			if (exp1 == Exp.Null)
				return exp2;
			if (exp2 == Exp.Null)
				return exp1;
			UnionExp union = null;
			int kind1 = exp1.getKind();
			int kind2 = exp2.getKind();
			if (kind1 == UNION &amp;&amp; kind2 != UNION) {
				union = addToUnion((UnionExp)exp1, exp2);
			}
			else if (kind1 != UNION &amp;&amp; kind2 == UNION) {
				union = addToUnion((UnionExp)exp2, exp1);
			}
			else if (kind1 == UNION &amp;&amp; kind2 == UNION) {
				union = addAllToUnion((UnionExp)exp1, 
(UnionExp)exp2);
			}
			else {
				if (exp1.hashCode() &gt; exp2.hashCode()) {
					Exp tmp = exp1;
					exp1 = exp2;
					exp2 = tmp;
				}
				union = new UnionExp(exp1, exp2);
			}
			return unique(new UnionExp(exp1,exp2));
		}
		private UnionExp addAllToUnion(UnionExp union1, UnionExp 
union2) {
			int kind = union2.exp1.getKind();
			UnionExp union = addToUnion(union1, union2.exp2);
			if (kind == UNION) {
				return addAllToUnion(union, (UnionExp)
union2.exp1);
			}
			return addToUnion(union, union2.exp1);
		}
		private UnionExp addToUnion(UnionExp union, Exp exp) {
			int kind1 = union.exp1.getKind();
			int kind2 = union.exp2.getKind();
			if (kind1 != UNION) {
				int id1 = union.exp1.id;
				int id2 = union.exp2.id;
				int id3 = exp.id;
				if (id3 &lt; id1) {
					return new UnionExp(new UnionExp(exp, 
union.exp1), union.exp2);
				}
				if (id3 &lt; id2) {
					return new UnionExp(new UnionExp
(union.exp1, exp), union.exp2);
				}
				else {
					return new UnionExp(union, exp);
				}
			}
			int id2 = union.exp2.id;
			int id3 = exp.id;
			if (id3 &lt; id2) {
				return new UnionExp(addToUnion((UnionExp)
union.exp1, exp), union.exp2);
			}
			return new UnionExp(union, exp);
		}
		public Exp element(String namespace, String localname) {
			return unique(new Elem(namespace, localname));
		}
		public Exp element(String localname) {
			return unique(new Elem(SchemaConstants.XS_NAMESPACE, 
localname));
		}
	}
	public static class ExpVisitor {
		public Exp onEpsilon(Exp exp) { return Exp.Null; }
		public Exp onNull(Exp exp) { return Exp.Null; }
		public Exp onStar(Star exp) { return Exp.Null; }
		public Exp onUnion(UnionExp exp) { return Exp.Null; }
		public Exp onConcat(Concat exp) { return Exp.Null; }
		public Exp onElem(Elem exp) { return Exp.Null; }
	}
	public static class DerivVisitor extends ExpVisitor {
		private Factory fac;
		private Exp exp;
		private Exp wrt;
		public DerivVisitor(Factory factory) {
			this.fac = factory;
		}
		public Exp deriv(Exp exp, Exp wrt) {
			this.exp = exp;
			this.wrt = wrt;
			return exp.visit(this);
		}
		public Exp onStar(Star exp) {
			return fac.union(exp.exp.visit(this), exp);
		}
		public Exp onUnion(UnionExp exp) {
			return fac.union(exp.exp1.visit(this), exp.exp2.visit
(this));
		}
		public Exp onConcat(Concat exp) {
			if (exp.exp1.nullable())
				return fac.union(exp.exp1.visit(this), 
exp.exp2.visit(this));
			return fac.concat(exp.exp1.visit(this), exp.exp2);
		}
		public Exp onElem(Elem exp) {
			if (exp.equals(wrt))
				return Exp.Epsilon;
			return Exp.Null;
		}
	}
	public static class RequiredVisitor extends ExpVisitor {
		private LinkedList list;
		public String[] getRequired(Exp exp) {
			list = new LinkedList();
			exp.visit(this);
			return (String[]) list.toArray(new String[list.size
()]);
		}
		public Exp onConcat(Concat exp) {
			if (exp.exp1.nullable()) {
				//don't need to visit exp1
				if (!exp.exp2.nullable())
					return exp.exp2.visit(this);
			}
			return exp.exp1.visit(this);
		}

		public Exp onElem(Elem exp) {
			list.add(exp.fLocalname);
			return null;
		}

		public Exp onStar(Star exp) {
			return null;
		}

		public Exp onUnion(UnionExp exp) {
			// if either choice is nullable the union is nullable
			if (!exp.nullable()) {
				exp.exp1.visit(this);
				exp.exp2.visit(this);
			}
			return null;
		}
	}
	
	private Exp fAllowChild = sFac.element("schema");
	
	private static final String XSNS = SchemaConstants.XS_NAMESPACE;
	private static Exp ALLOW_NONE = Exp.Null;
	private static Exp ALLOW_ANNOTATION = sFac.optional(sFac.element
("annotation"));
	private static Exp REQUIRE_SIMPLETYPE =
	sFac.concat(
		sFac.optional(sFac.element("annotation")),
		sFac.element("simpleType"));
	
	//Content: ((include | import | redefine | annotation)*, (((simpleType 
| complexType | group | attributeGroup) | element | attribute | notation), 
annotation*)*)
	private static Exp SCHEMA_CHILDREN = 
		sFac.concat(
			sFac.star(
				sFac.union(new String[] 
{"include","import","redefine","annotation"})),
			sFac.star(
				sFac.concat(
					sFac.union(new String[] 
{"simpleType","complexType","group","attributeGroup","element","attribute","not
ation"}),
					sFac.star("annotation"))));
					
	//Content: (appinfo | documentation)*
	private static Exp ANNOTATION_CHILDREN =
		sFac.star(
			sFac.union(new String[] {"appinfo","documentation"}));
			
	//Content: (annotation?, (simpleType?))
	private static Exp ATTRIBUTE_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.optional("simpleType"));
			
	//Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
	private static Exp ATTRIBUTEGROUP_CHILDREN =
		sFac.concat(
			sFac.concat(
				sFac.optional("annotation"),
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"}))),
			sFac.optional("anyAttribute"));
			
	//Content: (annotation?, (element | group | choice | sequence | any)*)
	private static Exp CHOICE_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.star(
				sFac.union(new String[] 
{"element","group","choice","sequence","any"})));
				
	//Content: (annotation?, (restriction | extension))
	private static Exp COMPLEXCONTENT_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.union(new String[] {"restriction","extension"}));
	
	//Content: (annotation?, (restriction | extension))
	private static Exp SIMPLECONTENT_CHILDREN = COMPLEXCONTENT_CHILDREN;
			
	//Content: (annotation?, 
	//          (simpleContent | complexContent | ((group | all | choice | 
sequence)?, ((attribute | attributeGroup)*, anyAttribute?))))
	private static Exp COMPLEXTYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(
			sFac.union(new String[] 
{"simpleContent","complexContent"}),
			sFac.concat(
				sFac.optional(
					sFac.union(new String[] 
{"group","all","choice","sequence"})),
				sFac.concat(
					sFac.star(
						sFac.union(new String[] 
{"attribute","attributeGroup"})),
					sFac.optional("anyAttribute")))));
					
	//Content: (annotation?, ((simpleType | complexType)?, (unique | key | 
keyref)*))
	private static Exp ELEMENT_CHILDREN =
	sFac.concat(
		sFac.concat(
			sFac.optional("annotation"),
			sFac.optional(
				sFac.union(new String[] 
{"simpleType","complexType"}))),
		sFac.star(
			sFac.union(new String[] {"unique","key","keyref"})));
			
	//Content: (annotation?, (unique | key | keyref)*) ???
	private static Exp ELEMENTNOTYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.star(
			sFac.union(new String[] {"unique","key","keyref"})));
			
	//Content: (annotation?, ((group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?)))
	private static Exp COMPLEXEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.optional(
				sFac.union(new String[] 
{"group","all","choice","sequence"})),
			sFac.concat(
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"})),
				sFac.optional("anyAttribute"))));
				
	//Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
	private static Exp SIMPLEEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.star(
				sFac.union(new String[] 
{"attribute","attributeGroup"})),
			sFac.optional("anyAttribute")));
	
	//Content: (annotation?, (all | choice | sequence))
	private static Exp GROUP_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(new String[] {"all","choice","sequence"}));
	
	//Content: (annotation | (simpleType | complexType | group | 
attributeGroup))*
	private static Exp REDEFINE_CHILDREN =
	sFac.star(
		sFac.union(new String[] 
{"annotation","simpleType","complexType","group","attributeGroup"}));
	
	//Content: (annotation?, (selector, field+))
	private static Exp KEY_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.element("selector"),
			sFac.plus("field")));
	
	//Content: (annotation?, element*)
	private static Exp ALL_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.star("element"));
	
	//Content: (annotation?, (restriction | list | union))
	private static Exp SIMPLETYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(new String[] {"restriction","list","union"}));
	
	//Content: (annotation?, (simpleType*))
	//Content: (annotation?, (simpleType+)) -- used only in simpleType 
required context
	private static Exp UNION_CHILDREN =
	sFac.concat(
		sFac.optional(sFac.element("annotation")),
		sFac.plus("simpleType"));
	
	/**
	 * Constructor.
	 */
	public CheckSchemaVisitor(ExtParser parser, String requiredNamespace) {
		fParser = parser;
		fRequiredNamespace = requiredNamespace;
	}
	
	/*
	 * &lt;all 
		  id = ID 
		  maxOccurs = 1 : 1
		  minOccurs = (0 | 1) : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, element*)
		&lt;/all&gt;
	 */
	public Object visitAll(All item) {
		checkId(item);
		int max = checkMinMax(item);
		if (max != 1)
			error(item, "maxOccurs must be 1");
		Exp saveAllow = checkAllow(item, ALL_CHILDREN);
		item.visitChildren(this);
		checkEnd(item, saveAllow);
		return null;
	}

	/*
	 * &lt;annotation 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (appinfo | documentation)*
		&lt;/annotation&gt;
	 */
	public Object visitAnnotation(Annotation item) {
		Exp saveAllow = checkAllow(item, ANNOTATION_CHILDREN);
		item.visitChildren(this);
		checkEnd(item, saveAllow);
		return null;
	}

	/*
	 * &lt;any 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  namespace = ((##any | ##other) | List of (anyURI | 
(##targetNamespace | ##local)) )  : ##any
		  processContents = (lax | skip | strict) : strict
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/any&gt;
	 */
	public Object visitAny(Any item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			int max = checkMinMax(item);
			checkNamespace(item);
			checkProcessContents(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private int checkMinMax(CommonMinMax item) {
		int max = checkMaxOccurs(item);
		int min = checkMinOccurs(item);
		if (max &gt;= 0 &amp;&amp; min &gt;= 0 &amp;&amp; max &lt; min) {
			error(item, "minOccurs({0}) greater than maxOccurs
({1})",
				new Integer(min), new Integer(max));
			return 0;
		}
		else if (max == 0)
			item.setSkip(true);
		return max;
	}

	private int checkMinOccurs(CommonMinMax item) {
		String min = item.getMinOccurs();
		if (min == null) {
			item.setMinOccurs("1");
			return 1;
		}
		else {
			Common c = (Common) item;
			Common parent = c.getParent();
			if (parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE)
				error(c, "minOccurs not allowed for top-level 
item");
			int m = getInt(min);
			if (m &lt; 0) {
				error(item, "{1} is not a valid minOccurs 
value", min);
				item.setMinOccurs("0");
			}
			return m;
		}
	}

	private int checkMaxOccurs(CommonMinMax item) {
		String max = item.getMaxOccurs();
		if (max == null) {
			item.setMaxOccurs("1");
			return 1;
		}
		else {
			Common c = (Common) item;
			Common parent = c.getParent();
			if (parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE)
				error(c, "minOccurs not allowed for top-level 
item");
			if (!max.equals("unbounded")) {
				int m = getInt(max);
				if (m &lt; 0) {
					error(item, "{1} is not a valid 
maxOccurs value", max);
					item.setMaxOccurs("0");
				}
				return m;
			}
			else
				return Integer.MAX_VALUE;
		}
	}

	private int getInt(String s) {
		try {
			return Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return -1;
		}
	}

	private void checkId(Common item) {
		String id = item.getId();
		if (id != null) {
			if (fIds.contains(id))
				error(item, "element {0} id is not unique", 
id);
			else
				fIds.add(id);
		}
	}

	/*
	 * &lt;anyAttribute 
		  id = ID 
		  namespace = ((##any | ##other) | List of (anyURI | 
(##targetNamespace | ##local)) )  : ##any
		  processContents = (lax | skip | strict) : strict
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/anyAttribute&gt;
	 */
	public Object visitAnyAttribute(AnyAttribute item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkNamespace(item);
			checkProcessContents(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkProcessContents(CommonAny item) {
		String pc = item.getProcessContents();
		if (pc == null)
			item.setProcessContents("strict");
		else if (!pc.equals("lax") &amp;&amp; !pc.equals("skip") &amp;&amp; !pc.equals
("strict")) {
			error(item, "invalid processContents value {0}", pc);
			item.setProcessContents("strict");
		}
	}

	private void checkNamespace(CommonAny item) {
		String ns = item.getNamespace();
		if (ns == null) {
			item.setNamespace("##any");
		}
		else if (!ns.equals("##any") &amp;&amp; !ns.equals("##other")) {
			int pos = 0;
			while ((pos = ns.indexOf("##", pos)) &gt;= 0) {
				StringBuffer buf = new StringBuffer();
				for (int i = pos+2; i &lt; ns.length(); i++)
					if (XMLCharacter.isWhitespace(ns.charAt
(i)))
						break;
				String key = buf.toString();
				if (!key.equals("targetNamespace") &amp;&amp; !
key.equals("local"))
					error(item, "invalid namespace keyword 
##", key);
			}
		}
	}

	public Object visitAppInfo(AppInfo item) {
		// don't look at children
		return null;
	}

	/*
	 * &lt;attribute 
		  default = string 
		  fixed = string 
		  form = (qualified | unqualified)
		  id = ID 
		  name = NCName 
		  ref = QName 
		  type = QName 
		  use = (optional | prohibited | required) : optional
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?))
		&lt;/attribute&gt;
	 */
	public Object visitAttribute(Attribute item) {
		boolean havetype = item.getType() != null;
		boolean haveref = item.getRef() != null;
		Exp saveAllow = checkAllow(item, havetype || haveref ? 
ALLOW_ANNOTATION : ATTRIBUTE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			boolean isElement = false;
			checkForm(item, isElement);
			checkNameRef(item);
			checkUse(item);
			String type = item.getType();
			if (type != null) {
				if (haveref)
					error(item, "cannot specify type 
attribute with ref");
				String prefix = getPrefix(type);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in type name {0}", type);
				}
				else {
					fTypeRefs.add(item);
				}
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}
	
	private final QName QNAME = new QName("","");
	private QName qname(String ns, String ln) {
		QNAME.namespace = ns;
		QNAME.localname = ln;
		return QNAME;
	}

	private boolean checkNameRef(CommonNameRef item) {
		boolean haveref = false;
		Common parent = ((Common)item).getParent();
		String target = parent.getTargetNamespace();
		boolean requireName = parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE;
		if (requireName) {
			String name = item.getName();
			if (name == null) {
				error((Common)item, "missing required name 
attribute");
			}
			else if (fAttributes.containsKey(qname(target, name))) 
{
				error((Common)item, "attribute {0} declared 
more than once", name);
			}
			else if (checkNCName((Common) item, "name", name)) {
				Common c = (Common) item;
				QName qn = new QName(target, name);
				if (c.getKind() == Visitor.ATTRIBUTE) {
					fAttributes.put(qn, item);
				}
				else if (c.getKind() == 
Visitor.ATTRIBUTEGROUP) {
					fAttrGroups.put(qn, item);
				}
				else if (c.getKind() == Visitor.ELEMENT) {
					fElements.put(qn, item);
				}
				else if (c.getKind() == Visitor.GROUP)
					fGroups.put(qn, item);
			}
			String ref = item.getRef();
			if (ref != null)
				error((Common)item, "cannot specify ref 
attribute on top-level item");
		}
		else {
			String name = item.getName();
			String ref = item.getRef();
			if (name == null &amp;&amp; ref == null) {
				error((Common)item, "missing name or ref 
attribute");
			}
			else if (name != null &amp;&amp; ref != null) {
				error((Common)item, "can't specify both name 
and ref attributes");
			}
			else if (ref != null)
				haveref = true;
			else if (name == null)
				error((Common)item, "missing required ref 
attribute");
		}
		if (haveref) {
			Common c = (Common) item;
			if (c.getKind() == Visitor.ATTRIBUTE) {
				fAttributeRefs.add(item);
			}
			else if (c.getKind() == Visitor.ATTRIBUTEGROUP) {
				fAttrGroupRefs.add(item);
			}
			else if (c.getKind() == Visitor.ELEMENT) {
				fElementRefs.add(item);
			}
			else if (c.getKind() == Visitor.GROUP) {
				fGroupRefs.add(item);
			}
		}
		return haveref;
	}
	
	private void checkUse(CommonUse item) {
		String use = item.getUse();
		if (use == null)
			item.setUse("optional"); //$NON-NLS-1$
		else {
			if (!use.equals("optional") &amp;&amp; !use.equals("required") 
&amp;&amp; !use.equals("prohibited")) { //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
				error((Common)item, "invalid use attribute 
value {0}", use);
			}
		}
		
	}

	private void checkForm(CommonForm item, boolean isElement) {
		String form = item.getForm();
		if (form == null)
			setFormToDefault(item, isElement);
		else if (!checkFormValue((Common)item, "form", form)) //$NON-
NLS-1$
			setFormToDefault(item, isElement);
	}
	
	private void setFormToDefault(CommonForm item, boolean isElement) {
		Common c = (Common) item;
		item.setForm(isElement ? c.getElementFormDefault() : 
c.getAttributeFormDefault());
	}
	
	private boolean checkFormValue(Common item, String attrName, String 
value) {
		if (!value.equals("qualified") &amp;&amp; !value.equals
("unqualified")) { //$NON-NLS-1$//$NON-NLS-2$
			error(item, INVALID_ATTR_VALUE, attrName, value);
			return false;
		}
		return true;
	}

	/*
	 * &lt;attributeGroup 
		  id = ID 
		  name = NCName 
		  ref = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
		&lt;/attributeGroup&gt;
	 * &lt;attributeGroup 
		  id = ID 
		  ref = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/attributeGroup&gt;
	 */
	public Object visitAttributeGroup(AttributeGroup item) {
		Common parent = item.getParent();
		boolean top = parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE;
		Exp saveAllow = checkAllow(item, top ? 
ATTRIBUTEGROUP_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkNameRef(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;choice 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (element | group | choice | sequence 
| any)*)
		&lt;/choice&gt;
	 */
	public Object visitChoice(Choice item) {
		Exp saveAllow = checkAllow(item, CHOICE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;complexContent 
		  id = ID 
		  mixed = boolean 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | extension))
		&lt;/complexContent&gt;
	 */
	public Object visitComplexContent(ComplexContent item) {
		Exp saveAllow = checkAllow(item, COMPLEXCONTENT_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String mixed = item.getMixed();
			if (mixed == null)
				item.setMixed("false");
			else {
				boolean m = checkBoolean(item, "mixed", mixed);
				item.setMixed(m ? "true" : "false");
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkBoolean(Common item, String attname, String 
value) {
		boolean m = value.equals("true") || value.equals("0");
		if (!value.equals("true") &amp;&amp; !value.equals("false") &amp;&amp; !
value.equals("0") &amp;&amp; !value.equals("1"))
			error(item, "invalid value {0} for boolean attribute 
{1}", value, attname);
		return m;
	}

	/*
	 * &lt;complexType 
		  abstract = boolean : false
		  block = (#all | List of (extension | restriction)) 
		  final = (#all | List of (extension | restriction)) 
		  id = ID 
		  mixed = boolean : false
		  name = NCName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleContent | complexContent | 
((group | all | choice | sequence)?, ((attribute | attributeGroup)*, 
anyAttribute?))))
		&lt;/complexType&gt;
	 */
	public Object visitComplexType(ComplexType item) {
		Exp saveAllow = checkAllow(item, COMPLEXTYPE_CHILDREN);
		if (!item.getSkip()) {
			String abs = item.getAbstract();
			if (abs == null)
				item.setAbstract("false");
			else {
				boolean a = checkBoolean(item, "abstract", 
abs);
				item.setAbstract(a ? "true" : "false");
			}
			String block = item.getBlock();
			if (block != null) {
				if (!checkExtensionRestriction(item, "block", 
block))
					item.setBlock(null);
			}
			String fin = item.getFinal();
			if (fin != null) {
				if (!checkExtensionRestriction(item, "final", 
fin))
					item.setFinal(null);
			}
			checkId(item);
			String mixed = item.getMixed();
			if (mixed == null)
				item.setMixed("false");
			else {
				boolean m = checkBoolean(item, "mixed", mixed);
				item.setMixed(m ? "true" : "false");
			}
			String name = item.getName();
			Common parent = item.getParent();
			if (name == null) {
				if (parent.getKind() == Visitor.SCHEMA)
					error(item, "top-level complex type 
must have name");
			}
			else if (fTypeNames.containsKey(name)) {
				error(item, "complex type name {0} is already 
defined", name);
			}
			else {
				fTypeNames.put(new QName
(parent.getTargetNamespace(), name), item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkExtensionRestriction(Common item, String attname, 
String value) {
		if (value.equals("#all"))
			return true;
		String[] list = getList(value);
		if (list.length == 0)
			error(item, "attribute {0} must not be empty list", 
attname);
		for (int i = 0; i &lt; list.length; i++) {
			String v = list[i];
			if (!v.equals("extension") &amp;&amp; !v.equals
("restriction")) {
				error(item, "attribute {0} must be list of 
extension or restriction, not {1}", attname, v);
				return false;
			}
		}
		return true;
	}

	private boolean checkExtensionRestrictionSubstitution(Common item, 
String attname, String value) {
		if (value.equals("#all"))
			return true;
		String[] list = getList(value);
		if (list.length == 0)
			error(item, "attribute {0} must not be empty list", 
attname);
		for (int i = 0; i &lt; list.length; i++) {
			String v = list[i];
			if (!v.equals("extension") &amp;&amp; !v.equals("restriction") 
&amp;&amp; !v.equals("substitution")) {
				error(item, "attribute {0} must be list of 
extension or restriction, not {1}", attname, v);
				return false;
			}
		}
		return true;
	}

	private String[] getList(String value) {
		StringBuffer buf = new StringBuffer();
		LinkedList list = new LinkedList();
		for (int i = 0, n = value.length(); i &lt; n; i++) {
			char c = value.charAt(i);
			if (XMLCharacter.isWhitespace(c)) {
				if (buf.length() &gt; 0) {
					list.add(buf.toString());
					buf.setLength(0);
				}
			}
			else
				buf.append(c);
		}
		if (buf.length() &gt; 0) {
			list.add(buf.toString());
		}
		return (String[]) list.toArray(new String[list.size()]);
	}

	public Object visitDocumentation(Documentation item) {
		// don't visit children
		return null;
	}

	/*
	 * &lt;element 
		  abstract = boolean : false
		  block = (#all | List of (extension | restriction | 
substitution)) 
		  default = string 
		  final = (#all | List of (extension | restriction)) 
		  fixed = string 
		  form = (qualified | unqualified)
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  name = NCName 
		  nillable = boolean : false
		  ref = QName 
		  substitutionGroup = QName 
		  type = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((simpleType | complexType)?, (unique 
| key | keyref)*))
		&lt;/element&gt;
	 */
	public Object visitElement(Element item) {
		boolean havetype = item.getType() != null;
		boolean haveref = item.getRef() != null;
		Exp saveAllow = checkAllow(item, haveref || havetype ? 
ELEMENTNOTYPE_CHILDREN : ELEMENT_CHILDREN);
		if (!item.getSkip()) {
			String abs = item.getAbstract();
			if (abs == null)
				item.setAbstract("false");
			else {
				boolean a = checkBoolean(item, "abstract", 
abs);
				item.setAbstract(a ? "true" : "false");
			}
			String block = item.getBlock();
			if (block != null) {
				if (!checkExtensionRestrictionSubstitution
(item, "block", block))
					item.setBlock(null);
			}
			String fin = item.getFinal();
			if (fin != null) {
				if (!checkExtensionRestriction(item, "final", 
fin))
					item.setFinal(null);
			}
			boolean hasvalue = false;
			String def = item.getDefault();
			if (def != null) {
				hasvalue = true;
			}
			String fix = item.getFixed();
			if (fix != null) {
				hasvalue = true;
			}
			checkId(item);
			boolean isElement = true;
			checkForm(item, isElement);
			checkMinMax(item);
			String nil = item.getNillable();
			if (nil == null)
				item.setNillable("false");
			else {
				boolean a = checkBoolean(item, "nillable", 
nil);
				item.setNillable(a ? "true" : "false");
			}
			checkNameRef(item);
			String type = item.getType();
			if (type != null) {
				String prefix = getPrefix(type);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in type name {0}", type);
				}
				else {
					fTypeRefs.add(item);
				}
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private String getPrefix(String name) {
		int pos = name.indexOf(':');
		if (pos &gt;= 0)
			return name.substring(0, pos);
		return "";
	}

	/*
	 * &lt;enumeration 
		  id = ID 
		  value = anySimpleType 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/enumeration&gt;
	 */
	public Object visitEnumeration(Enumeration item) {
		visitValueItem(item);
		return null;
	}

	/*
	 * &lt;extension 
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
		&lt;/extension&gt;
	 * &lt;extension 
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?)))
		&lt;/extension&gt;
	 */
	public Object visitExtension(Extension item) {
		Common parent = item.getParent();
		if (parent == null) {
			error(item, "&lt;extension&gt; cannot be root element");
			return null;
		}
		boolean isComplex = parent.getKind() == Visitor.COMPLEXCONTENT;
		Exp saveAllow = checkAllow(item, isComplex ? 
COMPLEXEXTENSION_CHILDREN : SIMPLEEXTENSION_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String base = item.getBase();
			if (base == null) {
				error(item, "&lt;extension&gt; must specify base 
type");
			}
			else if (isComplex) {
				String prefix = getPrefix(base);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in base {0}", base);
				}
				else {
					fBaseRefs.add(item);
				}
			}
			else {
				checkSimpleType(item, "base", base);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;field 
		  id = ID 
		  xpath = a subset of XPath expression, see below 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/field&gt;
	 */
	public Object visitField(Field item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkXpath(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkXpath(CommonXpath item) {
		String xpath = item.getXpath();
		if (xpath == null) {
			error((Common)item, "missing required xpath 
attribute");
		}
		else
			checkXpathValue(item, xpath);
	}

	private void checkXpathValue(CommonXpath item, String xpath) {
		// TODO Auto-generated method stub
	}

	/*
	 * &lt;fractionDigits 
		  fixed = boolean : false
		  id = ID 
		  value = nonNegativeInteger 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/fractionDigits&gt;
	 */
	public Object visitFractionDigits(FractionDigits item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			String fixed = item.getFixed();
			if (fixed == null)
				item.setFixed("false");
			else {
				boolean b = checkBoolean(item, "fixed", fixed);
				item.setFixed(b ? "true" : "false");
			}
			checkId(item);
			String value = item.getValue();
			if (value == null) {
				error(item, "missing required value 
attribute");
			}
			else {
				int v = getInt(value);
				if (v &lt; 0)
					error(item, 
INVALID_ATTR_VALUE, "value", value);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;group (as child of schema or redefine)
		  name = NCName&gt;
		  Content: (annotation?, (all | choice | sequence))
		&lt;/group&gt;
		&lt;group (otherwise???)
		  ref = QName
		  minOccurs = integer : 1
		  maxOccurs = { integer | "unbounded" } : 1
		  Content: (annotation?)
		&lt;/group&gt;
	 */
	public Object visitGroup(Group item) {
		Exp saveAllow = checkAllow(item, isTopLevel(item) ? 
GROUP_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkNameRef(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}
	
	private boolean isTopLevel(Common item) {
		Common parent = item.getParent();
		return parent == null ||
			parent.getKind() == Visitor.SCHEMA || parent.getKind() 
== Visitor.REDEFINE;	
	}

	/*
	 * &lt;import 
		  id = ID 
		  namespace = anyURI 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/import&gt;
	 */
	public Object visitImport(Import item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String loc = item.getSchemaLocation();
			String ns = item.getNamespace();
			fAllowRefs.add(ns == null ? "" : ns);
			if (loc != null) {
				include(loc, ns == null ? "" : ns);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;include 
		  id = ID 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/include&gt;
	 */
	public Object visitInclude(Include item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String loc = item.getSchemaLocation();
			if (loc == null) {
				error(item, MISSING_ATTR, "schemaLocation");
			}
			else {
				include(loc, item.getTargetNamespace());
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void include(String loc, String namespace) {
		// recursively parse include
		String saveRequiredNamespace = fRequiredNamespace;
		fRequiredNamespace = namespace;
		try {
			fParser.parseInclude(loc, this);
		}
		finally {
			fRequiredNamespace = saveRequiredNamespace;
		}
	}

	/*
	 * &lt;key 
		  id = ID 
		  name = NCName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/key&gt;
	 */
	public Object visitKey(Key item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null) {
				error(item, MISSING_ATTR, "name");
			}
			else {
				String ns = item.getTargetNamespace();
				if (fKeys.containsKey(qname(ns, name))) {
					error(item, "key name {0} is already 
defined",name);
				}
				else
					fKeys.put(new QName(ns, name), item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;keyref 
		  id = ID 
		  name = NCName (required)
		  refer = QName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/keyref&gt;
	 */
	public Object visitKeyRef(KeyRef item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String ns = item.getTargetNamespace();
			String name = item.getName();
			if (name == null) {
				error(item, MISSING_ATTR, "name");
			}
			else  if (checkNCName(item, "name", name)) {
				QName qn = new QName(ns, name);
				if (fIdentities.containsKey(qn) || 
fKeys.containsKey(qn))
					error(item, "identity constraint name 
{0} is already defined", name);
				else
					fIdentities.put(qn, item);
			}
			String refer = item.getRefer();
			if (refer == null)
				error(item, MISSING_ATTR, "refer");
			else {
				fKeyRefs.add(item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;length 
		  fixed = boolean : false
		  id = ID 
		  value = nonNegativeInteger 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/length&gt;
	 */
	public Object visitLength(Length item) {
		visitFixedValueItem(item);
		return null;
	}

	private void visitFixedValueItem(CommonFixedValue item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkFixedValueItem(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
	}

	private void visitValueItem(CommonValue item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkValueItem(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
	}

	private void checkFixedValueItem(CommonFixedValue item) {
		checkId(item);
		String fixed = item.getFixed();
		if (fixed == null)
			fixed = "false";
		else
			checkBoolean(item, "fixed", fixed);
		checkValueItem(item);
	}

	private void checkValueItem(CommonValue item) {
		String value = item.getValue();
		if (value == null)
			error(item, MISSING_ATTR, "value");
		else {
			int v = getInt(value);
			if (v &lt; 0) {
				error(item, "value=\"{0}\" is not a number or 
negative");
			}
		}
	}

	/*
	 * &lt;list 
		  id = ID 
		  itemType = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?))
		&lt;/list&gt;
	 */
	public Object visitList(List item) {
		Exp saveAllow = checkAllow(item, item.getItemType() == null ? 
REQUIRE_SIMPLETYPE : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			String itemType = item.getItemType();
			if (itemType != null) {
				checkSimpleType(item, "itemType", itemType);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkSimpleType(Common item, String attrName, String 
type) {
		QName qn = getQName(item, type);
		if (qn.namespace != "?" &amp;&amp; qn.localname != "?") {
			if (qn.namespace.equals(XSNS)) {
				if (!SimpleType.TYPE.contains(qn.localname)) {
					error(item, "unknown standard type 
\"{0}\"", type);
				}
			}
			else {
				fSimpleTypeRefs.add(item);
			}
		}
	}

	private void checkSimpleTypeDef(SimpleType item, String name) {
		QName qn = getQName(item, name);
		if (qn.namespace != "?" &amp;&amp; qn.localname != "?") {
			// allow definitions in XS namespace iff they are 
predefined
			// this allows to parse schema for schemas
			if (qn.namespace.equals(XSNS)) {
				if (!SimpleType.TYPE.contains(qn.localname)) {
					error(item, "unknown standard type 
\"{0}\"", name);
				}
			}
			else if (fSimpleTypes.containsKey(qn)){
				error(item, "duplicate definition of 
simpleType {0}", name);
			}
			else {
				fSimpleTypes.put(qn, item);
			}
		}
	}

	private QName getQName(Common item, String name) {
		int pos = name.indexOf(':');
		String prefix = "";
		String localname = name;
		if (pos &gt; 0) {
			prefix = name.substring(0, pos);
			localname = name.substring(pos+1);
		}
		if (localname.length() == 0) {
			error(item, "zero-length localname \"{0}\"", name);
			localname = "?";
		}
		String namespace = item.getNamespace(prefix);
		if (namespace == null) {
			error(item, "unknown namespace for \"{0}\"", name);
			namespace = "?";
		}
		return new QName(namespace, localname);
	}

	/*
	 * 
	 */
	public Object visitMaxExclusive(MaxExclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMaxInclusive(MaxInclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMaxLength(MaxLength item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinExclusive(MinExclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinInclusive(MinInclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinLength(MinLength item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * &lt;notation 
		  id = ID 
		  name = NCName (required)
		  public = anyURI (required)
		  system = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/notation&gt;
	 */
	public Object visitNotation(Notation item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null)
				error(item, MISSING_ATTR, "name");
			else {
				if (fNotations.containsKey(name))
					error(item, "notation {0} is 
previously defined", name);
				else
					fNotations.put(name, item);
			}
			String pubid = item.getPublic();
			if (pubid == null)
				error(item, MISSING_ATTR, "public");
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * 
	 */
	public Object visitPattern(Pattern item) {
		visitValueItem(item);
		return null;
	}

	/*
	 * &lt;redefine 
		  id = ID 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation | (simpleType | complexType | group | 
attributeGroup))*
		&lt;/redefine&gt;
	 */
	public Object visitRedefine(Redefine item) {
		checkId(item);
		String loc = item.getSchemaLocation();
		if (loc == null) {
			error(item, MISSING_ATTR, "schemaLocation");
		}
		else {
			include(loc, item.getTargetNamespace());
			Exp saveAllow = checkAllow(item, REDEFINE_CHILDREN);
			if (!item.getSkip()) {
			
				item.visitChildren(this);
				checkEnd(item, saveAllow);
			}
			else
				forceEnd(saveAllow);
			return null;
		}
		return null;
	}

	/*
	 * &lt;restriction (child of SimpleContent or SimpleType)
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?, (minExclusive | 
minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | 
length | minLength | maxLength | enumeration | whiteSpace | pattern)*)?, 
((attribute | attributeGroup)*, anyAttribute?))
		&lt;/restriction&gt;
		&lt;restriction (child of ComplexContent)
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?))
		&lt;/restriction&gt;	 */
	public Object visitRestriction(Restriction item) {
		Common parent = item.getParent();
		if (parent == null) {
			error(item, "&lt;restriction&gt; cannot be root element");
			return null;
		}
		boolean isComplex = parent.getKind() == Visitor.COMPLEXCONTENT;
		Exp saveAllow = checkAllow(item, isComplex ? 
COMPLEXEXTENSION_CHILDREN : SIMPLEEXTENSION_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String base = item.getBase();
			if (base == null) {
				error(item, "&lt;restriction&gt; must specify base 
type");
			}
			else if (isComplex){
				String prefix = getPrefix(base);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in base {0}", base);
				}
				else {
					fBaseRefs.add(item);
				}
			}
			else {
				checkSimpleType(item, "base", base);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;schema 
		  attributeFormDefault = (qualified | unqualified) : 
unqualified
		  blockDefault = (#all | List of (extension | restriction | 
substitution))  : ''
		  elementFormDefault = (qualified | unqualified) : unqualified
		  finalDefault = (#all | List of (extension | 
restriction))  : ''
		  id = ID 
		  targetNamespace = anyURI 
		  version = token 
		  xml:lang = language 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: ((include | import | redefine | annotation)*, 
(((simpleType | complexType | group | attributeGroup) | element | attribute | 
notation), annotation*)*)
		&lt;/schema&gt;
	 */
	public Object visitSchema(Schema item) {
		Exp saveAllow = checkAllow(item, SCHEMA_CHILDREN);
		if (!item.getSkip()) {
			String tn = item.getTargetNamespace();
			if (tn == null || (fRequiredNamespace != null &amp;&amp; !
tn.equals(fRequiredNamespace))) {
				if (fRequiredNamespace != null) {
					if (tn != null)
						error
(item, "targetNamespace=\"{0}\" must be \"{1}\"", tn, fRequiredNamespace);
					else {
						error(item, "targetNamespace 
must be specified as {0}", fRequiredNamespace);
						tn = "";
					}
					item.setTargetNamespace
(fRequiredNamespace);
				}
				else if (tn == null) {
					tn = "";
					item.setTargetNamespace("");
				}
			}
			String prefix = item.getPrefix(tn);
			if (prefix != null &amp;&amp; fRequiredNamespace != null &amp;&amp; !
tn.equals(fRequiredNamespace)) {
				// this will mask any previous definition
				item.addNamespace(prefix, fRequiredNamespace);
			}
			String attrForm = item.getAttributeFormDefault();
			if (attrForm == null || !checkFormValue
(item, "attributeFormDefault", attrForm))
				item.setAttributeFormDefault("unqualified");
			String elemForm = item.getElementFormDefault();
			if (elemForm == null || !checkFormValue
(item, "elementFormDefault", elemForm))
				item.setElementFormDefault("unqualified");
			String block = item.getBlockDefault();
			if (block == null || !checkBlockValue
(item, "blockDefault", block))
				item.setBlockDefault("");
			String fin = item.getFinalDefault();
			if (fin == null || !checkFinalValue
(item, "finalDefault", fin))
				item.setFinalDefault("");
			checkId(item);
			String version = item.getVersion();
			if (version != null &amp;&amp; !version.equals("1.0"))
				error(item, "version=\"{0}\" must be 1.0", 
version);
			String xmlLang = item.getXmlLang();
			if (xmlLang == null)
				item.setXmlLang("EN");
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkFinalValue(Schema item, String attrName, String 
fin) {
		if (!fin.equals("#all")) {
			String[] list = getList(fin);
			for (int i = 0; i &lt; list.length; i++) {
				String value = list[i];
				if (!value.equals("extension")
				&amp;&amp; !value.equals("restriction")) {
					error(item, INVALID_ATTR_VALUE, 
attrName, fin);
					return false;
				}
			}
		}
		return true;
	}

	private boolean checkBlockValue(Common item, String attrName, String 
block) {
		if (!block.equals("#all")) {
			String[] list = getList(block);
			for (int i = 0; i &lt; list.length; i++) {
				String value = list[i];
				if (!value.equals("extension")
				&amp;&amp; !value.equals("restriction")
				&amp;&amp; !value.equals("substitution")) {
					error(item, INVALID_ATTR_VALUE, 
attrName, block);
					return false;
				}
			}
		}
		return true;
	}

	private Exp checkAllow(Common item, Exp allowChild) {
		Exp deriv = fDeriv.deriv(fAllowChild, fFac.element
(item.getElementName()));
		if (fAllowChild != Exp.Null &amp;&amp; deriv == Exp.Null) {
			Common parent = item.getParent();
			if (parent != null)
				error(item, "{0} is not allowed as child of 
{1}",
					"&lt;"+item.getElementName()+"&gt;",
					"&lt;"+parent.getElementName()+"&gt;");
			else
				error(item, "{0} is not allowed as root 
element",
					"&lt;"+item.getElementName()+"&gt;");
		}
		fAllowChild = allowChild;
		return deriv;
	}
	
	private void checkEnd(Common item, Exp saveAllow) {
		if (fAllowChild != Exp.Null &amp;&amp; !fAllowChild.nullable()) {
			String [] required = fRequired.getRequired
(fAllowChild);
			String requiredList = getCommaList(required);
			error(item, "{0} missing children {1}",
				"&lt;"+item.getElementName()+"&gt;",
				requiredList);
		}
		fAllowChild = saveAllow;
	}

	private void forceEnd(Exp saveAllow) {
		fAllowChild = saveAllow;
	}

	private String getCommaList(String[] array) {
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i &lt; array.length; i++) {
			if (i &gt; 0)
				buf.append(", ");
			buf.append(array[i]);
		}
		return buf.toString();
	}

	private void error(Common item, String msg, Object arg1, Object arg2) {
		fParser.error(item.getOffset(), msg, arg1, arg2);
		item.setSkip(true);
	}

	private void error(Common item, String msg, Object arg) {
		fParser.error(item.getOffset(), msg, arg);
		item.setSkip(true);
	}

	private void error(Common item, String msg) {
		fParser.error(item.getOffset(), msg);
		item.setSkip(true);
	}

	/*
	 * &lt;selector 
		  id = ID 
		  xpath = a subset of XPath expression, see below 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/selector&gt;
	 */
	public Object visitSelector(Selector item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkXpath(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;sequence 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (element | group | choice | sequence 
| any)*)
		&lt;/sequence&gt;
	 */
	public Object visitSequence(Sequence item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;simpleContent 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | extension))
		&lt;/simpleContent&gt;
	 */
	public Object visitSimpleContent(SimpleContent item) {
		Exp saveAllow = checkAllow(item, SIMPLECONTENT_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;simpleType 
		  final = (#all | (list | union | restriction)) 
		  id = ID 
		  name = NCName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | list | union))
		&lt;/simpleType&gt;
	 */
	public Object visitSimpleType(SimpleType item) {
		Exp saveAllow = checkAllow(item, SIMPLETYPE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String fin = item.getFinal();
			if (fin != null)
				checkFinal(item, fin);
			String name = item.getName();
			boolean top = isTopLevel(item);
			if (name == null &amp;&amp; top)
				error(item, MISSING_ATTR, "name");
			else if (name != null &amp;&amp; !top)
				error(item, "name allowed only in top-level 
definition");
			else if (name != null) {
				checkSimpleTypeDef(item, name);
			}
			
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkFinal(Common item, String fin) {
		if (!fin.equals("#all") &amp;&amp; !fin.equals("list") &amp;&amp; !fin.equals
("union") &amp;&amp; !fin.equals("restriction"))
			error(item, INVALID_ATTR_VALUE, "final", fin);
	}

	/*
	 * 
	 */
	public Object visitTotalDigits(TotalDigits item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * &lt;union 
		  id = ID 
		  memberTypes = List of QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType*))
		&lt;/union&gt;
	 */
	public Object visitUnion(Union item) {
		Exp saveAllow = checkAllow(item, item.getMemberTypes() == 
null ? UNION_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String mem = item.getMemberTypes();
			if (mem != null) {
				// since list can contain both standard and 
user-defined types
				// defer all checking to ref checking phase
				fUnionRefs.add(item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;unique 
		  id = ID 
		  name = NCName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/unique&gt;
	 */
	public Object visitUnique(Unique item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null)
				error(item, MISSING_ATTR, "name");
			else if (checkNCName(item, "name", name)){
				String ns = item.getTargetNamespace();
				QName qn = new QName(ns, name);
				if (fIdentities.containsKey(qn) || 
fKeys.containsKey(qn))
					error(item, "identity constraint name 
{0} is already defined", name);
				else
					fIdentities.put(qn, item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkNCName(Common item, String attrName, String name) 
{
		if (name.indexOf(':') &gt;= 0) {
			error(item, "{0}=\"{1}\" must not contain a colon", 
attrName, name);
			return false;
		}
		return true;
	}

	/*
	 * 
	 */
	public Object visitWhiteSpace(WhiteSpace item) {
		visitFixedValueItem(item);
		return null;
	}

}

Can't reproduce using the striped down attached to this PR. Without a 
reproducable case there is little we can do.
Created attachment 4311
The file used to reproduce the problem
So you were able to reproduce the problem? Excellent!
Oh, I see, this is the file you used to _try_ to reproduce the problem. Oh,
well. Thanks for trying. No response required.
I spoke too soon. I can make it fail every time with a test case that is the
same as your cut-down example except:

1. It begins with:

public class Junk extends CheckSchemaVisitor {

where CheckSchemaVisitor is the same as the file I supplied except that the
inner classes have all been exported (by hand).

2. It has a pass-through constructor to satisfy CheckSchemaVisitor.

So obviously there is something about the original CheckSchemaVisitor that
causes this to fail. Unfortunately, I'm not willing to furnish the dozens of
files it would take for you to repro this exactly. I'm still searching for a
cut-down example that is sufficient to show the problem.
I'm afraid I'm going to have to give up on this one. I can make it fail with a
very large test case. I can make it succeed by successively removing methods in
the test case. But I can't make the test case small enough to send you and I'm
out of time to spend on this.
Without a reproducable case this is hard to track down.
Bob, i'm going to close this report.
Please reopen if you have a reproducible test case.</WithStack>
    <WithOutStack>Given the following nested classes, I attempted to Refactor &gt; Convert nested 
type to top-level... on the Exp class.

	public abstract static class Exp {
		public static final int STAR = 1;
		public static final int UNION = 2;
		public static final int CONCAT = 3;
		public static final int ELEMENT = 4;
		public static final int EPSILON = 5;
		public static final int NULL = 6;
	
		protected int hash = Integer.MAX_VALUE;
		private static int unique = 0;
		public int id = unique++;
		public static final Exp Epsilon = new Eps();
		public static final Exp Null = new Exp() {
			public boolean nullable() {
				return false;
			}
			public Exp visit(ExpVisitor visitor) {
				return visitor.onNull(this);
			}
			public int getKind() {
				return NULL;
			}
		};
		public abstract boolean nullable();
		public abstract Exp visit(ExpVisitor visitor);
		public abstract int getKind();
	}
	public static class Eps extends Exp {
		public Eps() {
			id = Integer.MAX_VALUE;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onEpsilon(this);
		}
		public int getKind() {
			return EPSILON;
		}
	}
	public static class ExpVisitor {
		public Exp onEpsilon(Exp exp) { return Exp.Null; }
		public Exp onNull(Exp exp) { return Exp.Null; }
		public Exp onStar(Star exp) { return Exp.Null; }
		public Exp onUnion(UnionExp exp) { return Exp.Null; }
		public Exp onConcat(Concat exp) { return Exp.Null; }
		public Exp onElem(Elem exp) { return Exp.Null; }
	}

The result was that the Exp class was removed and a new Exp.java file was 
created with the following contents:

import com.objfac.xmleditor.schema.extmodel.CheckSchemaVisitor.Eps;
import com.objfac.xmleditor.schema.extmodel.CheckSchemaVisitor.ExpVisitor;

That's it! Where'd my class go? Thank heavens for undo.
Adam, can you please comment on this.
i cannot reproduce this problem - it creates the correct thing for me
i tried on 20030318 but this code has not been touched recently
Bob, any additional hints to reproduce ?
I would have been happy to share the source file with you, but since filing the
bug report I have refactored the code manually. My ignorance is such that I am
unable to recover the previous version from CVS and the local history has never
done anything for me. If you can suggest a way I might recapture that version
from the repository I will send it along.
Here is what I normally do:

- Team &gt; Show in Version Histroy. 
- pick the version with the appropriate date (around 2003-03-21)
Thanks. But damn. Bugzilla is acting oddly. Every time I try any operation it 
asks me to re-login, and in the case of adding an attachment it loses the name 
of the attached file every time I log in. So please excuse me, but below is 
the original file where I saw the problem. There is probably more here than 
you need; removing all but the static class declarations beginning with STAR 
should compile and should be sufficient.

/*
 * (c) Copyright 2003 Object Factory Inc. All rights reserved.
 */
package com.objfac.xmleditor.schema.extmodel;

import java.util.BitSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;

import com.objfac.xml.XMLCharacter;
import com.objfac.xml.schema.SchemaConstants;

/**
 * @author Bob Foster
 */
public class CheckSchemaVisitor extends Visitor {

	public String fRequiredNamespace;
	public ExtParser fParser;
	public HashSet fIds = new HashSet();
	public HashMap fAttributes = new HashMap();
	public HashMap fAttrGroups = new HashMap();
	public HashMap fElements = new HashMap();
	public HashMap fGroups = new HashMap();
	public HashMap fTypeNames = new HashMap();
	public HashMap fKeys = new HashMap();
	public HashMap fIdentities = new HashMap();
	public HashMap fNotations = new HashMap();
	public HashMap fSimpleTypes = new HashMap();
	
	/*
	 * References to these namespaces allowed by import.
	 */
	public HashSet fAllowRefs = new HashSet();

	/*
	 * These are simple refs through ref attribute in like item
	 */
	public LinkedList fAttributeRefs = new LinkedList();
	public LinkedList fAttrGroupRefs = new LinkedList();
	public LinkedList fElementRefs = new LinkedList();
	public LinkedList fGroupRefs = new LinkedList();
	
	/*
	 * These are type references through type attribute in CommonType item.
	 */
	public LinkedList fTypeRefs = new LinkedList();

	/*
	 * These are type references through base attributes in CommonBase 
item.
	 */
	public LinkedList fBaseRefs = new LinkedList();
	
	/*
	 * These are key references through refer attributes in KeyRef item
	 */
	public LinkedList fKeyRefs = new LinkedList();
	
	/*
	 * These are simple type references through xxx attributes in List 
item.
	 */
	public LinkedList fSimpleTypeRefs = new LinkedList();
	
	/*
	 * These lists of simple type refs through memberTypes attribute in 
Union item
	 */
	public LinkedList fUnionRefs = new LinkedList();

	private static Factory sFac = new Factory();
	private Factory fFac = new Factory();
	private DerivVisitor fDeriv = new DerivVisitor(fFac);
	private RequiredVisitor fRequired = new RequiredVisitor();
	
	private static final String INVALID_ATTR_VALUE = "invalid {0} value 
{0}";
	private static final String MISSING_ATTR = "missing required {0} 
attribute";
	
	public static final int STAR = 1;
	public static final int UNION = 2;
	public static final int CONCAT = 3;
	public static final int ELEMENT = 4;
	public static final int EPSILON = 5;
	public static final int NULL = 6;
	
	public abstract static class Exp {
		protected int hash = Integer.MAX_VALUE;
		private static int unique = 0;
		public int id = unique++;
		public static final Exp Epsilon = new Eps();
		public static final Exp Null = new Exp() {
			public boolean nullable() {
				return false;
			}
			public Exp visit(ExpVisitor visitor) {
				return visitor.onNull(this);
			}
			public int getKind() {
				return NULL;
			}
		};
		public abstract boolean nullable();
		public abstract Exp visit(ExpVisitor visitor);
		public abstract int getKind();
	}
	public static class Eps extends Exp {
		public Eps() {
			id = Integer.MAX_VALUE;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onEpsilon(this);
		}
		public int getKind() {
			return EPSILON;
		}
	}
	public abstract static class UnaryExp extends Exp {
		public Exp exp;
	}
	public abstract static class BinaryExp extends Exp {
		public Exp exp1, exp2;
	}
	public static class Star extends UnaryExp {
		public Star(Exp exp) {
			this.exp = exp;
		}
		public boolean equals(Object o) {
			return o instanceof Star
			&amp;&amp; ((Star)o).exp.equals(exp);
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp.hashCode() + STAR;
			return hash;
		}
		public boolean nullable() {
			return true;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onStar(this);
		}
		public int getKind() {
			return STAR;
		}
	}
	public static class UnionExp extends BinaryExp {
		public UnionExp(Exp exp1, Exp exp2) {
			this.exp1 = exp1;
			this.exp2 = exp2;
		}
		public boolean equals(Object o) {
			if (!(o instanceof UnionExp)) return false;
			UnionExp other = (UnionExp) o;
			return (exp1.equals(other.exp1) &amp;&amp; exp2.equals
(other.exp2))
			|| (exp1.equals(other.exp2) &amp;&amp; exp2.equals
(other.exp1));
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp1.hashCode() + exp2.hashCode() + 
UNION;
			return hash;
		}
		public boolean nullable() {
			return exp1.nullable() || exp2.nullable();
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onUnion(this);
		}
		public int getKind() {
			return UNION;
		}
	}
	public static class Concat extends BinaryExp {
		public Concat(Exp exp1, Exp exp2) {
			this.exp1 = exp1;
			this.exp2 = exp2;
		}
		public boolean equals(Object o) {
			if (!(o instanceof Concat)) return false;
			Concat other = (Concat) o;
			return (exp1.equals(other.exp1) &amp;&amp; exp2.equals
(other.exp2));
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = exp1.hashCode() + exp2.hashCode() + 
CONCAT;
			return hash;
		}
		public boolean nullable() {
			return exp1.nullable() &amp;&amp; exp2.nullable();
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onConcat(this);
		}
		public int getKind() {
			return CONCAT;
		}
	}
	public static class Elem extends Exp {
		private String fNamespace;
		private String fLocalname;
		public Elem(String namespace, String localname) {
			fNamespace = namespace;
			fLocalname = localname;
		}
		public boolean equals(Object o) {
			if (!(o instanceof Elem)) return false;
			Elem other = (Elem) o;
			return fNamespace.equals(other.fNamespace) &amp;&amp; 
fLocalname.equals(other.fLocalname);
		}
		public int hashCode() {
			if (hash == Integer.MAX_VALUE)
				hash = fNamespace.hashCode() + 
fLocalname.hashCode() + ELEMENT;
			return hash;
		}
		public boolean nullable() {
			return false;
		}
		public Exp visit(ExpVisitor visitor) {
			return visitor.onElem(this);
		}
		public int getKind() {
			return ELEMENT;
		}
	}
	public static class Factory {
		HashMap map = new HashMap();
		public Exp optional(Exp exp) {
			UnionExp union = new UnionExp(exp, Exp.Epsilon);
			return unique(union);
		}
		public Exp optional(String name) {
			return optional(element(name));
		}
		public Exp unique(Exp exp) {
			Exp result = (Exp) map.get(exp);
			if (result == null) {
				result = exp;
				map.put(result, result);
			}
			return result;
		}
		public Exp star(Exp exp) {
			if (exp == Exp.Epsilon || exp == Exp.Null)
				return exp;
			if (exp instanceof Star)
				return exp;
			Star star = new Star(exp);
			return unique(star);
		}
		public Exp star(String name) {
			return star(element(name));
		}
		public Exp plus(Exp exp) {
			Concat concat = new Concat(exp, star(exp));
			return unique(concat);
		}
		public Exp plus(String name) {
			return plus(element(name));
		}
		public Exp concat(Exp exp1, Exp exp2) {
			if (exp1 == Exp.Epsilon)
				return exp2;
			if (exp2 == Exp.Epsilon)
				return exp1;
			if (exp1 == Exp.Null || exp2 == Exp.Null)
				return Exp.Null;
			return unique(new Concat(exp1,exp2));
		}
		public Exp union(String[] names) {
			Exp result = Exp.Null;
			for (int i = 0; i &lt; names.length; i++) {
				Exp element = element(names[i]);
				result = union(result, element);
			}
			return result;
		}
		public Exp union(Exp exp1, Exp exp2) {
			if (exp1 == Exp.Epsilon &amp;&amp; exp2.nullable())
				return exp2;
			if (exp2 == Exp.Epsilon &amp;&amp; exp1.nullable())
				return exp1;
			if (exp1 == Exp.Null)
				return exp2;
			if (exp2 == Exp.Null)
				return exp1;
			UnionExp union = null;
			int kind1 = exp1.getKind();
			int kind2 = exp2.getKind();
			if (kind1 == UNION &amp;&amp; kind2 != UNION) {
				union = addToUnion((UnionExp)exp1, exp2);
			}
			else if (kind1 != UNION &amp;&amp; kind2 == UNION) {
				union = addToUnion((UnionExp)exp2, exp1);
			}
			else if (kind1 == UNION &amp;&amp; kind2 == UNION) {
				union = addAllToUnion((UnionExp)exp1, 
(UnionExp)exp2);
			}
			else {
				if (exp1.hashCode() &gt; exp2.hashCode()) {
					Exp tmp = exp1;
					exp1 = exp2;
					exp2 = tmp;
				}
				union = new UnionExp(exp1, exp2);
			}
			return unique(new UnionExp(exp1,exp2));
		}
		private UnionExp addAllToUnion(UnionExp union1, UnionExp 
union2) {
			int kind = union2.exp1.getKind();
			UnionExp union = addToUnion(union1, union2.exp2);
			if (kind == UNION) {
				return addAllToUnion(union, (UnionExp)
union2.exp1);
			}
			return addToUnion(union, union2.exp1);
		}
		private UnionExp addToUnion(UnionExp union, Exp exp) {
			int kind1 = union.exp1.getKind();
			int kind2 = union.exp2.getKind();
			if (kind1 != UNION) {
				int id1 = union.exp1.id;
				int id2 = union.exp2.id;
				int id3 = exp.id;
				if (id3 &lt; id1) {
					return new UnionExp(new UnionExp(exp, 
union.exp1), union.exp2);
				}
				if (id3 &lt; id2) {
					return new UnionExp(new UnionExp
(union.exp1, exp), union.exp2);
				}
				else {
					return new UnionExp(union, exp);
				}
			}
			int id2 = union.exp2.id;
			int id3 = exp.id;
			if (id3 &lt; id2) {
				return new UnionExp(addToUnion((UnionExp)
union.exp1, exp), union.exp2);
			}
			return new UnionExp(union, exp);
		}
		public Exp element(String namespace, String localname) {
			return unique(new Elem(namespace, localname));
		}
		public Exp element(String localname) {
			return unique(new Elem(SchemaConstants.XS_NAMESPACE, 
localname));
		}
	}
	public static class ExpVisitor {
		public Exp onEpsilon(Exp exp) { return Exp.Null; }
		public Exp onNull(Exp exp) { return Exp.Null; }
		public Exp onStar(Star exp) { return Exp.Null; }
		public Exp onUnion(UnionExp exp) { return Exp.Null; }
		public Exp onConcat(Concat exp) { return Exp.Null; }
		public Exp onElem(Elem exp) { return Exp.Null; }
	}
	public static class DerivVisitor extends ExpVisitor {
		private Factory fac;
		private Exp exp;
		private Exp wrt;
		public DerivVisitor(Factory factory) {
			this.fac = factory;
		}
		public Exp deriv(Exp exp, Exp wrt) {
			this.exp = exp;
			this.wrt = wrt;
			return exp.visit(this);
		}
		public Exp onStar(Star exp) {
			return fac.union(exp.exp.visit(this), exp);
		}
		public Exp onUnion(UnionExp exp) {
			return fac.union(exp.exp1.visit(this), exp.exp2.visit
(this));
		}
		public Exp onConcat(Concat exp) {
			if (exp.exp1.nullable())
				return fac.union(exp.exp1.visit(this), 
exp.exp2.visit(this));
			return fac.concat(exp.exp1.visit(this), exp.exp2);
		}
		public Exp onElem(Elem exp) {
			if (exp.equals(wrt))
				return Exp.Epsilon;
			return Exp.Null;
		}
	}
	public static class RequiredVisitor extends ExpVisitor {
		private LinkedList list;
		public String[] getRequired(Exp exp) {
			list = new LinkedList();
			exp.visit(this);
			return (String[]) list.toArray(new String[list.size
()]);
		}
		public Exp onConcat(Concat exp) {
			if (exp.exp1.nullable()) {
				//don't need to visit exp1
				if (!exp.exp2.nullable())
					return exp.exp2.visit(this);
			}
			return exp.exp1.visit(this);
		}

		public Exp onElem(Elem exp) {
			list.add(exp.fLocalname);
			return null;
		}

		public Exp onStar(Star exp) {
			return null;
		}

		public Exp onUnion(UnionExp exp) {
			// if either choice is nullable the union is nullable
			if (!exp.nullable()) {
				exp.exp1.visit(this);
				exp.exp2.visit(this);
			}
			return null;
		}
	}
	
	private Exp fAllowChild = sFac.element("schema");
	
	private static final String XSNS = SchemaConstants.XS_NAMESPACE;
	private static Exp ALLOW_NONE = Exp.Null;
	private static Exp ALLOW_ANNOTATION = sFac.optional(sFac.element
("annotation"));
	private static Exp REQUIRE_SIMPLETYPE =
	sFac.concat(
		sFac.optional(sFac.element("annotation")),
		sFac.element("simpleType"));
	
	//Content: ((include | import | redefine | annotation)*, (((simpleType 
| complexType | group | attributeGroup) | element | attribute | notation), 
annotation*)*)
	private static Exp SCHEMA_CHILDREN = 
		sFac.concat(
			sFac.star(
				sFac.union(new String[] 
{"include","import","redefine","annotation"})),
			sFac.star(
				sFac.concat(
					sFac.union(new String[] 
{"simpleType","complexType","group","attributeGroup","element","attribute","not
ation"}),
					sFac.star("annotation"))));
					
	//Content: (appinfo | documentation)*
	private static Exp ANNOTATION_CHILDREN =
		sFac.star(
			sFac.union(new String[] {"appinfo","documentation"}));
			
	//Content: (annotation?, (simpleType?))
	private static Exp ATTRIBUTE_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.optional("simpleType"));
			
	//Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
	private static Exp ATTRIBUTEGROUP_CHILDREN =
		sFac.concat(
			sFac.concat(
				sFac.optional("annotation"),
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"}))),
			sFac.optional("anyAttribute"));
			
	//Content: (annotation?, (element | group | choice | sequence | any)*)
	private static Exp CHOICE_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.star(
				sFac.union(new String[] 
{"element","group","choice","sequence","any"})));
				
	//Content: (annotation?, (restriction | extension))
	private static Exp COMPLEXCONTENT_CHILDREN =
		sFac.concat(
			sFac.optional("annotation"),
			sFac.union(new String[] {"restriction","extension"}));
	
	//Content: (annotation?, (restriction | extension))
	private static Exp SIMPLECONTENT_CHILDREN = COMPLEXCONTENT_CHILDREN;
			
	//Content: (annotation?, 
	//          (simpleContent | complexContent | ((group | all | choice | 
sequence)?, ((attribute | attributeGroup)*, anyAttribute?))))
	private static Exp COMPLEXTYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(
			sFac.union(new String[] 
{"simpleContent","complexContent"}),
			sFac.concat(
				sFac.optional(
					sFac.union(new String[] 
{"group","all","choice","sequence"})),
				sFac.concat(
					sFac.star(
						sFac.union(new String[] 
{"attribute","attributeGroup"})),
					sFac.optional("anyAttribute")))));
					
	//Content: (annotation?, ((simpleType | complexType)?, (unique | key | 
keyref)*))
	private static Exp ELEMENT_CHILDREN =
	sFac.concat(
		sFac.concat(
			sFac.optional("annotation"),
			sFac.optional(
				sFac.union(new String[] 
{"simpleType","complexType"}))),
		sFac.star(
			sFac.union(new String[] {"unique","key","keyref"})));
			
	//Content: (annotation?, (unique | key | keyref)*) ???
	private static Exp ELEMENTNOTYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.star(
			sFac.union(new String[] {"unique","key","keyref"})));
			
	//Content: (annotation?, ((group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?)))
	private static Exp COMPLEXEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.optional(
				sFac.union(new String[] 
{"group","all","choice","sequence"})),
			sFac.concat(
				sFac.star(
					sFac.union(new String[] 
{"attribute","attributeGroup"})),
				sFac.optional("anyAttribute"))));
				
	//Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
	private static Exp SIMPLEEXTENSION_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.star(
				sFac.union(new String[] 
{"attribute","attributeGroup"})),
			sFac.optional("anyAttribute")));
	
	//Content: (annotation?, (all | choice | sequence))
	private static Exp GROUP_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(new String[] {"all","choice","sequence"}));
	
	//Content: (annotation | (simpleType | complexType | group | 
attributeGroup))*
	private static Exp REDEFINE_CHILDREN =
	sFac.star(
		sFac.union(new String[] 
{"annotation","simpleType","complexType","group","attributeGroup"}));
	
	//Content: (annotation?, (selector, field+))
	private static Exp KEY_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.concat(
			sFac.element("selector"),
			sFac.plus("field")));
	
	//Content: (annotation?, element*)
	private static Exp ALL_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.star("element"));
	
	//Content: (annotation?, (restriction | list | union))
	private static Exp SIMPLETYPE_CHILDREN =
	sFac.concat(
		sFac.optional("annotation"),
		sFac.union(new String[] {"restriction","list","union"}));
	
	//Content: (annotation?, (simpleType*))
	//Content: (annotation?, (simpleType+)) -- used only in simpleType 
required context
	private static Exp UNION_CHILDREN =
	sFac.concat(
		sFac.optional(sFac.element("annotation")),
		sFac.plus("simpleType"));
	
	/**
	 * Constructor.
	 */
	public CheckSchemaVisitor(ExtParser parser, String requiredNamespace) {
		fParser = parser;
		fRequiredNamespace = requiredNamespace;
	}
	
	/*
	 * &lt;all 
		  id = ID 
		  maxOccurs = 1 : 1
		  minOccurs = (0 | 1) : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, element*)
		&lt;/all&gt;
	 */
	public Object visitAll(All item) {
		checkId(item);
		int max = checkMinMax(item);
		if (max != 1)
			error(item, "maxOccurs must be 1");
		Exp saveAllow = checkAllow(item, ALL_CHILDREN);
		item.visitChildren(this);
		checkEnd(item, saveAllow);
		return null;
	}

	/*
	 * &lt;annotation 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (appinfo | documentation)*
		&lt;/annotation&gt;
	 */
	public Object visitAnnotation(Annotation item) {
		Exp saveAllow = checkAllow(item, ANNOTATION_CHILDREN);
		item.visitChildren(this);
		checkEnd(item, saveAllow);
		return null;
	}

	/*
	 * &lt;any 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  namespace = ((##any | ##other) | List of (anyURI | 
(##targetNamespace | ##local)) )  : ##any
		  processContents = (lax | skip | strict) : strict
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/any&gt;
	 */
	public Object visitAny(Any item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			int max = checkMinMax(item);
			checkNamespace(item);
			checkProcessContents(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private int checkMinMax(CommonMinMax item) {
		int max = checkMaxOccurs(item);
		int min = checkMinOccurs(item);
		if (max &gt;= 0 &amp;&amp; min &gt;= 0 &amp;&amp; max &lt; min) {
			error(item, "minOccurs({0}) greater than maxOccurs
({1})",
				new Integer(min), new Integer(max));
			return 0;
		}
		else if (max == 0)
			item.setSkip(true);
		return max;
	}

	private int checkMinOccurs(CommonMinMax item) {
		String min = item.getMinOccurs();
		if (min == null) {
			item.setMinOccurs("1");
			return 1;
		}
		else {
			Common c = (Common) item;
			Common parent = c.getParent();
			if (parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE)
				error(c, "minOccurs not allowed for top-level 
item");
			int m = getInt(min);
			if (m &lt; 0) {
				error(item, "{1} is not a valid minOccurs 
value", min);
				item.setMinOccurs("0");
			}
			return m;
		}
	}

	private int checkMaxOccurs(CommonMinMax item) {
		String max = item.getMaxOccurs();
		if (max == null) {
			item.setMaxOccurs("1");
			return 1;
		}
		else {
			Common c = (Common) item;
			Common parent = c.getParent();
			if (parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE)
				error(c, "minOccurs not allowed for top-level 
item");
			if (!max.equals("unbounded")) {
				int m = getInt(max);
				if (m &lt; 0) {
					error(item, "{1} is not a valid 
maxOccurs value", max);
					item.setMaxOccurs("0");
				}
				return m;
			}
			else
				return Integer.MAX_VALUE;
		}
	}

	private int getInt(String s) {
		try {
			return Integer.parseInt(s);
		} catch (NumberFormatException e) {
			return -1;
		}
	}

	private void checkId(Common item) {
		String id = item.getId();
		if (id != null) {
			if (fIds.contains(id))
				error(item, "element {0} id is not unique", 
id);
			else
				fIds.add(id);
		}
	}

	/*
	 * &lt;anyAttribute 
		  id = ID 
		  namespace = ((##any | ##other) | List of (anyURI | 
(##targetNamespace | ##local)) )  : ##any
		  processContents = (lax | skip | strict) : strict
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/anyAttribute&gt;
	 */
	public Object visitAnyAttribute(AnyAttribute item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkNamespace(item);
			checkProcessContents(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkProcessContents(CommonAny item) {
		String pc = item.getProcessContents();
		if (pc == null)
			item.setProcessContents("strict");
		else if (!pc.equals("lax") &amp;&amp; !pc.equals("skip") &amp;&amp; !pc.equals
("strict")) {
			error(item, "invalid processContents value {0}", pc);
			item.setProcessContents("strict");
		}
	}

	private void checkNamespace(CommonAny item) {
		String ns = item.getNamespace();
		if (ns == null) {
			item.setNamespace("##any");
		}
		else if (!ns.equals("##any") &amp;&amp; !ns.equals("##other")) {
			int pos = 0;
			while ((pos = ns.indexOf("##", pos)) &gt;= 0) {
				StringBuffer buf = new StringBuffer();
				for (int i = pos+2; i &lt; ns.length(); i++)
					if (XMLCharacter.isWhitespace(ns.charAt
(i)))
						break;
				String key = buf.toString();
				if (!key.equals("targetNamespace") &amp;&amp; !
key.equals("local"))
					error(item, "invalid namespace keyword 
##", key);
			}
		}
	}

	public Object visitAppInfo(AppInfo item) {
		// don't look at children
		return null;
	}

	/*
	 * &lt;attribute 
		  default = string 
		  fixed = string 
		  form = (qualified | unqualified)
		  id = ID 
		  name = NCName 
		  ref = QName 
		  type = QName 
		  use = (optional | prohibited | required) : optional
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?))
		&lt;/attribute&gt;
	 */
	public Object visitAttribute(Attribute item) {
		boolean havetype = item.getType() != null;
		boolean haveref = item.getRef() != null;
		Exp saveAllow = checkAllow(item, havetype || haveref ? 
ALLOW_ANNOTATION : ATTRIBUTE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			boolean isElement = false;
			checkForm(item, isElement);
			checkNameRef(item);
			checkUse(item);
			String type = item.getType();
			if (type != null) {
				if (haveref)
					error(item, "cannot specify type 
attribute with ref");
				String prefix = getPrefix(type);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in type name {0}", type);
				}
				else {
					fTypeRefs.add(item);
				}
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}
	
	private final QName QNAME = new QName("","");
	private QName qname(String ns, String ln) {
		QNAME.namespace = ns;
		QNAME.localname = ln;
		return QNAME;
	}

	private boolean checkNameRef(CommonNameRef item) {
		boolean haveref = false;
		Common parent = ((Common)item).getParent();
		String target = parent.getTargetNamespace();
		boolean requireName = parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE;
		if (requireName) {
			String name = item.getName();
			if (name == null) {
				error((Common)item, "missing required name 
attribute");
			}
			else if (fAttributes.containsKey(qname(target, name))) 
{
				error((Common)item, "attribute {0} declared 
more than once", name);
			}
			else if (checkNCName((Common) item, "name", name)) {
				Common c = (Common) item;
				QName qn = new QName(target, name);
				if (c.getKind() == Visitor.ATTRIBUTE) {
					fAttributes.put(qn, item);
				}
				else if (c.getKind() == 
Visitor.ATTRIBUTEGROUP) {
					fAttrGroups.put(qn, item);
				}
				else if (c.getKind() == Visitor.ELEMENT) {
					fElements.put(qn, item);
				}
				else if (c.getKind() == Visitor.GROUP)
					fGroups.put(qn, item);
			}
			String ref = item.getRef();
			if (ref != null)
				error((Common)item, "cannot specify ref 
attribute on top-level item");
		}
		else {
			String name = item.getName();
			String ref = item.getRef();
			if (name == null &amp;&amp; ref == null) {
				error((Common)item, "missing name or ref 
attribute");
			}
			else if (name != null &amp;&amp; ref != null) {
				error((Common)item, "can't specify both name 
and ref attributes");
			}
			else if (ref != null)
				haveref = true;
			else if (name == null)
				error((Common)item, "missing required ref 
attribute");
		}
		if (haveref) {
			Common c = (Common) item;
			if (c.getKind() == Visitor.ATTRIBUTE) {
				fAttributeRefs.add(item);
			}
			else if (c.getKind() == Visitor.ATTRIBUTEGROUP) {
				fAttrGroupRefs.add(item);
			}
			else if (c.getKind() == Visitor.ELEMENT) {
				fElementRefs.add(item);
			}
			else if (c.getKind() == Visitor.GROUP) {
				fGroupRefs.add(item);
			}
		}
		return haveref;
	}
	
	private void checkUse(CommonUse item) {
		String use = item.getUse();
		if (use == null)
			item.setUse("optional"); //$NON-NLS-1$
		else {
			if (!use.equals("optional") &amp;&amp; !use.equals("required") 
&amp;&amp; !use.equals("prohibited")) { //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
				error((Common)item, "invalid use attribute 
value {0}", use);
			}
		}
		
	}

	private void checkForm(CommonForm item, boolean isElement) {
		String form = item.getForm();
		if (form == null)
			setFormToDefault(item, isElement);
		else if (!checkFormValue((Common)item, "form", form)) //$NON-
NLS-1$
			setFormToDefault(item, isElement);
	}
	
	private void setFormToDefault(CommonForm item, boolean isElement) {
		Common c = (Common) item;
		item.setForm(isElement ? c.getElementFormDefault() : 
c.getAttributeFormDefault());
	}
	
	private boolean checkFormValue(Common item, String attrName, String 
value) {
		if (!value.equals("qualified") &amp;&amp; !value.equals
("unqualified")) { //$NON-NLS-1$//$NON-NLS-2$
			error(item, INVALID_ATTR_VALUE, attrName, value);
			return false;
		}
		return true;
	}

	/*
	 * &lt;attributeGroup 
		  id = ID 
		  name = NCName 
		  ref = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
		&lt;/attributeGroup&gt;
	 * &lt;attributeGroup 
		  id = ID 
		  ref = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/attributeGroup&gt;
	 */
	public Object visitAttributeGroup(AttributeGroup item) {
		Common parent = item.getParent();
		boolean top = parent.getKind() == Visitor.SCHEMA || 
parent.getKind() == Visitor.REDEFINE;
		Exp saveAllow = checkAllow(item, top ? 
ATTRIBUTEGROUP_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkNameRef(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;choice 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (element | group | choice | sequence 
| any)*)
		&lt;/choice&gt;
	 */
	public Object visitChoice(Choice item) {
		Exp saveAllow = checkAllow(item, CHOICE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;complexContent 
		  id = ID 
		  mixed = boolean 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | extension))
		&lt;/complexContent&gt;
	 */
	public Object visitComplexContent(ComplexContent item) {
		Exp saveAllow = checkAllow(item, COMPLEXCONTENT_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String mixed = item.getMixed();
			if (mixed == null)
				item.setMixed("false");
			else {
				boolean m = checkBoolean(item, "mixed", mixed);
				item.setMixed(m ? "true" : "false");
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkBoolean(Common item, String attname, String 
value) {
		boolean m = value.equals("true") || value.equals("0");
		if (!value.equals("true") &amp;&amp; !value.equals("false") &amp;&amp; !
value.equals("0") &amp;&amp; !value.equals("1"))
			error(item, "invalid value {0} for boolean attribute 
{1}", value, attname);
		return m;
	}

	/*
	 * &lt;complexType 
		  abstract = boolean : false
		  block = (#all | List of (extension | restriction)) 
		  final = (#all | List of (extension | restriction)) 
		  id = ID 
		  mixed = boolean : false
		  name = NCName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleContent | complexContent | 
((group | all | choice | sequence)?, ((attribute | attributeGroup)*, 
anyAttribute?))))
		&lt;/complexType&gt;
	 */
	public Object visitComplexType(ComplexType item) {
		Exp saveAllow = checkAllow(item, COMPLEXTYPE_CHILDREN);
		if (!item.getSkip()) {
			String abs = item.getAbstract();
			if (abs == null)
				item.setAbstract("false");
			else {
				boolean a = checkBoolean(item, "abstract", 
abs);
				item.setAbstract(a ? "true" : "false");
			}
			String block = item.getBlock();
			if (block != null) {
				if (!checkExtensionRestriction(item, "block", 
block))
					item.setBlock(null);
			}
			String fin = item.getFinal();
			if (fin != null) {
				if (!checkExtensionRestriction(item, "final", 
fin))
					item.setFinal(null);
			}
			checkId(item);
			String mixed = item.getMixed();
			if (mixed == null)
				item.setMixed("false");
			else {
				boolean m = checkBoolean(item, "mixed", mixed);
				item.setMixed(m ? "true" : "false");
			}
			String name = item.getName();
			Common parent = item.getParent();
			if (name == null) {
				if (parent.getKind() == Visitor.SCHEMA)
					error(item, "top-level complex type 
must have name");
			}
			else if (fTypeNames.containsKey(name)) {
				error(item, "complex type name {0} is already 
defined", name);
			}
			else {
				fTypeNames.put(new QName
(parent.getTargetNamespace(), name), item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkExtensionRestriction(Common item, String attname, 
String value) {
		if (value.equals("#all"))
			return true;
		String[] list = getList(value);
		if (list.length == 0)
			error(item, "attribute {0} must not be empty list", 
attname);
		for (int i = 0; i &lt; list.length; i++) {
			String v = list[i];
			if (!v.equals("extension") &amp;&amp; !v.equals
("restriction")) {
				error(item, "attribute {0} must be list of 
extension or restriction, not {1}", attname, v);
				return false;
			}
		}
		return true;
	}

	private boolean checkExtensionRestrictionSubstitution(Common item, 
String attname, String value) {
		if (value.equals("#all"))
			return true;
		String[] list = getList(value);
		if (list.length == 0)
			error(item, "attribute {0} must not be empty list", 
attname);
		for (int i = 0; i &lt; list.length; i++) {
			String v = list[i];
			if (!v.equals("extension") &amp;&amp; !v.equals("restriction") 
&amp;&amp; !v.equals("substitution")) {
				error(item, "attribute {0} must be list of 
extension or restriction, not {1}", attname, v);
				return false;
			}
		}
		return true;
	}

	private String[] getList(String value) {
		StringBuffer buf = new StringBuffer();
		LinkedList list = new LinkedList();
		for (int i = 0, n = value.length(); i &lt; n; i++) {
			char c = value.charAt(i);
			if (XMLCharacter.isWhitespace(c)) {
				if (buf.length() &gt; 0) {
					list.add(buf.toString());
					buf.setLength(0);
				}
			}
			else
				buf.append(c);
		}
		if (buf.length() &gt; 0) {
			list.add(buf.toString());
		}
		return (String[]) list.toArray(new String[list.size()]);
	}

	public Object visitDocumentation(Documentation item) {
		// don't visit children
		return null;
	}

	/*
	 * &lt;element 
		  abstract = boolean : false
		  block = (#all | List of (extension | restriction | 
substitution)) 
		  default = string 
		  final = (#all | List of (extension | restriction)) 
		  fixed = string 
		  form = (qualified | unqualified)
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  name = NCName 
		  nillable = boolean : false
		  ref = QName 
		  substitutionGroup = QName 
		  type = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((simpleType | complexType)?, (unique 
| key | keyref)*))
		&lt;/element&gt;
	 */
	public Object visitElement(Element item) {
		boolean havetype = item.getType() != null;
		boolean haveref = item.getRef() != null;
		Exp saveAllow = checkAllow(item, haveref || havetype ? 
ELEMENTNOTYPE_CHILDREN : ELEMENT_CHILDREN);
		if (!item.getSkip()) {
			String abs = item.getAbstract();
			if (abs == null)
				item.setAbstract("false");
			else {
				boolean a = checkBoolean(item, "abstract", 
abs);
				item.setAbstract(a ? "true" : "false");
			}
			String block = item.getBlock();
			if (block != null) {
				if (!checkExtensionRestrictionSubstitution
(item, "block", block))
					item.setBlock(null);
			}
			String fin = item.getFinal();
			if (fin != null) {
				if (!checkExtensionRestriction(item, "final", 
fin))
					item.setFinal(null);
			}
			boolean hasvalue = false;
			String def = item.getDefault();
			if (def != null) {
				hasvalue = true;
			}
			String fix = item.getFixed();
			if (fix != null) {
				hasvalue = true;
			}
			checkId(item);
			boolean isElement = true;
			checkForm(item, isElement);
			checkMinMax(item);
			String nil = item.getNillable();
			if (nil == null)
				item.setNillable("false");
			else {
				boolean a = checkBoolean(item, "nillable", 
nil);
				item.setNillable(a ? "true" : "false");
			}
			checkNameRef(item);
			String type = item.getType();
			if (type != null) {
				String prefix = getPrefix(type);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in type name {0}", type);
				}
				else {
					fTypeRefs.add(item);
				}
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private String getPrefix(String name) {
		int pos = name.indexOf(':');
		if (pos &gt;= 0)
			return name.substring(0, pos);
		return "";
	}

	/*
	 * &lt;enumeration 
		  id = ID 
		  value = anySimpleType 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/enumeration&gt;
	 */
	public Object visitEnumeration(Enumeration item) {
		visitValueItem(item);
		return null;
	}

	/*
	 * &lt;extension 
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((attribute | attributeGroup)*, 
anyAttribute?))
		&lt;/extension&gt;
	 * &lt;extension 
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, ((group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?)))
		&lt;/extension&gt;
	 */
	public Object visitExtension(Extension item) {
		Common parent = item.getParent();
		if (parent == null) {
			error(item, "&lt;extension&gt; cannot be root element");
			return null;
		}
		boolean isComplex = parent.getKind() == Visitor.COMPLEXCONTENT;
		Exp saveAllow = checkAllow(item, isComplex ? 
COMPLEXEXTENSION_CHILDREN : SIMPLEEXTENSION_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String base = item.getBase();
			if (base == null) {
				error(item, "&lt;extension&gt; must specify base 
type");
			}
			else if (isComplex) {
				String prefix = getPrefix(base);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in base {0}", base);
				}
				else {
					fBaseRefs.add(item);
				}
			}
			else {
				checkSimpleType(item, "base", base);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;field 
		  id = ID 
		  xpath = a subset of XPath expression, see below 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/field&gt;
	 */
	public Object visitField(Field item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkXpath(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkXpath(CommonXpath item) {
		String xpath = item.getXpath();
		if (xpath == null) {
			error((Common)item, "missing required xpath 
attribute");
		}
		else
			checkXpathValue(item, xpath);
	}

	private void checkXpathValue(CommonXpath item, String xpath) {
		// TODO Auto-generated method stub
	}

	/*
	 * &lt;fractionDigits 
		  fixed = boolean : false
		  id = ID 
		  value = nonNegativeInteger 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/fractionDigits&gt;
	 */
	public Object visitFractionDigits(FractionDigits item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			String fixed = item.getFixed();
			if (fixed == null)
				item.setFixed("false");
			else {
				boolean b = checkBoolean(item, "fixed", fixed);
				item.setFixed(b ? "true" : "false");
			}
			checkId(item);
			String value = item.getValue();
			if (value == null) {
				error(item, "missing required value 
attribute");
			}
			else {
				int v = getInt(value);
				if (v &lt; 0)
					error(item, 
INVALID_ATTR_VALUE, "value", value);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;group (as child of schema or redefine)
		  name = NCName&gt;
		  Content: (annotation?, (all | choice | sequence))
		&lt;/group&gt;
		&lt;group (otherwise???)
		  ref = QName
		  minOccurs = integer : 1
		  maxOccurs = { integer | "unbounded" } : 1
		  Content: (annotation?)
		&lt;/group&gt;
	 */
	public Object visitGroup(Group item) {
		Exp saveAllow = checkAllow(item, isTopLevel(item) ? 
GROUP_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkNameRef(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}
	
	private boolean isTopLevel(Common item) {
		Common parent = item.getParent();
		return parent == null ||
			parent.getKind() == Visitor.SCHEMA || parent.getKind() 
== Visitor.REDEFINE;	
	}

	/*
	 * &lt;import 
		  id = ID 
		  namespace = anyURI 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/import&gt;
	 */
	public Object visitImport(Import item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String loc = item.getSchemaLocation();
			String ns = item.getNamespace();
			fAllowRefs.add(ns == null ? "" : ns);
			if (loc != null) {
				include(loc, ns == null ? "" : ns);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;include 
		  id = ID 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/include&gt;
	 */
	public Object visitInclude(Include item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String loc = item.getSchemaLocation();
			if (loc == null) {
				error(item, MISSING_ATTR, "schemaLocation");
			}
			else {
				include(loc, item.getTargetNamespace());
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void include(String loc, String namespace) {
		// recursively parse include
		String saveRequiredNamespace = fRequiredNamespace;
		fRequiredNamespace = namespace;
		try {
			fParser.parseInclude(loc, this);
		}
		finally {
			fRequiredNamespace = saveRequiredNamespace;
		}
	}

	/*
	 * &lt;key 
		  id = ID 
		  name = NCName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/key&gt;
	 */
	public Object visitKey(Key item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null) {
				error(item, MISSING_ATTR, "name");
			}
			else {
				String ns = item.getTargetNamespace();
				if (fKeys.containsKey(qname(ns, name))) {
					error(item, "key name {0} is already 
defined",name);
				}
				else
					fKeys.put(new QName(ns, name), item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;keyref 
		  id = ID 
		  name = NCName (required)
		  refer = QName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/keyref&gt;
	 */
	public Object visitKeyRef(KeyRef item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String ns = item.getTargetNamespace();
			String name = item.getName();
			if (name == null) {
				error(item, MISSING_ATTR, "name");
			}
			else  if (checkNCName(item, "name", name)) {
				QName qn = new QName(ns, name);
				if (fIdentities.containsKey(qn) || 
fKeys.containsKey(qn))
					error(item, "identity constraint name 
{0} is already defined", name);
				else
					fIdentities.put(qn, item);
			}
			String refer = item.getRefer();
			if (refer == null)
				error(item, MISSING_ATTR, "refer");
			else {
				fKeyRefs.add(item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;length 
		  fixed = boolean : false
		  id = ID 
		  value = nonNegativeInteger 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/length&gt;
	 */
	public Object visitLength(Length item) {
		visitFixedValueItem(item);
		return null;
	}

	private void visitFixedValueItem(CommonFixedValue item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkFixedValueItem(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
	}

	private void visitValueItem(CommonValue item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkValueItem(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
	}

	private void checkFixedValueItem(CommonFixedValue item) {
		checkId(item);
		String fixed = item.getFixed();
		if (fixed == null)
			fixed = "false";
		else
			checkBoolean(item, "fixed", fixed);
		checkValueItem(item);
	}

	private void checkValueItem(CommonValue item) {
		String value = item.getValue();
		if (value == null)
			error(item, MISSING_ATTR, "value");
		else {
			int v = getInt(value);
			if (v &lt; 0) {
				error(item, "value=\"{0}\" is not a number or 
negative");
			}
		}
	}

	/*
	 * &lt;list 
		  id = ID 
		  itemType = QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?))
		&lt;/list&gt;
	 */
	public Object visitList(List item) {
		Exp saveAllow = checkAllow(item, item.getItemType() == null ? 
REQUIRE_SIMPLETYPE : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			String itemType = item.getItemType();
			if (itemType != null) {
				checkSimpleType(item, "itemType", itemType);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkSimpleType(Common item, String attrName, String 
type) {
		QName qn = getQName(item, type);
		if (qn.namespace != "?" &amp;&amp; qn.localname != "?") {
			if (qn.namespace.equals(XSNS)) {
				if (!SimpleType.TYPE.contains(qn.localname)) {
					error(item, "unknown standard type 
\"{0}\"", type);
				}
			}
			else {
				fSimpleTypeRefs.add(item);
			}
		}
	}

	private void checkSimpleTypeDef(SimpleType item, String name) {
		QName qn = getQName(item, name);
		if (qn.namespace != "?" &amp;&amp; qn.localname != "?") {
			// allow definitions in XS namespace iff they are 
predefined
			// this allows to parse schema for schemas
			if (qn.namespace.equals(XSNS)) {
				if (!SimpleType.TYPE.contains(qn.localname)) {
					error(item, "unknown standard type 
\"{0}\"", name);
				}
			}
			else if (fSimpleTypes.containsKey(qn)){
				error(item, "duplicate definition of 
simpleType {0}", name);
			}
			else {
				fSimpleTypes.put(qn, item);
			}
		}
	}

	private QName getQName(Common item, String name) {
		int pos = name.indexOf(':');
		String prefix = "";
		String localname = name;
		if (pos &gt; 0) {
			prefix = name.substring(0, pos);
			localname = name.substring(pos+1);
		}
		if (localname.length() == 0) {
			error(item, "zero-length localname \"{0}\"", name);
			localname = "?";
		}
		String namespace = item.getNamespace(prefix);
		if (namespace == null) {
			error(item, "unknown namespace for \"{0}\"", name);
			namespace = "?";
		}
		return new QName(namespace, localname);
	}

	/*
	 * 
	 */
	public Object visitMaxExclusive(MaxExclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMaxInclusive(MaxInclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMaxLength(MaxLength item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinExclusive(MinExclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinInclusive(MinInclusive item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * 
	 */
	public Object visitMinLength(MinLength item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * &lt;notation 
		  id = ID 
		  name = NCName (required)
		  public = anyURI (required)
		  system = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/notation&gt;
	 */
	public Object visitNotation(Notation item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null)
				error(item, MISSING_ATTR, "name");
			else {
				if (fNotations.containsKey(name))
					error(item, "notation {0} is 
previously defined", name);
				else
					fNotations.put(name, item);
			}
			String pubid = item.getPublic();
			if (pubid == null)
				error(item, MISSING_ATTR, "public");
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * 
	 */
	public Object visitPattern(Pattern item) {
		visitValueItem(item);
		return null;
	}

	/*
	 * &lt;redefine 
		  id = ID 
		  schemaLocation = anyURI 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation | (simpleType | complexType | group | 
attributeGroup))*
		&lt;/redefine&gt;
	 */
	public Object visitRedefine(Redefine item) {
		checkId(item);
		String loc = item.getSchemaLocation();
		if (loc == null) {
			error(item, MISSING_ATTR, "schemaLocation");
		}
		else {
			include(loc, item.getTargetNamespace());
			Exp saveAllow = checkAllow(item, REDEFINE_CHILDREN);
			if (!item.getSkip()) {
			
				item.visitChildren(this);
				checkEnd(item, saveAllow);
			}
			else
				forceEnd(saveAllow);
			return null;
		}
		return null;
	}

	/*
	 * &lt;restriction (child of SimpleContent or SimpleType)
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType?, (minExclusive | 
minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | 
length | minLength | maxLength | enumeration | whiteSpace | pattern)*)?, 
((attribute | attributeGroup)*, anyAttribute?))
		&lt;/restriction&gt;
		&lt;restriction (child of ComplexContent)
		  base = QName 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (group | all | choice | sequence)?, 
((attribute | attributeGroup)*, anyAttribute?))
		&lt;/restriction&gt;	 */
	public Object visitRestriction(Restriction item) {
		Common parent = item.getParent();
		if (parent == null) {
			error(item, "&lt;restriction&gt; cannot be root element");
			return null;
		}
		boolean isComplex = parent.getKind() == Visitor.COMPLEXCONTENT;
		Exp saveAllow = checkAllow(item, isComplex ? 
COMPLEXEXTENSION_CHILDREN : SIMPLEEXTENSION_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String base = item.getBase();
			if (base == null) {
				error(item, "&lt;restriction&gt; must specify base 
type");
			}
			else if (isComplex){
				String prefix = getPrefix(base);
				String ns = item.getNamespace(prefix);
				if (ns == null) {
					error(item, "undeclared namespace 
prefix in base {0}", base);
				}
				else {
					fBaseRefs.add(item);
				}
			}
			else {
				checkSimpleType(item, "base", base);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;schema 
		  attributeFormDefault = (qualified | unqualified) : 
unqualified
		  blockDefault = (#all | List of (extension | restriction | 
substitution))  : ''
		  elementFormDefault = (qualified | unqualified) : unqualified
		  finalDefault = (#all | List of (extension | 
restriction))  : ''
		  id = ID 
		  targetNamespace = anyURI 
		  version = token 
		  xml:lang = language 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: ((include | import | redefine | annotation)*, 
(((simpleType | complexType | group | attributeGroup) | element | attribute | 
notation), annotation*)*)
		&lt;/schema&gt;
	 */
	public Object visitSchema(Schema item) {
		Exp saveAllow = checkAllow(item, SCHEMA_CHILDREN);
		if (!item.getSkip()) {
			String tn = item.getTargetNamespace();
			if (tn == null || (fRequiredNamespace != null &amp;&amp; !
tn.equals(fRequiredNamespace))) {
				if (fRequiredNamespace != null) {
					if (tn != null)
						error
(item, "targetNamespace=\"{0}\" must be \"{1}\"", tn, fRequiredNamespace);
					else {
						error(item, "targetNamespace 
must be specified as {0}", fRequiredNamespace);
						tn = "";
					}
					item.setTargetNamespace
(fRequiredNamespace);
				}
				else if (tn == null) {
					tn = "";
					item.setTargetNamespace("");
				}
			}
			String prefix = item.getPrefix(tn);
			if (prefix != null &amp;&amp; fRequiredNamespace != null &amp;&amp; !
tn.equals(fRequiredNamespace)) {
				// this will mask any previous definition
				item.addNamespace(prefix, fRequiredNamespace);
			}
			String attrForm = item.getAttributeFormDefault();
			if (attrForm == null || !checkFormValue
(item, "attributeFormDefault", attrForm))
				item.setAttributeFormDefault("unqualified");
			String elemForm = item.getElementFormDefault();
			if (elemForm == null || !checkFormValue
(item, "elementFormDefault", elemForm))
				item.setElementFormDefault("unqualified");
			String block = item.getBlockDefault();
			if (block == null || !checkBlockValue
(item, "blockDefault", block))
				item.setBlockDefault("");
			String fin = item.getFinalDefault();
			if (fin == null || !checkFinalValue
(item, "finalDefault", fin))
				item.setFinalDefault("");
			checkId(item);
			String version = item.getVersion();
			if (version != null &amp;&amp; !version.equals("1.0"))
				error(item, "version=\"{0}\" must be 1.0", 
version);
			String xmlLang = item.getXmlLang();
			if (xmlLang == null)
				item.setXmlLang("EN");
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkFinalValue(Schema item, String attrName, String 
fin) {
		if (!fin.equals("#all")) {
			String[] list = getList(fin);
			for (int i = 0; i &lt; list.length; i++) {
				String value = list[i];
				if (!value.equals("extension")
				&amp;&amp; !value.equals("restriction")) {
					error(item, INVALID_ATTR_VALUE, 
attrName, fin);
					return false;
				}
			}
		}
		return true;
	}

	private boolean checkBlockValue(Common item, String attrName, String 
block) {
		if (!block.equals("#all")) {
			String[] list = getList(block);
			for (int i = 0; i &lt; list.length; i++) {
				String value = list[i];
				if (!value.equals("extension")
				&amp;&amp; !value.equals("restriction")
				&amp;&amp; !value.equals("substitution")) {
					error(item, INVALID_ATTR_VALUE, 
attrName, block);
					return false;
				}
			}
		}
		return true;
	}

	private Exp checkAllow(Common item, Exp allowChild) {
		Exp deriv = fDeriv.deriv(fAllowChild, fFac.element
(item.getElementName()));
		if (fAllowChild != Exp.Null &amp;&amp; deriv == Exp.Null) {
			Common parent = item.getParent();
			if (parent != null)
				error(item, "{0} is not allowed as child of 
{1}",
					"&lt;"+item.getElementName()+"&gt;",
					"&lt;"+parent.getElementName()+"&gt;");
			else
				error(item, "{0} is not allowed as root 
element",
					"&lt;"+item.getElementName()+"&gt;");
		}
		fAllowChild = allowChild;
		return deriv;
	}
	
	private void checkEnd(Common item, Exp saveAllow) {
		if (fAllowChild != Exp.Null &amp;&amp; !fAllowChild.nullable()) {
			String [] required = fRequired.getRequired
(fAllowChild);
			String requiredList = getCommaList(required);
			error(item, "{0} missing children {1}",
				"&lt;"+item.getElementName()+"&gt;",
				requiredList);
		}
		fAllowChild = saveAllow;
	}

	private void forceEnd(Exp saveAllow) {
		fAllowChild = saveAllow;
	}

	private String getCommaList(String[] array) {
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i &lt; array.length; i++) {
			if (i &gt; 0)
				buf.append(", ");
			buf.append(array[i]);
		}
		return buf.toString();
	}

	private void error(Common item, String msg, Object arg1, Object arg2) {
		fParser.error(item.getOffset(), msg, arg1, arg2);
		item.setSkip(true);
	}

	private void error(Common item, String msg, Object arg) {
		fParser.error(item.getOffset(), msg, arg);
		item.setSkip(true);
	}

	private void error(Common item, String msg) {
		fParser.error(item.getOffset(), msg);
		item.setSkip(true);
	}

	/*
	 * &lt;selector 
		  id = ID 
		  xpath = a subset of XPath expression, see below 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?)
		&lt;/selector&gt;
	 */
	public Object visitSelector(Selector item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkXpath(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;sequence 
		  id = ID 
		  maxOccurs = (nonNegativeInteger | unbounded)  : 1
		  minOccurs = nonNegativeInteger : 1
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (element | group | choice | sequence 
| any)*)
		&lt;/sequence&gt;
	 */
	public Object visitSequence(Sequence item) {
		Exp saveAllow = checkAllow(item, ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			checkMinMax(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;simpleContent 
		  id = ID 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | extension))
		&lt;/simpleContent&gt;
	 */
	public Object visitSimpleContent(SimpleContent item) {
		Exp saveAllow = checkAllow(item, SIMPLECONTENT_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;simpleType 
		  final = (#all | (list | union | restriction)) 
		  id = ID 
		  name = NCName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (restriction | list | union))
		&lt;/simpleType&gt;
	 */
	public Object visitSimpleType(SimpleType item) {
		Exp saveAllow = checkAllow(item, SIMPLETYPE_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String fin = item.getFinal();
			if (fin != null)
				checkFinal(item, fin);
			String name = item.getName();
			boolean top = isTopLevel(item);
			if (name == null &amp;&amp; top)
				error(item, MISSING_ATTR, "name");
			else if (name != null &amp;&amp; !top)
				error(item, "name allowed only in top-level 
definition");
			else if (name != null) {
				checkSimpleTypeDef(item, name);
			}
			
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private void checkFinal(Common item, String fin) {
		if (!fin.equals("#all") &amp;&amp; !fin.equals("list") &amp;&amp; !fin.equals
("union") &amp;&amp; !fin.equals("restriction"))
			error(item, INVALID_ATTR_VALUE, "final", fin);
	}

	/*
	 * 
	 */
	public Object visitTotalDigits(TotalDigits item) {
		visitFixedValueItem(item);
		return null;
	}

	/*
	 * &lt;union 
		  id = ID 
		  memberTypes = List of QName 
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (simpleType*))
		&lt;/union&gt;
	 */
	public Object visitUnion(Union item) {
		Exp saveAllow = checkAllow(item, item.getMemberTypes() == 
null ? UNION_CHILDREN : ALLOW_ANNOTATION);
		if (!item.getSkip()) {
			checkId(item);
			String mem = item.getMemberTypes();
			if (mem != null) {
				// since list can contain both standard and 
user-defined types
				// defer all checking to ref checking phase
				fUnionRefs.add(item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	/*
	 * &lt;unique 
		  id = ID 
		  name = NCName (required)
		  {any attributes with non-schema namespace . . .}&gt;
		  Content: (annotation?, (selector, field+))
		&lt;/unique&gt;
	 */
	public Object visitUnique(Unique item) {
		Exp saveAllow = checkAllow(item, KEY_CHILDREN);
		if (!item.getSkip()) {
			checkId(item);
			String name = item.getName();
			if (name == null)
				error(item, MISSING_ATTR, "name");
			else if (checkNCName(item, "name", name)){
				String ns = item.getTargetNamespace();
				QName qn = new QName(ns, name);
				if (fIdentities.containsKey(qn) || 
fKeys.containsKey(qn))
					error(item, "identity constraint name 
{0} is already defined", name);
				else
					fIdentities.put(qn, item);
			}
			
			item.visitChildren(this);
			checkEnd(item, saveAllow);
		}
		else
			forceEnd(saveAllow);
		return null;
	}

	private boolean checkNCName(Common item, String attrName, String name) 
{
		if (name.indexOf(':') &gt;= 0) {
			error(item, "{0}=\"{1}\" must not contain a colon", 
attrName, name);
			return false;
		}
		return true;
	}

	/*
	 * 
	 */
	public Object visitWhiteSpace(WhiteSpace item) {
		visitFixedValueItem(item);
		return null;
	}

}

Can't reproduce using the striped down attached to this PR. Without a 
reproducable case there is little we can do.
Created attachment 4311
The file used to reproduce the problem
So you were able to reproduce the problem? Excellent!
Oh, I see, this is the file you used to _try_ to reproduce the problem. Oh,
well. Thanks for trying. No response required.
I spoke too soon. I can make it fail every time with a test case that is the
same as your cut-down example except:

1. It begins with:

public class Junk extends CheckSchemaVisitor {

where CheckSchemaVisitor is the same as the file I supplied except that the
inner classes have all been exported (by hand).

2. It has a pass-through constructor to satisfy CheckSchemaVisitor.

So obviously there is something about the original CheckSchemaVisitor that
causes this to fail. Unfortunately, I'm not willing to furnish the dozens of
files it would take for you to repro this exactly. I'm still searching for a
cut-down example that is sufficient to show the problem.
I'm afraid I'm going to have to give up on this one. I can make it fail with a
very large test case. I can make it succeed by successively removing methods in
the test case. But I can't make the test case small enough to send you and I'm
out of time to spend on this.
Without a reproducable case this is hard to track down.
Bob, i'm going to close this report.
Please reopen if you have a reproducible test case.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35442" />
    <CreationDate amount="2003-03-21 02:04:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>flag unnecessary casts</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="7">
      <source_code type="assignment">
        <location start="616" end="631" />
        <code>String s = ...;</code>
      </source_code>
      <source_code type="assignment">
        <location start="632" end="647" />
        <code>Thread t = ...;</code>
      </source_code>
      <source_code type="assignment">
        <location start="648" end="680" />
        <code>Object o = bool ? s : (Object)t;</code>
      </source_code>
      <source_code type="class">
        <location start="802" end="1066" />
        <code>class X {

   void foo(String s) { ... }
   void foo(Thread t) { ... }

   void bar(Object o) {
      if (o instance String) {
        foo((String)o); // necessary cast
      } else if (o instanceof Thread){
        foo((Thread)o); // necessary cast
      }
   }
}</code>
      </source_code>
      <source_code type="class">
        <location start="1178" end="1326" />
        <code>class X {

   void foo(String s) { ... }
   void foo(Object o) { ... }

   void bar() {
      foo((Object)"hello");
      foo((String) null);
   }
}</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="1765" end="1838" />
        <code>// program would have thrown ClassCastException at runtime with cast in.</code>
      </source_code>
      <source_code type="functiondef">
        <location start="1839" end="1860" />
        <code>void foo(Object o) {}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>It would be nice to have a compiler option to flag unnecessary explicit type 
casts.
Good suggestion. Post 2.1
Yes indeed, that would be super. 

The best reason for the feature is the case we have right now where we have 
discovered some nice interface refactoring that will clean things up greatly 
for us. But the most tedious part of the clean up is to go through our giant 
pile of code and remove the no longer needed type casts. 

Thank you for considering this request as soon as the 2.1 tree re-opens!
Note though that unnecessary casts are optimized out by the compiler.
reopen
One thing to keep in mind:

String s = ...;
Thread t = ...;
Object o = bool ? s : (Object)t;

The cast isn't unnecessary (optimized out, but necessary for conditional 
operator type resolution).
Other nasty case:

class X {

   void foo(String s) { ... }
   void foo(Thread t) { ... }

   void bar(Object o) {
      if (o instance String) {
        foo((String)o); // necessary cast
      } else if (o instanceof Thread){
        foo((Thread)o); // necessary cast
      }
   }
}
Actually my previous case was fine, but the following is problematic:

However the following is a nasty case:

class X {

   void foo(String s) { ... }
   void foo(Object o) { ... }

   void bar() {
      foo((Object)"hello");
      foo((String) null);
   }
}
Previous case also affects allocation expression, anonymous type declarations 
and explicit constructor calls.

Also numeric promotion in operators is troublesome.

Finally, instanceof operator should also diagnose unnecessary case (quite 
trivial).
I am not flagging unnecessary narrowing cast, since removing these may change 
the end program behavior, however it is still useful information for end-user.

foo((String) new Object()); 
// program would have thrown ClassCastException at runtime with cast in.

void foo(Object o) {}

Will not check for this (for now)
Considered narrowing scenario as well.


Added optional diagnosis for unnecessary cast or instanceof operations 
(matching problem IDs are IProblem.UnnecessaryCast, 
IProblem.UnnecessaryArgumentCast, IProblem.UnnecessaryInstanceof). 
* COMPILER / Reporting Unnecessary Type Check
*    When enabled, the compiler will issue an error or a warning when a cast or 
an instanceof operation 
*    is unnecessary.
*     - option 
id:         "org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck"
*     - possible values:   { "error", "warning", "ignore" }
*     - default:           "ignore"


Note: will not complain about unnecessary narrowing casts on receiver (message 
or field access) since these may induce change in constant pool for target &gt;= 
1.2 (pool references contain the actual receiver type, instead of the declaring 
class).

Verified.</WithStack>
    <WithOutStack>It would be nice to have a compiler option to flag unnecessary explicit type 
casts.
Good suggestion. Post 2.1
Yes indeed, that would be super. 

The best reason for the feature is the case we have right now where we have 
discovered some nice interface refactoring that will clean things up greatly 
for us. But the most tedious part of the clean up is to go through our giant 
pile of code and remove the no longer needed type casts. 

Thank you for considering this request as soon as the 2.1 tree re-opens!
Note though that unnecessary casts are optimized out by the compiler.
reopen
One thing to keep in mind:

String s = ...;
Thread t = ...;
Object o = bool ? s : (Object)t;

The cast isn't unnecessary (optimized out, but necessary for conditional 
operator type resolution).
Other nasty case:

class X {

   void foo(String s) { ... }
   void foo(Thread t) { ... }

   void bar(Object o) {
      if (o instance String) {
        foo((String)o); // necessary cast
      } else if (o instanceof Thread){
        foo((Thread)o); // necessary cast
      }
   }
}
Actually my previous case was fine, but the following is problematic:

However the following is a nasty case:

class X {

   void foo(String s) { ... }
   void foo(Object o) { ... }

   void bar() {
      foo((Object)"hello");
      foo((String) null);
   }
}
Previous case also affects allocation expression, anonymous type declarations 
and explicit constructor calls.

Also numeric promotion in operators is troublesome.

Finally, instanceof operator should also diagnose unnecessary case (quite 
trivial).
I am not flagging unnecessary narrowing cast, since removing these may change 
the end program behavior, however it is still useful information for end-user.

foo((String) new Object()); 
// program would have thrown ClassCastException at runtime with cast in.

void foo(Object o) {}

Will not check for this (for now)
Considered narrowing scenario as well.


Added optional diagnosis for unnecessary cast or instanceof operations 
(matching problem IDs are IProblem.UnnecessaryCast, 
IProblem.UnnecessaryArgumentCast, IProblem.UnnecessaryInstanceof). 
* COMPILER / Reporting Unnecessary Type Check
*    When enabled, the compiler will issue an error or a warning when a cast or 
an instanceof operation 
*    is unnecessary.
*     - option 
id:         "org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck"
*     - possible values:   { "error", "warning", "ignore" }
*     - default:           "ignore"


Note: will not complain about unnecessary narrowing casts on receiver (message 
or field access) since these may induce change in constant pool for target &gt;= 
1.2 (pool references contain the actual receiver type, instead of the declaring 
class).

Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35443" />
    <CreationDate amount="2003-03-21 02:21:00 -0500" />
    <DupId amount="31525" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P2" />
    <bug_severity amount="critical" />
    <Summery>CPU Peg and SWTException with Code Generation preference page</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437340488137">
        <Exception>org.eclipse.swt.SWTException</Exception>
        <Reason>Widget is disposed</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.SWT.error(SWT.java:2320)</Frame>
          <Frame depth="1">org.eclipse.swt.widgets.Control.getDisplay(Control.java(Compiled Code))</Frame>
          <Frame depth="2">org.eclipse.swt.widgets.Control.getDisplay(Control.java(Compiled Code))</Frame>
          <Frame depth="3">org.eclipse.swt.widgets.Control.getDisplay(Control.java(Compiled Code))</Frame>
          <Frame depth="4">org.eclipse.swt.widgets.Widget.checkWidget(Widget.java(Compiled Code))</Frame>
          <Frame depth="5">org.eclipse.swt.widgets.Widget.checkWidget(Widget.java(Compiled Code))</Frame>
          <Frame depth="6">org.eclipse.swt.widgets.Tree.setSelection(Tree.java:894)</Frame>
          <Frame depth="7">org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:226)</Frame>
          <Frame depth="8">org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:1261)</Frame>
          <Frame depth="9">org.eclipse.jface.viewers.StructuredViewer.setSelectionToWidget(StructuredViewer.java:1053)</Frame>
          <Frame depth="10">org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:808)</Frame>
          <Frame depth="11">org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:859)</Frame>
          <Frame depth="12">org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.refresh(TreeListDialogField.java:710)</Frame>
          <Frame depth="13">org.eclipse.jdt.internal.ui.preferences.CodeTemplateBlock.edit(CodeTemplateBlock.java:349)</Frame>
          <Frame depth="14">org.eclipse.jdt.internal.ui.preferences.CodeTemplateBlock.doButtonPressed(CodeTemplateBlock.java:332)</Frame>
          <Frame depth="15">org.eclipse.jdt.internal.ui.preferences.CodeTemplateBlock$CodeTemplateAdapter.customButtonPressed(CodeTemplateBlock.java:70)</Frame>
          <Frame depth="16">org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.buttonPressed(TreeListDialogField.java:171)</Frame>
          <Frame depth="17">org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.doButtonSelected(TreeListDialogField.java:386)</Frame>
          <Frame depth="18">org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.access$2(TreeListDialogField.java:382)</Frame>
          <Frame depth="19">org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField$2.widgetSelected(TreeListDialogField.java:349)</Frame>
          <Frame depth="20">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="21">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java(CompiledCode))</Frame>
          <Frame depth="22">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))</Frame>
          <Frame depth="23">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))</Frame>
          <Frame depth="24">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java(CompiledCode))</Frame>
          <Frame depth="25">org.eclipse.jface.window.Window.runEventLoop(Window.java(Compiled Code))</Frame>
          <Frame depth="26">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="27">org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:53)</Frame>
          <Frame depth="28">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="29">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="30">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="31">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="32">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="33">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java(CompiledCode))</Frame>
          <Frame depth="34">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:913)</Frame>
          <Frame depth="35">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1641)</Frame>
          <Frame depth="36">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1433)</Frame>
          <Frame depth="37">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="38">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="39">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="40">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="41">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="42">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:61)</Frame>
          <Frame depth="43">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:40)</Frame>
          <Frame depth="44">java.lang.reflect.Method.invoke(Method.java:335)</Frame>
          <Frame depth="45">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="46">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="47">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="3">
      <Enumeration lines="15">
        <Lines>
          <Line>1) get eclipse RC3 (linux gtk on a debian/sid laptop is what I got), unzip and run</Line>
          <Line>2) Navigate to Window/Preferences/Java/Code Generation/Code and Comments</Line>
          <Line>3) Select Types</Line>
          <Line>4) wait for a moment and notice that your favorite load meter shows that the CPU</Line>
          <Line>is pegged</Line>
          <Line>5) click edit</Line>
          <Line>6) modify the text</Line>
          <Line>7) click ok</Line>
          <Line>8) notice that the pattern display is not updated and CPU is still pegged</Line>
          <Line>9) Click apply ok and cancel</Line>
          <Line>10) notice that the prferences window doesn't go away</Line>
          <Line>11) click the 'X' in the window decorations for the preferences page</Line>
          <Line>12) notice that the preferences window goes away and CPU goes back down</Line>
          <Line>13) exit eclipse</Line>
          <Line>14) look at .metadata/.log, notice the stack trace</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="16">
        <Lines>
          <Line>- it only happens under Linux-GTK. Motif, Windows and Mac don't reveal the</Line>
          <Line>behaviour of CPU pegging and exception.</Line>
          <Line>- starting GTK in debug mode and following the steps including 4 and then</Line>
          <Line>suspending the main thread brings the CPU back to normal. Unfortunatelly the</Line>
          <Line>stack trace doesn't reveal what is done in main.</Line>
          <Line>- resuming main brings the CPU back to 100%</Line>
          <Line />
          <Line>The first thing we have to track down IMO is the CPU pegging since it makes the</Line>
          <Line>dialog unusable. The exception at the end doesn't really cause harm.</Line>
          <Line />
          <Line>Veronika any idea what can cause the CPU pegging. It is easy to reproduce and I</Line>
          <Line>assume you have better tools and are more familiar with GTk to figure this out.</Line>
          <Line />
          <Line>I don't want to move the PR back and forth but without help from SWT it is hard to</Line>
          <Line>find out what is going on, especially since it only happens under Linux-GTK</Line>
          <Line>Weird, resize the dialog during the process and the bug doesn't happen.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="19">
        <Lines>
          <Line>- following steps until step 4</Line>
          <Line>- move the scroll bar of the tree widget down</Line>
          <Line />
          <Line>observe: the CPU does back to 0% and the dialog works as expected.</Line>
          <Line>Dirk, please execute this in a shell, "rpm -q glib2".</Line>
          <Line>My configuration is:</Line>
          <Line />
          <Line>atk: 1.2.0</Line>
          <Line>glib: 2.2.1</Line>
          <Line>gtk+: 2.2.1</Line>
          <Line>pango: 1.2.1</Line>
          <Line>pkgconfig: 0.15.0</Line>
          <Line>Note that after resizing the dialog or moving the scrollbar you have to wait 2 - 3</Line>
          <Line>seconds until the CPU goes back to 0%.</Line>
          <Line>Use build to reproduce: 200303241446</Line>
          <Line>We are able to confirm that this problem occurs in GTK 2.2.x only.  Since this</Line>
          <Line>is not an offically supported GTK release at this time, I'm downgrading this PR.</Line>
          <Line>Felipe is still looking at the problem.</Line>
          <Line>See also bug 31525.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Steps to reproduce:

1) get eclipse RC3 (linux gtk on a debian/sid laptop is what I got), unzip and run
2) Navigate to Window/Preferences/Java/Code Generation/Code and Comments
3) Select Types
4) wait for a moment and notice that your favorite load meter shows that the CPU
is pegged
5) click edit
6) modify the text
7) click ok
8) notice that the pattern display is not updated and CPU is still pegged
9) Click apply ok and cancel
10) notice that the prferences window doesn't go away
11) click the 'X' in the window decorations for the preferences page
12) notice that the preferences window goes away and CPU goes back down
13) exit eclipse
14) look at .metadata/.log, notice the stack trace

!SESSION Mar 21, 2003 02:15:33.672 ---------------------------------------------
java.fullversion=J2RE 1.4.0 IBM build cxia32140-20020917a (JIT enabled: jitc)
BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=en
Command-line arguments: -os linux -ws gtk -arch x86 -install
file:/home/burner/jdks/eclipse/eclipse/
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 02:15:33.673
!MESSAGE Unhandled exception caught in event loop.
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 02:15:33.713
!MESSAGE Widget is disposed
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
        at org.eclipse.swt.SWT.error(SWT.java:2320)
        at org.eclipse.swt.widgets.Control.getDisplay(Control.java(Compiled Code))
        at org.eclipse.swt.widgets.Control.getDisplay(Control.java(Compiled Code))
        at org.eclipse.swt.widgets.Control.getDisplay(Control.java(Compiled Code))
        at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java(Compiled Code))
        at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java(Compiled Code))
        at org.eclipse.swt.widgets.Tree.setSelection(Tree.java:894)
        at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:226)
        at
org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:1261)
        at
org.eclipse.jface.viewers.StructuredViewer.setSelectionToWidget(StructuredViewer.java:1053)
        at
org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:808)
        at
org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:859)
        at
org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.refresh(TreeListDialogField.java:710)
        at
org.eclipse.jdt.internal.ui.preferences.CodeTemplateBlock.edit(CodeTemplateBlock.java:349)
        at
org.eclipse.jdt.internal.ui.preferences.CodeTemplateBlock.doButtonPressed(CodeTemplateBlock.java:332)
        at
org.eclipse.jdt.internal.ui.preferences.CodeTemplateBlock$CodeTemplateAdapter.customButtonPressed(CodeTemplateBlock.java:70)
        at
org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.buttonPressed(TreeListDialogField.java:171)
        at
org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.doButtonSelected(TreeListDialogField.java:386)
        at
org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField.access$2(TreeListDialogField.java:382)
        at
org.eclipse.jdt.internal.ui.wizards.dialogfields.TreeListDialogField$2.widgetSelected(TreeListDialogField.java:349)
        at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java(Compiled
Code))
        at
org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))
        at
org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java(Compiled
Code))
        at org.eclipse.jface.window.Window.runEventLoop(Window.java(Compiled Code))
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at
org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:53)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)
        at
org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)
        at
org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)
        at
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java(Compiled
Code))
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:913)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1641)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1433)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at
org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:61)
        at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:40)
        at java.lang.reflect.Method.invoke(Method.java:335)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
FYI: The exception is generated when the 'X' is clicked on the window
decorations for the preferences window.
This was an RC3 bug fixed in RC3a, apparently
Martin, also the reporter said that the problem is gone in RC3a can you please 
comnment on the stack trace. May be there is a underlying problem here.
I've not seen such a stacktrace before. It's strange that the tree would be 
disposed after the edit call. My guess this is a SWT problem
Asking SWT if anything changed here between RC3 and RC3a
The only changes made by SWT between RC3 and RC3a where for motif.  I think 
the stack trace does not show the full problem.  When the CPU was pegged there 
were probably exceptions thrown and caught that altered the code flow and 
resulted in referenceing a disposed tree.

Moving back to JDT UI.
Yeah, if I recall correctly the stack trace occured at step 11/12, so Veronika's
probably right.
Veronika, I trried to track this done but I am not able to do so. Here are my findings: 
 
- it only happens under Linux-GTK. Motif, Windows and Mac don't reveal the  
  behaviour of CPU pegging and exception. 
- starting GTK in debug mode and following the steps including 4 and then  
  suspending the main thread brings the CPU back to normal. Unfortunatelly the 
  stack trace doesn't reveal what is done in main. 
- resuming main brings the CPU back to 100% 
 
The first thing we have to track down IMO is the CPU pegging since it makes the 
dialog unusable. The exception at the end doesn't really cause harm. 
 
Veronika any idea what can cause the CPU pegging. It is easy to reproduce and I 
assume you have better tools and are more familiar with GTk to figure this out. 
 
I don't want to move the PR back and forth but without help from SWT it is hard to 
find out what is going on, especially since it only happens under Linux-GTK 
Weird, resize the dialog during the process and the bug doesn't happen.


Another finding: 
 
- following steps until step 4 
- move the scroll bar of the tree widget down 
 
observe: the CPU does back to 0% and the dialog works as expected. 
Dirk, please execute this in a shell, "rpm -q glib2".
My configuration is: 
 
atk: 1.2.0 
glib: 2.2.1 
gtk+: 2.2.1 
pango: 1.2.1 
pkgconfig: 0.15.0 
Note that after resizing the dialog or moving the scrollbar you have to wait 2 - 3 
seconds until the CPU goes back to 0%.  
Use build to reproduce: 200303241446
We are able to confirm that this problem occurs in GTK 2.2.x only.  Since this
is not an offically supported GTK release at this time, I'm downgrading this PR.
 Felipe is still looking at the problem.
See also bug 31525.


*** This bug has been marked as a duplicate of 31525 ***</WithStack>
    <WithOutStack>Steps to reproduce:

1) get eclipse RC3 (linux gtk on a debian/sid laptop is what I got), unzip and run
2) Navigate to Window/Preferences/Java/Code Generation/Code and Comments
3) Select Types
4) wait for a moment and notice that your favorite load meter shows that the CPU
is pegged
5) click edit
6) modify the text
7) click ok
8) notice that the pattern display is not updated and CPU is still pegged
9) Click apply ok and cancel
10) notice that the prferences window doesn't go away
11) click the 'X' in the window decorations for the preferences page
12) notice that the preferences window goes away and CPU goes back down
13) exit eclipse
14) look at .metadata/.log, notice the stack trace

!SESSION Mar 21, 2003 02:15:33.672 ---------------------------------------------
java.fullversion=J2RE 1.4.0 IBM build cxia32140-20020917a (JIT enabled: jitc)
BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=en
Command-line arguments: -os linux -ws gtk -arch x86 -install
file:/home/burner/jdks/eclipse/eclipse/
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 02:15:33.673
!MESSAGE Unhandled exception caught in event loop.
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 02:15:33.713
!MESSAGE Widget is disposed
!STACK 0

FYI: The exception is generated when the 'X' is clicked on the window
decorations for the preferences window.
This was an RC3 bug fixed in RC3a, apparently
Martin, also the reporter said that the problem is gone in RC3a can you please 
comnment on the stack trace. May be there is a underlying problem here.
I've not seen such a stacktrace before. It's strange that the tree would be 
disposed after the edit call. My guess this is a SWT problem
Asking SWT if anything changed here between RC3 and RC3a
The only changes made by SWT between RC3 and RC3a where for motif.  I think 
the stack trace does not show the full problem.  When the CPU was pegged there 
were probably exceptions thrown and caught that altered the code flow and 
resulted in referenceing a disposed tree.

Moving back to JDT UI.
Yeah, if I recall correctly the stack trace occured at step 11/12, so Veronika's
probably right.
Veronika, I trried to track this done but I am not able to do so. Here are my findings: 
 
- it only happens under Linux-GTK. Motif, Windows and Mac don't reveal the  
  behaviour of CPU pegging and exception. 
- starting GTK in debug mode and following the steps including 4 and then  
  suspending the main thread brings the CPU back to normal. Unfortunatelly the 
  stack trace doesn't reveal what is done in main. 
- resuming main brings the CPU back to 100% 
 
The first thing we have to track down IMO is the CPU pegging since it makes the 
dialog unusable. The exception at the end doesn't really cause harm. 
 
Veronika any idea what can cause the CPU pegging. It is easy to reproduce and I 
assume you have better tools and are more familiar with GTk to figure this out. 
 
I don't want to move the PR back and forth but without help from SWT it is hard to 
find out what is going on, especially since it only happens under Linux-GTK 
Weird, resize the dialog during the process and the bug doesn't happen.


Another finding: 
 
- following steps until step 4 
- move the scroll bar of the tree widget down 
 
observe: the CPU does back to 0% and the dialog works as expected. 
Dirk, please execute this in a shell, "rpm -q glib2".
My configuration is: 
 
atk: 1.2.0 
glib: 2.2.1 
gtk+: 2.2.1 
pango: 1.2.1 
pkgconfig: 0.15.0 
Note that after resizing the dialog or moving the scrollbar you have to wait 2 - 3 
seconds until the CPU goes back to 0%.  
Use build to reproduce: 200303241446
We are able to confirm that this problem occurs in GTK 2.2.x only.  Since this
is not an offically supported GTK release at this time, I'm downgrading this PR.
 Felipe is still looking at the problem.
See also bug 31525.


*** This bug has been marked as a duplicate of 31525 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35444" />
    <CreationDate amount="2003-03-21 03:56:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Too many lines selected when pressing Ctrl+F</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="class">
        <location start="328" end="373" />
        <code>public class Foo
{
	public void xxx()
	{
	}
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="2">
      <Enumeration lines="3">
        <Lines>
          <Line>- Select first line</Line>
          <Line>- press ctrl-f</Line>
          <Line>- Two lines are highlighted in grey</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="3">
        <Lines>
          <Line>- Select a single word</Line>
          <Line>- press ctrl-f</Line>
          <Line>- That single word is highlighted in blue</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="ASSIGNED" />
    <resolution amount="" />
    <WithStack>- Select first line
- press ctrl-f
- Two lines are highlighted in grey

Now try:

- Select a single word
- press ctrl-f
- That single word is highlighted in blue

Is this intentional?


The reason I reported this is that I'm trying to narrow down "bleeding yellow 
highlighting", and perhaps this might be a clue to something.

public class Foo
{
	public void xxx()
	{
	}
}
yes, this is what is called 'scope' (in the Find dialog)
This is not a line highlighting problem: when you press Ctrl+F while there's a
selection it selects the range in which text will be searched and in the Find
dialog it selects "Search in selected lines"

If you select a line, the cursor is probably at the beginning of the second line
and therefore 2 lines get selected.

We can change the code to select only one line if the cursor is at the beginning
of a line.

changing summary.</WithStack>
    <WithOutStack>- Select first line
- press ctrl-f
- Two lines are highlighted in grey

Now try:

- Select a single word
- press ctrl-f
- That single word is highlighted in blue

Is this intentional?


The reason I reported this is that I'm trying to narrow down "bleeding yellow 
highlighting", and perhaps this might be a clue to something.

public class Foo
{
	public void xxx()
	{
	}
}
yes, this is what is called 'scope' (in the Find dialog)
This is not a line highlighting problem: when you press Ctrl+F while there's a
selection it selects the range in which text will be searched and in the Find
dialog it selects "Search in selected lines"

If you select a line, the cursor is probably at the beginning of the second line
and therefore 2 lines get selected.

We can change the code to select only one line if the cursor is at the beginning
of a line.

changing summary.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35445" />
    <CreationDate amount="2003-03-21 04:47:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>The console view pops to front when I'm working in the synchronize view</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>I've got a test that I run from within Eclipse. It takes quite a while.

Meantime I'd like to continue working with e.g. synchronizing/comparing my 
local code to the CVS repository. 

The problem is that the console view pops to front every time something is 
printed to stdout/stderr.

yvind
Behaviour can be controlled by Preferences &gt; Debugs &gt; Console.</WithStack>
    <WithOutStack>I've got a test that I run from within Eclipse. It takes quite a while.

Meantime I'd like to continue working with e.g. synchronizing/comparing my 
local code to the CVS repository. 

The problem is that the console view pops to front every time something is 
printed to stdout/stderr.

yvind
Behaviour can be controlled by Preferences &gt; Debugs &gt; Console.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35446" />
    <CreationDate amount="2003-03-21 05:09:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>[CVS Sync View] Synchronize view should allow to create patch</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build RC3a

It isn't possible to create a patch in the synchronize view, though it is 
likely the most relevant location for this action, since I can confront the 
change with the server code.
Note that this can currently be done by performing a Show in Navigaotr 
followed by a Team&gt;Create Patch from the navigator. However, direct access to 
the operation in the sync view should be considered.
Fixed in the live sync view. The standard Team menu is shown from the view.</WithStack>
    <WithOutStack>Build RC3a

It isn't possible to create a patch in the synchronize view, though it is 
likely the most relevant location for this action, since I can confront the 
change with the server code.
Note that this can currently be done by performing a Show in Navigaotr 
followed by a Team&gt;Create Patch from the navigator. However, direct access to 
the operation in the sync view should be considered.
Fixed in the live sync view. The standard Team menu is shown from the view.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35447" />
    <CreationDate amount="2003-03-21 05:13:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P4" />
    <bug_severity amount="enhancement" />
    <Summery>Add data to File Property Pop Up [metrics]</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="2">
      <Enumeration lines="2">
        <Lines>
          <Line>- lines and maybe words in file</Line>
          <Line>- empty lines vs. non empty lines</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="5">
        <Lines>
          <Line>- number of classes defined</Line>
          <Line>- number of methods (maybe separated by visibility and static / instance) per</Line>
          <Line>class or overall</Line>
          <Line>- number of members (maybe separation as above) per class or overall</Line>
          <Line>- number of non comment lines</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>I'd like to have added some information to the resource property pop up that is 
reachable from the navigator and package explorer.  IMHO these things could be 
useful:

Category "Info":
 - lines and maybe words in file
 - empty lines vs. non empty lines

Category "Java" (not present at the moment)
 - number of classes defined
 - number of methods (maybe separated by visibility and static / instance) per 
class or overall
 - number of members (maybe separation as above) per class or overall
 - number of non comment lines

I guess the data is there already (since eclipse can show those entities in 
package explorer) and need only be presented.

Reason: these simple metrics can give a quick indication whether a class is too 
big and should be split up or otherwise dealt with.  I am not fixed on the 
exact set of data presented, but I think something along these lines could be 
helpful.
Since your primary interest is in Java metrics, I'm moving this to JDT.
If you'd also like to see metrics on non-Java files, please enter a separate 
PR against Platform-UI.

No action planned for 2.1. This is also a good third party opportunity.
Since there are already third party activities for Java metrics I drop the Java 
part and suggest just to include words, lines and (non) empty lines into 
category "Info".  Thus moved back to "Platform-UI". :-)
Note that, currently, the properties shown on the Info property page do not 
require reading the file.  The stats you suggest here would require reading the 
file, and therefore might have an adverse performance impact, particularly on 
slow network drives.

There are no plans for the UI team to work on this defect until higher priority 
items are addressed.  
If you would like to work on this defect, please let us know on the platform-ui-
dev mailing list.

There are currently no plans to address this.</WithStack>
    <WithOutStack>I'd like to have added some information to the resource property pop up that is 
reachable from the navigator and package explorer.  IMHO these things could be 
useful:

Category "Info":
 - lines and maybe words in file
 - empty lines vs. non empty lines

Category "Java" (not present at the moment)
 - number of classes defined
 - number of methods (maybe separated by visibility and static / instance) per 
class or overall
 - number of members (maybe separation as above) per class or overall
 - number of non comment lines

I guess the data is there already (since eclipse can show those entities in 
package explorer) and need only be presented.

Reason: these simple metrics can give a quick indication whether a class is too 
big and should be split up or otherwise dealt with.  I am not fixed on the 
exact set of data presented, but I think something along these lines could be 
helpful.
Since your primary interest is in Java metrics, I'm moving this to JDT.
If you'd also like to see metrics on non-Java files, please enter a separate 
PR against Platform-UI.

No action planned for 2.1. This is also a good third party opportunity.
Since there are already third party activities for Java metrics I drop the Java 
part and suggest just to include words, lines and (non) empty lines into 
category "Info".  Thus moved back to "Platform-UI". :-)
Note that, currently, the properties shown on the Info property page do not 
require reading the file.  The stats you suggest here would require reading the 
file, and therefore might have an adverse performance impact, particularly on 
slow network drives.

There are no plans for the UI team to work on this defect until higher priority 
items are addressed.  
If you would like to work on this defect, please let us know on the platform-ui-
dev mailing list.

There are currently no plans to address this.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35448" />
    <CreationDate amount="2003-03-21 05:13:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Outline does not reflect access modifier changes in editor</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="2">
      <source_code type="functiondef">
        <location start="162" end="182" />
        <code>public void foo() {}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="251" end="264" />
        <code>void foo() {}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>The Outline view does not reflect the change (by changing the icon) if you
modify the access modifier of a method in the editor view.

e.g. a class has a method

public void foo() {}

you change the method signature by typing in the java editor into

void foo() {}

The outline view still shows the green dot (even after saving the class). Only
reopening the class helps. The same happens if you declare a method final/non-final.

Everything works well if you declare a method static/non-static, change the name
or arguments.

Build id is 200303192032. I am sure this bug was not existing in a earlier build.
Reproducable using build 200303202147

It only happens when the Outliner is sorted. The package explorer updates as 
expected.
When sorting is enabled, we call TreeViewer.refresh(false).
Moving to Platform UI.
Since you are specifying updateLabels=false, refresh does not update the label 
for existing elements.

Created attachment 4318
changes refresh(false) to refresh(true) at certain locations
+1
+1
+1
Reviewed and released.</WithStack>
    <WithOutStack>The Outline view does not reflect the change (by changing the icon) if you
modify the access modifier of a method in the editor view.

e.g. a class has a method

public void foo() {}

you change the method signature by typing in the java editor into

void foo() {}

The outline view still shows the green dot (even after saving the class). Only
reopening the class helps. The same happens if you declare a method final/non-final.

Everything works well if you declare a method static/non-static, change the name
or arguments.

Build id is 200303192032. I am sure this bug was not existing in a earlier build.
Reproducable using build 200303202147

It only happens when the Outliner is sorted. The package explorer updates as 
expected.
When sorting is enabled, we call TreeViewer.refresh(false).
Moving to Platform UI.
Since you are specifying updateLabels=false, refresh does not update the label 
for existing elements.

Created attachment 4318
changes refresh(false) to refresh(true) at certain locations
+1
+1
+1
Reviewed and released.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35449" />
    <CreationDate amount="2003-03-21 05:26:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>copyAndPaste of line comment+code produces wrong indentation</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="11">
      <source_code type="singlecomment">
        <location start="50" end="73" />
        <code>//-------------------</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="73" end="81" />
        <code>// TODO</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="81" end="103" />
        <code>//-------------------</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="136" end="156" />
        <code>//blah blah</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="281" end="307" />
        <code>//  -------------------</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="307" end="317" />
        <code>//   TODO</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="317" end="341" />
        <code>//  -------------------</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="378" end="400" />
        <code>//blah blah</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="740" end="762" />
        <code>//-------------------</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="762" end="770" />
        <code>// TODO</code>
      </source_code>
      <source_code type="singlecomment">
        <location start="770" end="792" />
        <code>//-------------------</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Using 2.1 RC2 and RC3a, if I copy a snippet like:

//-------------------
// TODO
//-------------------

    private void method()
    {
        //blah blah
    }


what I get has an incorrect indentation (two spaces added after the // and at
the beginning of every line of code ):


//  -------------------
//   TODO
//  -------------------

      private void method()
      {
          //blah blah
      }
The copy paste function in version 2.1 has a bug concerning identation. When 
more than a line of code are copied, the resulting paste lines have wrong 
identation, except for the first line. The other lines add a tab or more.
Using I20031120, the code is now correctly indented and the single line comments
are on the left border:
//-------------------
// TODO
//-------------------</WithStack>
    <WithOutStack>Using 2.1 RC2 and RC3a, if I copy a snippet like:

//-------------------
// TODO
//-------------------

    private void method()
    {
        //blah blah
    }


what I get has an incorrect indentation (two spaces added after the // and at
the beginning of every line of code ):


//  -------------------
//   TODO
//  -------------------

      private void method()
      {
          //blah blah
      }
The copy paste function in version 2.1 has a bug concerning identation. When 
more than a line of code are copied, the resulting paste lines have wrong 
identation, except for the first line. The other lines add a tab or more.
Using I20031120, the code is now correctly indented and the single line comments
are on the left border:
//-------------------
// TODO
//-------------------</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35450" />
    <CreationDate amount="2003-03-21 06:08:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Can't create project from an existing directory [build path] [code manipulation]</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>I try to create a Java.
I give the name and the directory where my java project is stored.
I press the Next Button and receive an error.

I did it with a 2.0 release without any problem.

I attach the stack trace.
Created attachment 4276
The eclipse log file
I forgot to precise that it is the 2.1 RC2 release.
Moving to JDT/UI for investigation (seems like order of operations is wrong)
Martin, 

can you please investigate.
The problem is that at the location at which you pointed to there is 
a .classpath file, but not a .project file.

If you have them both (with .project file that specifiesthe Java nature) the 
project detection works, also when you delete the .classpath file.

This worked before, but JCore is new now throwing an exception when 
getOutputLocation is calles on a IJavaProject that points to an existing but 
non-java project. For 2.0 this was explicitly allowed as I want to probe 
existing .classpath files but now have to set the Java nature to avoid setting 
up the builder and indexer until the project really is created.
I confirm that Martin has right.
I tried to recreate my .project file that I lost.
I kept my .classpath file in the project directory.
This is somewhat related to fix for bug 31799 where we were incorrectly 
allowing to read non-Java projects, and then become inconsistent.

Note that our implementation doesn't contradict our spec which always said:
 * @exception JavaModelException if this element does not exist

Except that from 2.0 to 2.1 our definition of 'exists' changed....
It does indeed check for Java nature too. Would you prefer having a non-Java 
project claim it exists as a Java element ? This was identified as being a bug 
as well.
Philippe, can you suggest a solution how we get the old behavior back. We 
somehow need to get the output location without creating the project.
discussed with Dirk no action for 2.1 required
There is no obvious way to reach the output location unfortunately of a non-
existing Java project (would need to add Java nature temporarily).
Changing severity to normal since this only happens when there is a .classpath 
file but no .project file.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>I try to create a Java.
I give the name and the directory where my java project is stored.
I press the Next Button and receive an error.

I did it with a 2.0 release without any problem.

I attach the stack trace.
Created attachment 4276
The eclipse log file
I forgot to precise that it is the 2.1 RC2 release.
Moving to JDT/UI for investigation (seems like order of operations is wrong)
Martin, 

can you please investigate.
The problem is that at the location at which you pointed to there is 
a .classpath file, but not a .project file.

If you have them both (with .project file that specifiesthe Java nature) the 
project detection works, also when you delete the .classpath file.

This worked before, but JCore is new now throwing an exception when 
getOutputLocation is calles on a IJavaProject that points to an existing but 
non-java project. For 2.0 this was explicitly allowed as I want to probe 
existing .classpath files but now have to set the Java nature to avoid setting 
up the builder and indexer until the project really is created.
I confirm that Martin has right.
I tried to recreate my .project file that I lost.
I kept my .classpath file in the project directory.
This is somewhat related to fix for bug 31799 where we were incorrectly 
allowing to read non-Java projects, and then become inconsistent.

Note that our implementation doesn't contradict our spec which always said:
 * @exception JavaModelException if this element does not exist

Except that from 2.0 to 2.1 our definition of 'exists' changed....
It does indeed check for Java nature too. Would you prefer having a non-Java 
project claim it exists as a Java element ? This was identified as being a bug 
as well.
Philippe, can you suggest a solution how we get the old behavior back. We 
somehow need to get the output location without creating the project.
discussed with Dirk no action for 2.1 required
There is no obvious way to reach the output location unfortunately of a non-
existing Java project (would need to add Java nature temporarily).
Changing severity to normal since this only happens when there is a .classpath 
file but no .project file.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35451" />
    <CreationDate amount="2003-03-21 06:24:00 -0500" />
    <DupId amount="31700" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[Key Bindings] Next Editor Key Binding Bug</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Attempted to change the Key binding for "Next Editor" to CTRL+TAB, but when I 
press CTRL+TAB it pops up with the "Next Editor" window as is the normal 
behaviour, however it does not let me cycle through the available editors by 
pressing TAB again whilst holding down CTRL as is the behaviour when using 
CTRL+F6.
Note: I am using eclise RC3 build 200303192032


*** This bug has been marked as a duplicate of 31700 ***</WithStack>
    <WithOutStack>Attempted to change the Key binding for "Next Editor" to CTRL+TAB, but when I 
press CTRL+TAB it pops up with the "Next Editor" window as is the normal 
behaviour, however it does not let me cycle through the available editors by 
pressing TAB again whilst holding down CTRL as is the behaviour when using 
CTRL+F6.
Note: I am using eclise RC3 build 200303192032


*** This bug has been marked as a duplicate of 31700 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35452" />
    <CreationDate amount="2003-03-21 06:34:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>super in anonymous prevents move[refactoring]</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="class">
        <location start="43" end="176" />
        <code>public class X {
	void foo() {
		new Object() {
			public String toString() {
				return super.toString();
			}

		}.toString();
	}
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="6">
        <Lines>
          <Line>1. Create the following class:</Line>
          <Line />
          <Line>2. Select foo in Outline</Line>
          <Line>3. Refactor-&gt;Move</Line>
          <Line>Observe: You get a dialog saying that 'The method cannot be moved, since it</Line>
          <Line>uses the "super" keyword.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build RC3a

1. Create the following class:
public class X {
	void foo() {
		new Object() {
			public String toString() {
				return super.toString();
			}

		}.toString();
	}
}
2. Select foo in Outline
3. Refactor-&gt;Move
Observe: You get a dialog saying that 'The method cannot be moved, since it 
uses the "super" keyword.

The "super" keyword is used in an anonymous class of the method. It should not 
prevent the move.
true - to be fixed, but only after 2.1
deferring
reopening
Created attachment 5692
Fix
Created attachment 5693
Tests
Markus, can you re-create the patches on the latest code? 
i already have test15 that this patch adds
Created attachment 5750
Fix
Created attachment 5751
Tests
great, thanks - patch released
please also include a test for the local type case - i came across bug 41530 
while trying to create one
fixed</WithStack>
    <WithOutStack>Build RC3a

1. Create the following class:
public class X {
	void foo() {
		new Object() {
			public String toString() {
				return super.toString();
			}

		}.toString();
	}
}
2. Select foo in Outline
3. Refactor-&gt;Move
Observe: You get a dialog saying that 'The method cannot be moved, since it 
uses the "super" keyword.

The "super" keyword is used in an anonymous class of the method. It should not 
prevent the move.
true - to be fixed, but only after 2.1
deferring
reopening
Created attachment 5692
Fix
Created attachment 5693
Tests
Markus, can you re-create the patches on the latest code? 
i already have test15 that this patch adds
Created attachment 5750
Fix
Created attachment 5751
Tests
great, thanks - patch released
please also include a test for the local type case - i came across bug 41530 
while trying to create one
fixed</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35453" />
    <CreationDate amount="2003-03-21 07:40:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Process output causes switch to wrong console view.</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>This particular programm I'm debugging happens to produce a bit of output
on the console.

I'd like to push the console output view to the background
and look at the debug view, that happens to occupy the same spot of screen.

That doesn't work. I'm immediately back to see the new output.

No doubt that there is some configuration someplace to have Eclipse
not switch to output as it happens.  But, in general, I want to see
the output as it happens.  Only just now, I don't.

So I decide to try being lazy, and switch the console output view
to the output of a programm that's already terminated.
That works, I get to see that old output and, no wonder: no movement.

So, now I switch to that debug view.

Nope - the next output of my programm that's still running switches me back
to the console output view.

So far, so acceptable, if you want to handle it that way.
(Though I'd appreciate if the GUI would allow that shortcut.)

The bug is:
What I'm switched back to is the console output of that programm
that's already terminated.  Of course, nothing has moved.

No point switching me there.

Either switch me to the paricular console output that has moved.
But that would not be a good idea if two programms actually run
simultaniously and rapidly fire output.

Or, which is what I'd prefer, switch me to the console output view
only if the stuff I get to see there has actually changed.
See the "Debug -&gt; Console" pref page for controlling the auto display of the 
console:

* Show when program writes to standard out
* Show when program writes to stnadard err

However, is sounds like our "process lock" (i.e. selecting the output of a 
specific process) has a bug. I.e. we show the console since a program has 
produced output, but the process being displayed is not the one that has 
produced output.
Deferred
re-opening
Cannot reproduce with latest console implementation.
Please verify, Darin (S).
The console is still being brought to the front for me.

Layer the console view in the same pane as the debug view.
I ran a program that loops forever, System.out every 3 seconds.
Pin the console on a terminated process doc
Switch to the debug view.
On the three seconds, the console view is brought to the front.
I fixed the problem in ConsoleDocumentManager.showConsole
If the console view is pinned, the console view is not brought to front unless 
that pinned console is the one for the process being written to.

I also made a small change in ConsoleView to make it immediate that display
(IConsole) has no impact if it is pinned.

Please verify DarinW.
Verified.</WithStack>
    <WithOutStack>This particular programm I'm debugging happens to produce a bit of output
on the console.

I'd like to push the console output view to the background
and look at the debug view, that happens to occupy the same spot of screen.

That doesn't work. I'm immediately back to see the new output.

No doubt that there is some configuration someplace to have Eclipse
not switch to output as it happens.  But, in general, I want to see
the output as it happens.  Only just now, I don't.

So I decide to try being lazy, and switch the console output view
to the output of a programm that's already terminated.
That works, I get to see that old output and, no wonder: no movement.

So, now I switch to that debug view.

Nope - the next output of my programm that's still running switches me back
to the console output view.

So far, so acceptable, if you want to handle it that way.
(Though I'd appreciate if the GUI would allow that shortcut.)

The bug is:
What I'm switched back to is the console output of that programm
that's already terminated.  Of course, nothing has moved.

No point switching me there.

Either switch me to the paricular console output that has moved.
But that would not be a good idea if two programms actually run
simultaniously and rapidly fire output.

Or, which is what I'd prefer, switch me to the console output view
only if the stuff I get to see there has actually changed.
See the "Debug -&gt; Console" pref page for controlling the auto display of the 
console:

* Show when program writes to standard out
* Show when program writes to stnadard err

However, is sounds like our "process lock" (i.e. selecting the output of a 
specific process) has a bug. I.e. we show the console since a program has 
produced output, but the process being displayed is not the one that has 
produced output.
Deferred
re-opening
Cannot reproduce with latest console implementation.
Please verify, Darin (S).
The console is still being brought to the front for me.

Layer the console view in the same pane as the debug view.
I ran a program that loops forever, System.out every 3 seconds.
Pin the console on a terminated process doc
Switch to the debug view.
On the three seconds, the console view is brought to the front.
I fixed the problem in ConsoleDocumentManager.showConsole
If the console view is pinned, the console view is not brought to front unless 
that pinned console is the one for the process being written to.

I also made a small change in ConsoleView to make it immediate that display
(IConsole) has no impact if it is pinned.

Please verify DarinW.
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35454" />
    <CreationDate amount="2003-03-21 07:41:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Plugin import failed when updating self-hosting workspace</Summery>
    <Patches amount="0" />
    <Stacktraces amount="3">
      <Stacktrace timestamp="1437340488147">
        <Exception>org.eclipse.core.internal.resources.ResourceException</Exception>
        <Reason>Problems encountered 
while deleting resources.</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:169)</Frame>
          <Frame depth="1">org.eclipse.core.internal.resources.ResourceTree.standardDeleteProject(ResourceTree.java:705)</Frame>
          <Frame depth="2">org.eclipse.core.internal.resources.Resource.delete(Resource.java:638)</Frame>
          <Frame depth="3">org.eclipse.core.internal.resources.Project.delete(Project.java:288)</Frame>
          <Frame depth="4">org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.createProject(PluginImportOperation.java:157)</Frame>
          <Frame depth="5">org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.run(PluginImportOperation.java:125)</Frame>
          <Frame depth="6">org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1595)</Frame>
          <Frame depth="7">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard$2.run(PluginImportWizard.java:185)</Frame>
          <Frame depth="8">org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:101)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488147">
        <Exception>org.eclipse.core.internal.resources.ResourceException</Exception>
        <Reason>Problems encountered 
while deleting resources.</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:169)</Frame>
          <Frame depth="1">org.eclipse.core.internal.resources.ResourceTree.standardDeleteProject(ResourceTree.java:705)</Frame>
          <Frame depth="2">org.eclipse.core.internal.resources.Resource.delete(Resource.java:638)</Frame>
          <Frame depth="3">org.eclipse.core.internal.resources.Project.delete(Project.java:288)</Frame>
          <Frame depth="4">org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.createProject(PluginImportOperation.java:157)</Frame>
          <Frame depth="5">org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.run(PluginImportOperation.java:125)</Frame>
          <Frame depth="6">org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1595)</Frame>
          <Frame depth="7">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard$2.run(PluginImportWizard.java:185)</Frame>
          <Frame depth="8">org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:101)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488147">
        <Exception>org.eclipse.core.internal.resources.ResourceException</Exception>
        <Reason>Problems encountered 
while deleting resources.</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:169)</Frame>
          <Frame depth="1">org.eclipse.core.internal.resources.ResourceTree.standardDeleteProject(ResourceTree.java:705)</Frame>
          <Frame depth="2">org.eclipse.core.internal.resources.Resource.delete(Resource.java:638)</Frame>
          <Frame depth="3">org.eclipse.core.internal.resources.Project.delete(Project.java:288)</Frame>
          <Frame depth="4">org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.createProject(PluginImportOperation.java:157)</Frame>
          <Frame depth="5">org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.run(PluginImportOperation.java:125)</Frame>
          <Frame depth="6">org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1595)</Frame>
          <Frame depth="7">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard$2.run(PluginImportWizard.java:185)</Frame>
          <Frame depth="8">org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:101)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Build RC3a

I had a 20030318 self-hosting full-source workspace, which I upgraded to RC3a 
contents (binary project mode).

During the import, it prompted me about some missing references which would be 
mapped to projects(I allowed it ?!). Note: before the import, there was no such 
unbound reference issue in my workspace. Is this a bug in PDE import ?

Then, in the end the import failed with following detail:

Problems detected while importing plug-ins
  Could not delete: /org.apache.xerces.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xercesImpl.jar.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xmlParserAPIs.jar.
  Could not delete: /org.eclipse.core.resources.win32.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86\core_2_1_0a.dll.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os.
  Could not delete: /org.eclipse.pde.junit.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.pde.junit\junitpde.jar.
Log contents:

!ENTRY org.eclipse.pde.ui 4 0 Mar 21, 2003 13:33:29.375
!MESSAGE Problems detected while importing plug-ins
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: /org.apache.xerces.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered 
while deleting resources.
        at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete
(FileSystemResourceManager.java:169)
        at 
org.eclipse.core.internal.resources.ResourceTree.standardDeleteProject
(ResourceTree.java:705)
        at org.eclipse.core.internal.resources.Resource.delete
(Resource.java:638)
        at org.eclipse.core.internal.resources.Project.delete(Project.java:288)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.createProject
(PluginImportOperation.java:157)
        at org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.run
(PluginImportOperation.java:125)
        at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1595)
        at org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard$2.run
(PluginImportWizard.java:185)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:101)
!ENTRY org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xercesImpl.jar.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xmlParserAPIs.jar.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xercesImpl.jar.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xmlParserAPIs.jar.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: /org.eclipse.core.resources.win32.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered 
while deleting resources.
        at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete
(FileSystemResourceManager.java:169)
        at 
org.eclipse.core.internal.resources.ResourceTree.standardDeleteProject
(ResourceTree.java:705)
        at org.eclipse.core.internal.resources.Resource.delete
(Resource.java:638)
        at org.eclipse.core.internal.resources.Project.delete(Project.java:288)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.createProject
(PluginImportOperation.java:157)
        at org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.run
(PluginImportOperation.java:125)
        at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1595)
        at org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard$2.run
(PluginImportWizard.java:185)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:101)
!ENTRY org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86\core_2_1_0a.dll.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86\core_2_1_0a.dll.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: /org.eclipse.pde.junit.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered 
while deleting resources.
        at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete
(FileSystemResourceManager.java:169)
        at 
org.eclipse.core.internal.resources.ResourceTree.standardDeleteProject
(ResourceTree.java:705)
        at org.eclipse.core.internal.resources.Resource.delete
(Resource.java:638)
        at org.eclipse.core.internal.resources.Project.delete(Project.java:288)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.createProject
(PluginImportOperation.java:157)
        at org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.run
(PluginImportOperation.java:125)
        at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1595)
        at org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard$2.run
(PluginImportWizard.java:185)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:101)
!ENTRY org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.pde.junit\junitpde.jar.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.pde.junit\junitpde.jar.
The dialog you now get warns you that we cannot resolve all referenced plug-
ins. The question you are asked is if we should assume they will come later as 
projects. If you say 'yes', we resolve them as project classpath entries 
assuming that you will make these projects appear later.

Historically, errors while deleting projects are caused by JDT holding the JAR 
handles open.
I see, however all referenced plugins were selected for import, so it shouldn't 
have complained.
*** Bug 38556 has been marked as a duplicate of this bug. ***
closing as this must have been a transient problem.</WithStack>
    <WithOutStack>Build RC3a

I had a 20030318 self-hosting full-source workspace, which I upgraded to RC3a 
contents (binary project mode).

During the import, it prompted me about some missing references which would be 
mapped to projects(I allowed it ?!). Note: before the import, there was no such 
unbound reference issue in my workspace. Is this a bug in PDE import ?

Then, in the end the import failed with following detail:

Problems detected while importing plug-ins
  Could not delete: /org.apache.xerces.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xercesImpl.jar.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xmlParserAPIs.jar.
  Could not delete: /org.eclipse.core.resources.win32.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86\core_2_1_0a.dll.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os.
  Could not delete: /org.eclipse.pde.junit.
    Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.pde.junit\junitpde.jar.
Log contents:

!ENTRY org.eclipse.pde.ui 4 0 Mar 21, 2003 13:33:29.375
!MESSAGE Problems detected while importing plug-ins
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: /org.apache.xerces.
!STACK 1
!ENTRY org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xercesImpl.jar.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xmlParserAPIs.jar.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xercesImpl.jar.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.apache.xerces\xmlParserAPIs.jar.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: /org.eclipse.core.resources.win32.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered 
while deleting resources.
        at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete
(FileSystemResourceManager.java:169)
        at 
org.eclipse.core.internal.resources.ResourceTree.standardDeleteProject
(ResourceTree.java:705)
        at org.eclipse.core.internal.resources.Resource.delete
(Resource.java:638)
        at org.eclipse.core.internal.resources.Project.delete(Project.java:288)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.createProject
(PluginImportOperation.java:157)
        at org.eclipse.pde.internal.ui.wizards.imports.PluginImportOperation.run
(PluginImportOperation.java:125)
        at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1595)
        at org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard$2.run
(PluginImportWizard.java:185)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:101)
!ENTRY org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86\core_2_1_0a.dll.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86\core_2_1_0a.dll.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32\x86.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os\win32.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.core.resources.win32\os.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: /org.eclipse.pde.junit.
!STACK 1

!ENTRY org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 1 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.pde.junit\junitpde.jar.
!SUBENTRY 2 org.eclipse.core.resources 4 273 Mar 21, 2003 13:33:29.375
!MESSAGE Could not delete: D:\eclipse\workspaces\dev2.0
\plugins\org.eclipse.pde.junit\junitpde.jar.
The dialog you now get warns you that we cannot resolve all referenced plug-
ins. The question you are asked is if we should assume they will come later as 
projects. If you say 'yes', we resolve them as project classpath entries 
assuming that you will make these projects appear later.

Historically, errors while deleting projects are caused by JDT holding the JAR 
handles open.
I see, however all referenced plugins were selected for import, so it shouldn't 
have complained.
*** Bug 38556 has been marked as a duplicate of this bug. ***
closing as this must have been a transient problem.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35455" />
    <CreationDate amount="2003-03-21 07:44:00 -0500" />
    <DupId amount="35236" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>NPE in editor while importing binary plugins</Summery>
    <Patches amount="0" />
    <Stacktraces amount="10">
      <Stacktrace timestamp="1437340488167">
        <Exception>org.eclipse.swt.SWTException</Exception>
        <Reason>Failed to execute runnable 
(java.lang.NullPointerException)</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.SWT.error(SWT.java:2320)</Frame>
          <Frame depth="1">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:101)</Frame>
          <Frame depth="2">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="3">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="4">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="5">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="6">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="7">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="8">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="9">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="11">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="12">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="13">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="14">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="15">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="16">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="17">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="18">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="19">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="20">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="21">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="22">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="23">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="24">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="25">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="26">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="27">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="28">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="29">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="30">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="31">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="32">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="33">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="34">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="35">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="36">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="37">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="38">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="39">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="40">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="41">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="42">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="43">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="44">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="45">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="46">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="47">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="48">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="49">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:2308)</Frame>
          <Frame depth="1">org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:160)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:1560)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput(ClassFileEditor.java:518)</Frame>
          <Frame depth="4">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2337)</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="6">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="7">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="8">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="9">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="10">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="11">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="12">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="13">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="14">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="15">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="16">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="18">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="19">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="20">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="21">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="22">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="23">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="24">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="25">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="26">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="27">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="28">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="29">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="30">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="31">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="32">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="33">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="34">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="35">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="36">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="37">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="38">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="39">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="40">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="41">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="42">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="43">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="44">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="45">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="46">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="47">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="48">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="49">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="50">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="51">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="52">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="53">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="54">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="55">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason>!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.134
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.144
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.SWT.error(SWT.java:2320)</Frame>
          <Frame depth="1">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:101)</Frame>
          <Frame depth="2">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="3">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="4">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="5">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="6">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="7">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="8">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="9">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="11">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="12">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="13">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="14">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="15">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="16">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="17">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="18">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="19">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="20">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="21">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="22">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="23">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="24">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="25">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="26">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="27">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="28">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="29">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="30">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="31">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="32">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="33">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="34">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="35">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="36">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="37">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="38">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="39">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="40">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="41">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="42">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="43">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="44">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="45">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="46">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="47">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="48">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="49">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:2308)</Frame>
          <Frame depth="1">org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:160)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:1560)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput(ClassFileEditor.java:518)</Frame>
          <Frame depth="4">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2337)</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="6">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="7">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="8">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="9">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="10">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="11">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="12">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="13">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="14">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="15">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="16">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="18">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="19">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="20">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="21">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="22">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="23">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="24">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="25">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="26">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="27">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="28">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="29">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="30">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="31">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="32">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="33">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="34">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="35">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="36">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="37">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="38">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="39">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="40">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="41">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="42">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="43">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="44">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="45">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="46">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="47">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="48">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="49">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="50">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="51">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="52">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="53">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="54">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="55">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason>!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.234
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.234
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.SWT.error(SWT.java:2320)</Frame>
          <Frame depth="1">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:101)</Frame>
          <Frame depth="2">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="3">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="4">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="5">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="6">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="7">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="8">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="9">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="11">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="12">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="13">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="14">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="15">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="16">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="17">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="18">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="19">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="20">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="21">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="22">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="23">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="24">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="25">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="26">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="27">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="28">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="29">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="30">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="31">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="32">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="33">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="34">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="35">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="36">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="37">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="38">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="39">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="40">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="41">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="42">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="43">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="44">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="45">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="46">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="47">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="48">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="49">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:2308)</Frame>
          <Frame depth="1">org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:160)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:1560)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput(ClassFileEditor.java:518)</Frame>
          <Frame depth="4">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2337)</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="6">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="7">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="8">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="9">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="10">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="11">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="12">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="13">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="14">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="15">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="16">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="18">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="19">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="20">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="21">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="22">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="23">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="24">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="25">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="26">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="27">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="28">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="29">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="30">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="31">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="32">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="33">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="34">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="35">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="36">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="37">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="38">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="39">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="40">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="41">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="42">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="43">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="44">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="45">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="46">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="47">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="48">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="49">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="50">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="51">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="52">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="53">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="54">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="55">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason>!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.254
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.264
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.SWT.error(SWT.java:2320)</Frame>
          <Frame depth="1">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:101)</Frame>
          <Frame depth="2">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="3">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="4">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="5">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="6">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="7">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="8">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="9">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="11">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="12">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="13">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="14">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="15">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="16">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="17">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="18">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="19">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="20">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="21">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="22">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="23">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="24">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="25">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="26">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="27">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="28">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="29">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="30">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="31">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="32">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="33">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="34">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="35">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="36">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="37">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="38">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="39">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="40">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="41">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="42">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="43">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="44">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="45">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="46">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="47">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="48">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="49">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:2308)</Frame>
          <Frame depth="1">org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:160)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:1560)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput(ClassFileEditor.java:518)</Frame>
          <Frame depth="4">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2337)</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="6">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="7">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="8">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="9">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="10">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="11">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="12">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="13">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="14">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="15">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="16">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="18">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="19">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="20">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="21">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="22">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="23">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="24">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="25">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="26">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="27">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="28">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="29">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="30">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="31">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="32">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="33">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="34">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="35">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="36">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="37">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="38">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="39">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="40">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="41">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="42">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="43">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="44">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="45">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="46">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="47">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="48">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="49">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="50">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="51">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="52">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="53">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="54">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="55">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason>!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.354
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.354
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.SWT.error(SWT.java:2320)</Frame>
          <Frame depth="1">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:101)</Frame>
          <Frame depth="2">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="3">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="4">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="5">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="6">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="7">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="8">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="9">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="11">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="12">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="13">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="14">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="15">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="16">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="17">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="18">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="19">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="20">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="21">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="22">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="23">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="24">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="25">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="26">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="27">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="28">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="29">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="30">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="31">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="32">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="33">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="34">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="35">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="36">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="37">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="38">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="39">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="40">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="41">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="42">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="43">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="44">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="45">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="46">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="47">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="48">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="49">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488167">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:2308)</Frame>
          <Frame depth="1">org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:160)</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:1560)</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput(ClassFileEditor.java:518)</Frame>
          <Frame depth="4">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2337)</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="6">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="7">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="8">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="9">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="10">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="11">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="12">org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)</Frame>
          <Frame depth="13">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)</Frame>
          <Frame depth="14">org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)</Frame>
          <Frame depth="15">org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:2343)</Frame>
          <Frame depth="16">org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run(ClassFileEditor.java:617)</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)</Frame>
          <Frame depth="18">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:98)</Frame>
          <Frame depth="19">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)</Frame>
          <Frame depth="20">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)</Frame>
          <Frame depth="21">org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:136)</Frame>
          <Frame depth="22">org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)</Frame>
          <Frame depth="23">org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)</Frame>
          <Frame depth="24">org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish(PluginImportWizard.java:145)</Frame>
          <Frame depth="25">org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:608)</Frame>
          <Frame depth="26">org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:321)</Frame>
          <Frame depth="27">org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)</Frame>
          <Frame depth="28">org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:91)</Frame>
          <Frame depth="29">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="30">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="31">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="32">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="33">org.eclipse.jface.window.Window.runEventLoop(Window.java:583)</Frame>
          <Frame depth="34">org.eclipse.jface.window.Window.open(Window.java:563)</Frame>
          <Frame depth="35">org.eclipse.ui.actions.ImportResourcesAction.run(ImportResourcesAction.java:96)</Frame>
          <Frame depth="36">org.eclipse.jface.action.Action.runWithEvent(Action.java:842)</Frame>
          <Frame depth="37">org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)</Frame>
          <Frame depth="38">org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)</Frame>
          <Frame depth="39">org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)</Frame>
          <Frame depth="40">org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)</Frame>
          <Frame depth="41">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)</Frame>
          <Frame depth="42">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)</Frame>
          <Frame depth="43">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)</Frame>
          <Frame depth="44">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)</Frame>
          <Frame depth="45">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)</Frame>
          <Frame depth="46">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="47">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="48">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="49">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="50">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="51">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="52">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="53">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="54">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="55">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Build RC3a

When upgrading a self-hosting binary workspace using PDE import, I got the 
following failures in the log:

!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:43.543
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:43.593
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)
        at org.eclipse.swt.SWT.error(SWT.java:2320)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:101)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:43.984
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.04
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
java.lang.NullPointerException
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.134
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.144
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)
        at org.eclipse.swt.SWT.error(SWT.java:2320)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:101)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.224
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.224
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
java.lang.NullPointerException
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.234
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.234
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)
        at org.eclipse.swt.SWT.error(SWT.java:2320)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:101)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.244
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.254
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
java.lang.NullPointerException
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.254
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.264
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)
        at org.eclipse.swt.SWT.error(SWT.java:2320)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:101)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.294
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.304
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
java.lang.NullPointerException
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.354
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.354
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable 
(java.lang.NullPointerException)
        at org.eclipse.swt.SWT.error(SWT.java:2320)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:101)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.364
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.374
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
java.lang.NullPointerException
This is also caused by reacting to the mass of change notifications send out 
by core.

*** This bug has been marked as a duplicate of 35236 ***</WithStack>
    <WithOutStack>Build RC3a

When upgrading a self-hosting binary workspace using PDE import, I got the 
following failures in the log:

!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:43.543
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:43.593
!MESSAGE Failed to execute runnable (java.lang.NullPointerException)
!STACK 0
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:43.984
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.04
!MESSAGE java.lang.NullPointerException
!STACK 0
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.224
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.224
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.244
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.254
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.294
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.304
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Failed to execute runnable (java.lang.NullPointerException)
!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 13:29:44.364
!MESSAGE
*** Stack trace of contained exception ***

*** Stack trace of contained exception ***
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 13:29:44.374
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
        at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput
(AbstractTextEditor.java:2308)
        at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput
(StatusTextEditor.java:160)
        at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput
(JavaEditor.java:1560)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.doSetInput
(ClassFileEditor.java:518)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2337)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:292)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:355)
        at org.eclipse.jface.dialogs.ErrorDialog.openError(ErrorDialog.java:318)
        at org.eclipse.ui.texteditor.AbstractTextEditor.setInput
(AbstractTextEditor.java:2343)
        at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$4.run
(ClassFileEditor.java:617)
        at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
        at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:98)
        at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1819)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1553)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:136)
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:261)
        at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:758)
        at 
org.eclipse.pde.internal.ui.wizards.imports.PluginImportWizard.performFinish
(PluginImportWizard.java:145)
        at org.eclipse.jface.wizard.WizardDialog.finishPressed
(WizardDialog.java:608)
        at org.eclipse.jface.wizard.WizardDialog.buttonPressed
(WizardDialog.java:321)
        at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:423)
        at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:91)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:583)
        at org.eclipse.jface.window.Window.open(Window.java:563)
        at org.eclipse.ui.actions.ImportResourcesAction.run
(ImportResourcesAction.java:96)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:456)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent
(ActionContributionItem.java:403)
        at org.eclipse.jface.action.ActionContributionItem.access$0
(ActionContributionItem.java:397)
        at 
org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent
(ActionContributionItem.java:72)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1842)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1549)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402)
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
java.lang.NullPointerException
This is also caused by reacting to the mass of change notifications send out 
by core.

*** This bug has been marked as a duplicate of 35236 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35456" />
    <CreationDate amount="2003-03-21 07:46:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="critical" />
    <Summery>The Eclipse compiler generates classes that throw a VerifyError</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437340488177">
        <Exception>java.lang.VerifyError</Exception>
        <Reason>(class: oranges/Derived$Inner, method: bug signature: ()
V) Incompatible type for getting or setting field</Reason>
        <Frames>
          <Frame depth="0">java.lang.Class.forName0(Native Method)</Frame>
          <Frame depth="1">java.lang.Class.forName(Class.java:140)</Frame>
          <Frame depth="2">Main.main(Main.java:4)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>The Eclipse compiler generates classes that throw a java.lang.VerifyError when 
they are loaded. If Sun's javac or IBM's jikes is used to compile the same 
class, no error occurs.

This happens when an inner class accesses a protected field belonging to the 
base class of the outer class if the base class and the outer class are in 
different packages. (Hope that makes sense!)

java.lang.VerifyError: (class: oranges/Derived$Inner, method: bug signature: ()
V) Incompatible type for getting or setting field
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:140)
	at Main.main(Main.java:4)
Exception in thread "main"
Created attachment 4277
Bug demonstration classes

The VerifyError.jar file contains a simple Eclipse project to demonstrate the
bug. I contains classes that I've compiled using 2.1 rc3a - you may run it by
typing "java -jar VerifyError.jar". Tested with java 1.4.1_01 and 1.4.1_02
The bug is in the innerclass emulation. 

In reference from Derived$Inner.bug() to 'c.foo', we generate code as if 'c' 
was defined in enclosing type Derived (where it is defined at depth 0).

Method void bug()
   0 getstatic #29 &lt;Field java.io.PrintStream out&gt;
   3 aload_0
   4 getfield #16 &lt;Field oranges.Derived this$0&gt; // SHOULD NOT BE HERE
   7 getfield #18 &lt;Field oranges.Derived c&gt;
  10 invokestatic #35 &lt;Method java.lang.String access$0(oranges.Derived)&gt;
  13 invokevirtual #41 &lt;Method void println(java.lang.String)&gt;
  16 return
}
As a workaround, you may simply write 'this.c.foo' instead of 'c.foo'.
Problem isolated. #setDepth implementation weren't doing anything when depth is 
set to zero (can occur for QualifiedNameReferences when binding subsequent 
fields).

Fix is quite simple.
Created attachment 4279
setDepth patch
Tushar - isn't the workaround a viable solution for 2.1 ?
Yes, the workaround is good :-) Thanks for the quick turnaround Philippe :-)



+1
+1
+1
+1
Fix released for integration
Verified.</WithStack>
    <WithOutStack>The Eclipse compiler generates classes that throw a java.lang.VerifyError when 
they are loaded. If Sun's javac or IBM's jikes is used to compile the same 
class, no error occurs.

This happens when an inner class accesses a protected field belonging to the 
base class of the outer class if the base class and the outer class are in 
different packages. (Hope that makes sense!)


Exception in thread "main"
Created attachment 4277
Bug demonstration classes

The VerifyError.jar file contains a simple Eclipse project to demonstrate the
bug. I contains classes that I've compiled using 2.1 rc3a - you may run it by
typing "java -jar VerifyError.jar". Tested with java 1.4.1_01 and 1.4.1_02
The bug is in the innerclass emulation. 

In reference from Derived$Inner.bug() to 'c.foo', we generate code as if 'c' 
was defined in enclosing type Derived (where it is defined at depth 0).

Method void bug()
   0 getstatic #29 &lt;Field java.io.PrintStream out&gt;
   3 aload_0
   4 getfield #16 &lt;Field oranges.Derived this$0&gt; // SHOULD NOT BE HERE
   7 getfield #18 &lt;Field oranges.Derived c&gt;
  10 invokestatic #35 &lt;Method java.lang.String access$0(oranges.Derived)&gt;
  13 invokevirtual #41 &lt;Method void println(java.lang.String)&gt;
  16 return
}
As a workaround, you may simply write 'this.c.foo' instead of 'c.foo'.
Problem isolated. #setDepth implementation weren't doing anything when depth is 
set to zero (can occur for QualifiedNameReferences when binding subsequent 
fields).

Fix is quite simple.
Created attachment 4279
setDepth patch
Tushar - isn't the workaround a viable solution for 2.1 ?
Yes, the workaround is good :-) Thanks for the quick turnaround Philippe :-)



+1
+1
+1
+1
Fix released for integration
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35457" />
    <CreationDate amount="2003-03-21 07:46:00 -0500" />
    <DupId amount="34142" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>ArrayIndexOutOfBoundsException on Workbench startup</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437340488177">
        <Exception>java.lang.ArrayIndexOutOfBoundsException</Exception>
        <Reason>-1</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.ui.internal.NavigationHistory.restoreState(NavigationHistory.java:424)</Frame>
          <Frame depth="1">org.eclipse.ui.internal.WorkbenchPage.restoreState(WorkbenchPage.java:2331)</Frame>
          <Frame depth="2">org.eclipse.ui.internal.WorkbenchWindow.restoreState(WorkbenchWindow.java:1327)</Frame>
          <Frame depth="3">org.eclipse.ui.internal.Workbench.restoreState(Workbench.java:1261)</Frame>
          <Frame depth="4">org.eclipse.ui.internal.Workbench.access$10(Workbench.java:1221)</Frame>
          <Frame depth="5">org.eclipse.ui.internal.Workbench$12.run(Workbench.java:1139)</Frame>
          <Frame depth="6">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="7">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="8">org.eclipse.ui.internal.Workbench.openPreviousWorkbenchState(Workbench.java:1091)</Frame>
          <Frame depth="9">org.eclipse.ui.internal.Workbench.init(Workbench.java:868)</Frame>
          <Frame depth="10">org.eclipse.ui.internal.Workbench.run(Workbench.java:1371)</Frame>
          <Frame depth="11">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="12">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="13">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="14">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="15">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="16">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="17">org.eclipse.core.launcher.Main.basicRun(Main.java:247)</Frame>
          <Frame depth="18">org.eclipse.core.launcher.Main.run(Main.java:703)</Frame>
          <Frame depth="19">org.eclipse.core.launcher.Main.main(Main.java:539)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>2.1 RC2

I get the following error randomly at workbench startup. After this error, the 
layout is reset to default each time. 

This is a little bit annoying. There should be a smarter error recovery 
mechanisme on such errors.


!ENTRY org.eclipse.ui.workbench 4 2 Mrz 21, 2003 13:33:32.923
!MESSAGE Problems occurred when invoking code from plug-
in: "org.eclipse.ui.workbench".
!STACK 0
java.lang.ArrayIndexOutOfBoundsException: -1
	at org.eclipse.ui.internal.NavigationHistory.restoreState
(NavigationHistory.java:424)
	at org.eclipse.ui.internal.WorkbenchPage.restoreState
(WorkbenchPage.java:2331)
	at org.eclipse.ui.internal.WorkbenchWindow.restoreState
(WorkbenchWindow.java:1327)
	at org.eclipse.ui.internal.Workbench.restoreState(Workbench.java:1261)
	at org.eclipse.ui.internal.Workbench.access$10(Workbench.java:1221)
	at org.eclipse.ui.internal.Workbench$12.run(Workbench.java:1139)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.ui.internal.Workbench.openPreviousWorkbenchState
(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.init(Workbench.java:868)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:1371)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:247)
	at org.eclipse.core.launcher.Main.run(Main.java:703)
	at org.eclipse.core.launcher.Main.main(Main.java:539)


*** This bug has been marked as a duplicate of 34142 ***</WithStack>
    <WithOutStack>2.1 RC2

I get the following error randomly at workbench startup. After this error, the 
layout is reset to default each time. 

This is a little bit annoying. There should be a smarter error recovery 
mechanisme on such errors.


!ENTRY org.eclipse.ui.workbench 4 2 Mrz 21, 2003 13:33:32.923
!MESSAGE Problems occurred when invoking code from plug-
in: "org.eclipse.ui.workbench".
!STACK 0



*** This bug has been marked as a duplicate of 34142 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35458" />
    <CreationDate amount="2003-03-21 07:54:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Compiler setting change should trigger also an incremental build [build path]</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Build RC3a

When a project rebuild is proposed, there is a chance that some dependent 
project is affected as well. Thus the proposed build action should also trigger 
an incremental build so affected dependent projects would get a chance to 
refresh accordingly.
Philippe, what cases do you think of. IMO chaning compiler settings should not 
result in changes that need recompile of dependent projects. I just to 
understand how important this is for 2.1
This isn't critical to 2.1. If you fully build one project, its dependents will 
need to be refreshed as well (you can observe this by pressing the build 
button, incremental activity will be triggered). 

The only problem I am currently seeing is that when I customize one project 
settings, then it asks for rebuild, but then if I go and edit one unit in a 
dependent project, the incremental build will be quite massive, even though the 
it was only a minor edit.
Moving to later then.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>Build RC3a

When a project rebuild is proposed, there is a chance that some dependent 
project is affected as well. Thus the proposed build action should also trigger 
an incremental build so affected dependent projects would get a chance to 
refresh accordingly.
Philippe, what cases do you think of. IMO chaning compiler settings should not 
result in changes that need recompile of dependent projects. I just to 
understand how important this is for 2.1
This isn't critical to 2.1. If you fully build one project, its dependents will 
need to be refreshed as well (you can observe this by pressing the build 
button, incremental activity will be triggered). 

The only problem I am currently seeing is that when I customize one project 
settings, then it asks for rebuild, but then if I go and edit one unit in a 
dependent project, the incremental build will be quite massive, even though the 
it was only a minor edit.
Moving to later then.
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35459" />
    <CreationDate amount="2003-03-21 08:00:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Debug" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows NT" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>"Run As ..." menu disabled</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>All entry of the submenu of "Run As ..." in the menu "Run" are disabled. The
same submenu of the "Run"-icon works (that means it is enabled).
The launch shortcuts are disabled when there is no selection in a view, and 
there is no open editor. However, it looks like the enablement is different 
between the two menus (i.e. the run/debug drop down menus, and the top level 
run menu).
It appears that the "debug as/run as" menu in the top level "run" menu is not 
re-created each time it is realized, as is the menu in the run/debug drop 
downs. Thus the enablement is not dynamic based on selection.
Created attachment 4330
Steps to recreate menu option enable problem
Created attachment 4331
Steps to recreate menu option enable problem
Created attachment 4333
Patch for LaunchAsAction
Verified patch. Marking as RC4 candidate, as this is a regression from 2.0.
Fix released to HEAD.
Please verify.
Verified.
*** Bug 35548 has been marked as a duplicate of this bug. ***</WithStack>
    <WithOutStack>All entry of the submenu of "Run As ..." in the menu "Run" are disabled. The
same submenu of the "Run"-icon works (that means it is enabled).
The launch shortcuts are disabled when there is no selection in a view, and 
there is no open editor. However, it looks like the enablement is different 
between the two menus (i.e. the run/debug drop down menus, and the top level 
run menu).
It appears that the "debug as/run as" menu in the top level "run" menu is not 
re-created each time it is realized, as is the menu in the run/debug drop 
downs. Thus the enablement is not dynamic based on selection.
Created attachment 4330
Steps to recreate menu option enable problem
Created attachment 4331
Steps to recreate menu option enable problem
Created attachment 4333
Patch for LaunchAsAction
Verified patch. Marking as RC4 candidate, as this is a regression from 2.0.
Fix released to HEAD.
Please verify.
Verified.
*** Bug 35548 has been marked as a duplicate of this bug. ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35460" />
    <CreationDate amount="2003-03-21 08:28:00 -0500" />
    <DupId amount="10668" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Debug" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Variable selection reset when resuming to next occurrence of breakpoint</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Build RC3a

When setting breakpoint on first line of QualifiedNameReference#generateCode,
and running the compiler on a file which is going to hit the breakpoint twice,
at first hit I did select the variable 'this'.

Then resumed execution until next hit. When reached, 'this' ad got deselected.
if "this" is actually a different object in the two invocations, it will not be 
reselected/expanded with our current implementation. We select/expand based on 
equality (not name).
When I select, I do pick a name, not a value... so in a consistent way, the 
reselection should occur on a name basis. For expansion, though this should 
likely be a value equality I agree.
Deferred
Open for 3.0
Fixed in conjunction with bug 10668.

*** This bug has been marked as a duplicate of 10668 ***</WithStack>
    <WithOutStack>Build RC3a

When setting breakpoint on first line of QualifiedNameReference#generateCode,
and running the compiler on a file which is going to hit the breakpoint twice,
at first hit I did select the variable 'this'.

Then resumed execution until next hit. When reached, 'this' ad got deselected.
if "this" is actually a different object in the two invocations, it will not be 
reselected/expanded with our current implementation. We select/expand based on 
equality (not name).
When I select, I do pick a name, not a value... so in a consistent way, the 
reselection should occur on a name basis. For expansion, though this should 
likely be a value equality I agree.
Deferred
Open for 3.0
Fixed in conjunction with bug 10668.

*** This bug has been marked as a duplicate of 10668 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35461" />
    <CreationDate amount="2003-03-21 08:30:00 -0500" />
    <DupId amount="" />
    <classification amount="Tools" />
    <Product amount="CDT" />
    <component amount="cdt-core" />
    <Version amount="1.2" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="blocker" />
    <Summery>Can't install latest CDT relase (1.0.1) on Linux GTK+</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="CLOSED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Downloaded binary distribution and it's ok using unzip -t. So changed to my
Eclipse install directory and unziped all the distro, the same way I did with
SolarEclipse, who also has bot "features" and "plugins" subdirectory on the ZIP
file. When I start eclipse it states it cannot install the new feature, saying 

Eclipse C/C++ Development Tools (Linux GTK+): Feature requires plug-in
"org.eclipse.cdt (1.0.1)".

The CDT pages at eclipse.org do not states I need anything besides the single
binary distro ZIP file and GNU development tools.

Using Eclipse 2.0.2 with lots of plugins (all working fine), Red Hat 8.0 (no
erratas) Mozilla 1.2.1 and Sun Java2 SDK 1.4.1_01
The new install updated from Doug S. should take care
of all this details.

Reassign to Doug(I tink it is safe to flip that one to Fix)

But I'll let you be the judge of that, you have a better understanding
of all the Eclipse features/update stuff.

Thanks


I have seen this in the past as well. However, with the move to the update 
site for 1.1 and 1.2, we have not seen this. If you see this again, please 
reopen the defect.
Doug,

We can close this bug.  Can you assign to me?

Thanks.
No response =&gt; closed.</WithStack>
    <WithOutStack>Downloaded binary distribution and it's ok using unzip -t. So changed to my
Eclipse install directory and unziped all the distro, the same way I did with
SolarEclipse, who also has bot "features" and "plugins" subdirectory on the ZIP
file. When I start eclipse it states it cannot install the new feature, saying 

Eclipse C/C++ Development Tools (Linux GTK+): Feature requires plug-in
"org.eclipse.cdt (1.0.1)".

The CDT pages at eclipse.org do not states I need anything besides the single
binary distro ZIP file and GNU development tools.

Using Eclipse 2.0.2 with lots of plugins (all working fine), Red Hat 8.0 (no
erratas) Mozilla 1.2.1 and Sun Java2 SDK 1.4.1_01
The new install updated from Doug S. should take care
of all this details.

Reassign to Doug(I tink it is safe to flip that one to Fix)

But I'll let you be the judge of that, you have a better understanding
of all the Eclipse features/update stuff.

Thanks


I have seen this in the past as well. However, with the move to the update 
site for 1.1 and 1.2, we have not seen this. If you see this again, please 
reopen the defect.
Doug,

We can close this bug.  Can you assign to me?

Thanks.
No response =&gt; closed.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35462" />
    <CreationDate amount="2003-03-21 08:46:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="Macintosh" />
    <op_sys amount="Mac OS X - Carbon (unsup.)" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[RC3a] Modifier for source hover cannot be changed</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Actuall, 2 related bugs:

In Preferences-&gt;Java-&gt;Editor-&gt;Hovers it should be possible to change keyboard 
modifiers for hovers. The source hover is mapped to CTRL by default, which is a bug in 
itself because it doesn't work on the Mac (CTRL is mapped to right mouse button on OS 
level).

When I changed it to COMMAND howver, it didn't really change. As in: in the preferences 
it says that COMMAND is the modifier, but in reality it's still CTRL.
This works without problems in the latest build, hovers as well as the browser 
like navigation can be configured.</WithStack>
    <WithOutStack>Actuall, 2 related bugs:

In Preferences-&gt;Java-&gt;Editor-&gt;Hovers it should be possible to change keyboard 
modifiers for hovers. The source hover is mapped to CTRL by default, which is a bug in 
itself because it doesn't work on the Mac (CTRL is mapped to right mouse button on OS 
level).

When I changed it to COMMAND howver, it didn't really change. As in: in the preferences 
it says that COMMAND is the modifier, but in reality it's still CTRL.
This works without problems in the latest build, hovers as well as the browser 
like navigation can be configured.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35463" />
    <CreationDate amount="2003-03-21 08:55:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="Macintosh" />
    <op_sys amount="Mac OS X - Carbon (unsup.)" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[Key Bindings] COMMAND-LEFT and COMMAND-RIGHT keys</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>The COMMAND-LEFT and COMMAND-RIGHT keys are not in the list of bindable keys. (preferences-&gt;workbench-&gt;keys).
any key that you can press in the key sequence entry widget (new in m3) is 
bindable. marking as fixed.</WithStack>
    <WithOutStack>The COMMAND-LEFT and COMMAND-RIGHT keys are not in the list of bindable keys. (preferences-&gt;workbench-&gt;keys).
any key that you can press in the key sequence entry widget (new in m3) is 
bindable. marking as fixed.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35464" />
    <CreationDate amount="2003-03-21 09:04:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[CVS Core] External deletions cause exceptions to be logged</Summery>
    <Patches amount="0" />
    <Stacktraces amount="3">
      <Stacktrace timestamp="1437340488187">
        <Exception>org.eclipse.core.internal.resources.ResourceException</Exception>
        <Reason>File not found: 
C:\eclipse\workspace\webstart\rubbish\CVS\Root.</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:398)</Frame>
          <Frame depth="1">org.eclipse.core.internal.resources.File.getContents(File.java:213)</Frame>
          <Frame depth="2">org.eclipse.core.internal.resources.File.getContents(File.java:203)</Frame>
          <Frame depth="3">org.eclipse.team.internal.ccvs.core.util.SyncFileWriter.readFirstLine(SyncFileWriter.java:392)</Frame>
          <Frame depth="4">org.eclipse.team.internal.ccvs.core.util.SyncFileWriter.readFolderSync(SyncFileWriter.java:165)</Frame>
          <Frame depth="5">org.eclipse.team.internal.ccvs.core.resources.EclipseSynchronizer.cacheFolderSync(EclipseSynchronizer.java:720)</Frame>
          <Frame depth="6">org.eclipse.team.internal.ccvs.core.resources.EclipseSynchronizer.getFolderSync(EclipseSynchronizer.java:145)</Frame>
          <Frame depth="7">org.eclipse.team.internal.ccvs.core.resources.EclipseFolder.isCVSFolder(EclipseFolder.java:226)</Frame>
          <Frame depth="8">org.eclipse.team.internal.ccvs.core.resources.EclipseFolder.isIgnored(EclipseFolder.java:268)</Frame>
          <Frame depth="9">org.eclipse.team.internal.ccvs.core.resources.EclipseFolder.members(EclipseFolder.java:70)</Frame>
          <Frame depth="10">org.eclipse.team.internal.ccvs.core.resources.RemoteFolderTreeBuilder.buildBaseTree(RemoteFolderTreeBuilder.java:334)</Frame>
          <Frame depth="11">org.eclipse.team.internal.ccvs.core.resources.RemoteFolderTreeBuilder.buildBaseTree(RemoteFolderTreeBuilder.java:139)</Frame>
          <Frame depth="12">org.eclipse.team.internal.ccvs.core.resources.CVSWorkspaceRoot.getRemoteSyncTree(CVSWorkspaceRoot.java:616)</Frame>
          <Frame depth="13">org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput.buildSyncTrees(CVSSyncCompareInput.java:218)</Frame>
          <Frame depth="14">org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput.createSyncElements(CVSSyncCompareInput.java:209)</Frame>
          <Frame depth="15">org.eclipse.team.internal.ui.sync.SyncCompareInput.prepareInput(SyncCompareInput.java:208)</Frame>
          <Frame depth="16">org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput.access$2(CVSSyncCompareInput.java:1)</Frame>
          <Frame depth="17">org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput$4.run(CVSSyncCompareInput.java:324)</Frame>
          <Frame depth="18">org.eclipse.team.internal.ccvs.ui.CVSUIPlugin.runWithRefresh(CVSUIPlugin.java:156)</Frame>
          <Frame depth="19">org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput$3.run(CVSSyncCompareInput.java:322)</Frame>
          <Frame depth="20">org.eclipse.team.internal.ccvs.core.client.Session.run(Session.java:167)</Frame>
          <Frame depth="21">org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput.prepareInput(CVSSyncCompareInput.java:319)</Frame>
          <Frame depth="22">org.eclipse.compare.CompareEditorInput.run(CompareEditorInput.java:307)</Frame>
          <Frame depth="23">org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:95)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488187">
        <Exception>com.sun.jdi.VMDisconnectedException</Exception>
        <Reason>Got IOException from Virtual Machine</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply(PacketReceiveManager.java:139)</Frame>
          <Frame depth="1">org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply(PacketReceiveManager.java:152)</Frame>
          <Frame depth="2">org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:167)</Frame>
          <Frame depth="3">org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:185)</Frame>
          <Frame depth="4">org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:215)</Frame>
          <Frame depth="5">org.eclipse.jdi.internal.ReferenceTypeImpl.modifiers(ReferenceTypeImpl.java:205)</Frame>
          <Frame depth="6">org.eclipse.jdi.internal.AccessibleImpl.isPublic(AccessibleImpl.java:73)</Frame>
          <Frame depth="7">org.eclipse.jdt.internal.debug.core.model.JDIThisVariable.isPublic(JDIThisVariable.java:127)</Frame>
          <Frame depth="8">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeBaseImageDescriptor(JDIModelPresentation.java:893)</Frame>
          <Frame depth="9">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:751)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:618)</Frame>
          <Frame depth="11">org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:61)</Frame>
          <Frame depth="12">org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:105)</Frame>
          <Frame depth="13">org.eclipse.debug.internal.ui.views.variables.VariablesView$VariablesViewLabelProvider.getImage(VariablesView.java:126)</Frame>
          <Frame depth="14">org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:96)</Frame>
          <Frame depth="15">org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:87)</Frame>
          <Frame depth="16">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="17">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="18">org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:406)</Frame>
          <Frame depth="19">org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:119)</Frame>
          <Frame depth="20">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="21">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="22">org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:1271)</Frame>
          <Frame depth="23">org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:320)</Frame>
          <Frame depth="24">org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:303)</Frame>
          <Frame depth="25">org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:65)</Frame>
          <Frame depth="26">org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:289)</Frame>
          <Frame depth="27">org.eclipse.jface.viewers.AbstractTreeViewer$5.run(AbstractTreeViewer.java:729)</Frame>
          <Frame depth="28">org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:801)</Frame>
          <Frame depth="29">org.eclipse.jface.viewers.AbstractTreeViewer.inputChanged(AbstractTreeViewer.java:721)</Frame>
          <Frame depth="30">org.eclipse.jface.viewers.ContentViewer.setInput(ContentViewer.java:232)</Frame>
          <Frame depth="31">org.eclipse.jface.viewers.StructuredViewer.setInput(StructuredViewer.java:991)</Frame>
          <Frame depth="32">org.eclipse.debug.internal.ui.views.variables.VariablesView.setViewerInput(VariablesView.java:358)</Frame>
          <Frame depth="33">org.eclipse.debug.internal.ui.views.variables.VariablesView.selectionChanged(VariablesView.java:1090)</Frame>
          <Frame depth="34">org.eclipse.ui.internal.AbstractPartSelectionTracker$1.run(AbstractPartSelectionTracker.java:105)</Frame>
          <Frame depth="35">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="36">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="37">org.eclipse.ui.internal.AbstractPartSelectionTracker.fireSelection(AbstractPartSelectionTracker.java:103)</Frame>
          <Frame depth="38">org.eclipse.ui.internal.PagePartSelectionTracker$1.selectionChanged(PagePartSelectionTracker.java:32)</Frame>
          <Frame depth="39">org.eclipse.jface.viewers.Viewer$2.run(Viewer.java:153)</Frame>
          <Frame depth="40">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="41">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="42">org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:151)</Frame>
          <Frame depth="43">org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:1290)</Frame>
          <Frame depth="44">org.eclipse.jface.viewers.StructuredViewer.setSelection(StructuredViewer.java:1020)</Frame>
          <Frame depth="45">org.eclipse.debug.internal.ui.views.launch.LaunchView.autoExpand(LaunchView.java:962)</Frame>
          <Frame depth="46">org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleSuspendThreadEvent(LaunchViewEventHandler.java:229)</Frame>
          <Frame depth="47">org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleSuspendEvent(LaunchViewEventHandler.java:175)</Frame>
          <Frame depth="48">org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleDebugEvents(LaunchViewEventHandler.java:96)</Frame>
          <Frame depth="49">org.eclipse.debug.internal.ui.views.AbstractDebugEventHandler$1.run(AbstractDebugEventHandler.java:66)</Frame>
          <Frame depth="50">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:31)</Frame>
          <Frame depth="51">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:94)</Frame>
          <Frame depth="52">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1754)</Frame>
          <Frame depth="53">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1489)</Frame>
          <Frame depth="54">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1400)</Frame>
          <Frame depth="55">org.eclipse.ui.internal.Workbench.run(Workbench.java:1383)</Frame>
          <Frame depth="56">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="57">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="58">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="59">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="60">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="61">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="62">org.eclipse.core.launcher.Main.basicRun(Main.java:247)</Frame>
          <Frame depth="63">org.eclipse.core.launcher.Main.run(Main.java:703)</Frame>
          <Frame depth="64">org.eclipse.core.launcher.Main.main(Main.java:539)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488187">
        <Exception>com.sun.jdi.VMDisconnectedException</Exception>
        <Reason>Got IOException from Virtual Machine</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply(PacketReceiveManager.java:139)</Frame>
          <Frame depth="1">org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply(PacketReceiveManager.java:152)</Frame>
          <Frame depth="2">org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:167)</Frame>
          <Frame depth="3">org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:185)</Frame>
          <Frame depth="4">org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:215)</Frame>
          <Frame depth="5">org.eclipse.jdi.internal.ReferenceTypeImpl.modifiers(ReferenceTypeImpl.java:205)</Frame>
          <Frame depth="6">org.eclipse.jdi.internal.AccessibleImpl.isPublic(AccessibleImpl.java:73)</Frame>
          <Frame depth="7">org.eclipse.jdt.internal.debug.core.model.JDIThisVariable.isPublic(JDIThisVariable.java:127)</Frame>
          <Frame depth="8">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeBaseImageDescriptor(JDIModelPresentation.java:893)</Frame>
          <Frame depth="9">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:751)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:618)</Frame>
          <Frame depth="11">org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:61)</Frame>
          <Frame depth="12">org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:105)</Frame>
          <Frame depth="13">org.eclipse.debug.internal.ui.views.variables.VariablesView$VariablesViewLabelProvider.getImage(VariablesView.java:126)</Frame>
          <Frame depth="14">org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:96)</Frame>
          <Frame depth="15">org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:87)</Frame>
          <Frame depth="16">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="17">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="18">org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:406)</Frame>
          <Frame depth="19">org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:119)</Frame>
          <Frame depth="20">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="21">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="22">org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:1271)</Frame>
          <Frame depth="23">org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:320)</Frame>
          <Frame depth="24">org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:303)</Frame>
          <Frame depth="25">org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:65)</Frame>
          <Frame depth="26">org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:289)</Frame>
          <Frame depth="27">org.eclipse.jface.viewers.AbstractTreeViewer$5.run(AbstractTreeViewer.java:729)</Frame>
          <Frame depth="28">org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:801)</Frame>
          <Frame depth="29">org.eclipse.jface.viewers.AbstractTreeViewer.inputChanged(AbstractTreeViewer.java:721)</Frame>
          <Frame depth="30">org.eclipse.jface.viewers.ContentViewer.setInput(ContentViewer.java:232)</Frame>
          <Frame depth="31">org.eclipse.jface.viewers.StructuredViewer.setInput(StructuredViewer.java:991)</Frame>
          <Frame depth="32">org.eclipse.debug.internal.ui.views.variables.VariablesView.setViewerInput(VariablesView.java:358)</Frame>
          <Frame depth="33">org.eclipse.debug.internal.ui.views.variables.VariablesView.selectionChanged(VariablesView.java:1090)</Frame>
          <Frame depth="34">org.eclipse.ui.internal.AbstractPartSelectionTracker$1.run(AbstractPartSelectionTracker.java:105)</Frame>
          <Frame depth="35">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="36">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="37">org.eclipse.ui.internal.AbstractPartSelectionTracker.fireSelection(AbstractPartSelectionTracker.java:103)</Frame>
          <Frame depth="38">org.eclipse.ui.internal.PagePartSelectionTracker$1.selectionChanged(PagePartSelectionTracker.java:32)</Frame>
          <Frame depth="39">org.eclipse.jface.viewers.Viewer$2.run(Viewer.java:153)</Frame>
          <Frame depth="40">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="41">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="42">org.eclipse.jface.viewers.Viewer.fireSelectionChanged(Viewer.java:151)</Frame>
          <Frame depth="43">org.eclipse.jface.viewers.StructuredViewer.updateSelection(StructuredViewer.java:1290)</Frame>
          <Frame depth="44">org.eclipse.jface.viewers.StructuredViewer.setSelection(StructuredViewer.java:1020)</Frame>
          <Frame depth="45">org.eclipse.debug.internal.ui.views.launch.LaunchView.autoExpand(LaunchView.java:962)</Frame>
          <Frame depth="46">org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleSuspendThreadEvent(LaunchViewEventHandler.java:229)</Frame>
          <Frame depth="47">org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleSuspendEvent(LaunchViewEventHandler.java:175)</Frame>
          <Frame depth="48">org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleDebugEvents(LaunchViewEventHandler.java:96)</Frame>
          <Frame depth="49">org.eclipse.debug.internal.ui.views.AbstractDebugEventHandler$1.run(AbstractDebugEventHandler.java:66)</Frame>
          <Frame depth="50">org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:31)</Frame>
          <Frame depth="51">org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:94)</Frame>
          <Frame depth="52">org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1754)</Frame>
          <Frame depth="53">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1489)</Frame>
          <Frame depth="54">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1400)</Frame>
          <Frame depth="55">org.eclipse.ui.internal.Workbench.run(Workbench.java:1383)</Frame>
          <Frame depth="56">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="57">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="58">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="59">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="60">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="61">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="62">org.eclipse.core.launcher.Main.basicRun(Main.java:247)</Frame>
          <Frame depth="63">org.eclipse.core.launcher.Main.run(Main.java:703)</Frame>
          <Frame depth="64">org.eclipse.core.launcher.Main.main(Main.java:539)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>I was creating and deleting some directories for testing purposes, and when I 
got back into Eclipse CVS was a bit confused about which directories existed or 
not.

Normally I wouldn't have reported this bug, since my description is pretty 
useless, but then I found the exceptions below.


!SESSION mar 20, 2003 16:44:55.167 ---------------------------------------------
java.version=1.4.1_01
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=no_NO
Command-line arguments: -os win32 -ws win32 -arch x86 -install file:C:/eclipse/
!ENTRY org.eclipse.team.cvs.core 4 271 mar 20, 2003 16:44:55.167
!MESSAGE File not found: C:\eclipse\workspace\webstart\rubbish\CVS\Root.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: File not found: 
C:\eclipse\workspace\webstart\rubbish\CVS\Root.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read
(FileSystemResourceManager.java:398)
	at org.eclipse.core.internal.resources.File.getContents(File.java:213)
	at org.eclipse.core.internal.resources.File.getContents(File.java:203)
	at org.eclipse.team.internal.ccvs.core.util.SyncFileWriter.readFirstLine
(SyncFileWriter.java:392)
	at 
org.eclipse.team.internal.ccvs.core.util.SyncFileWriter.readFolderSync
(SyncFileWriter.java:165)
	at 
org.eclipse.team.internal.ccvs.core.resources.EclipseSynchronizer.cacheFolderSyn
c(EclipseSynchronizer.java:720)
	at 
org.eclipse.team.internal.ccvs.core.resources.EclipseSynchronizer.getFolderSync
(EclipseSynchronizer.java:145)
	at 
org.eclipse.team.internal.ccvs.core.resources.EclipseFolder.isCVSFolder
(EclipseFolder.java:226)
	at org.eclipse.team.internal.ccvs.core.resources.EclipseFolder.isIgnored
(EclipseFolder.java:268)
	at org.eclipse.team.internal.ccvs.core.resources.EclipseFolder.members
(EclipseFolder.java:70)
	at 
org.eclipse.team.internal.ccvs.core.resources.RemoteFolderTreeBuilder.buildBaseT
ree(RemoteFolderTreeBuilder.java:334)
	at 
org.eclipse.team.internal.ccvs.core.resources.RemoteFolderTreeBuilder.buildBaseT
ree(RemoteFolderTreeBuilder.java:139)
	at 
org.eclipse.team.internal.ccvs.core.resources.CVSWorkspaceRoot.getRemoteSyncTree
(CVSWorkspaceRoot.java:616)
	at 
org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput.buildSyncTrees
(CVSSyncCompareInput.java:218)
	at 
org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput.createSyncElements
(CVSSyncCompareInput.java:209)
	at org.eclipse.team.internal.ui.sync.SyncCompareInput.prepareInput
(SyncCompareInput.java:208)
	at org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput.access$2
(CVSSyncCompareInput.java:1)
	at org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput$4.run
(CVSSyncCompareInput.java:324)
	at org.eclipse.team.internal.ccvs.ui.CVSUIPlugin.runWithRefresh
(CVSUIPlugin.java:156)
	at org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput$3.run
(CVSSyncCompareInput.java:322)
	at org.eclipse.team.internal.ccvs.core.client.Session.run
(Session.java:167)
	at 
org.eclipse.team.internal.ccvs.ui.sync.CVSSyncCompareInput.prepareInput
(CVSSyncCompareInput.java:319)
	at org.eclipse.compare.CompareEditorInput.run
(CompareEditorInput.java:307)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:95)
!ENTRY org.eclipse.core.resources 4 271 mar 20, 2003 16:44:55.167
!MESSAGE File not found: C:\eclipse\workspace\webstart\rubbish\CVS\Root.
!SESSION mar 20, 2003 16:52:45.137 ---------------------------------------------
java.version=1.4.1_01
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=no_NO
Command-line arguments: -os win32 -ws win32 -arch x86 -install file:C:/eclipse/
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 20, 2003 16:52:45.137
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
!SESSION mar 21, 2003 09:04:00.264 ---------------------------------------------
java.version=1.4.1_01
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=no_NO
Command-line arguments: -os win32 -ws win32 -arch x86 -install file:C:/eclipse/
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 21, 2003 09:04:00.264
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 21, 2003 09:46:32.143
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 21, 2003 12:05:06.812
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
!ENTRY org.eclipse.jdt.debug.ui 4 150 mar 21, 2003 12:27:58.550
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException[5010]: 
com.sun.jdi.VMDisconnectedException: Got IOException from Virtual Machine
	at org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply
(PacketReceiveManager.java:139)
	at org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply
(PacketReceiveManager.java:152)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:167)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:185)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:215)
	at org.eclipse.jdi.internal.ReferenceTypeImpl.modifiers
(ReferenceTypeImpl.java:205)
	at org.eclipse.jdi.internal.AccessibleImpl.isPublic
(AccessibleImpl.java:73)
	at org.eclipse.jdt.internal.debug.core.model.JDIThisVariable.isPublic
(JDIThisVariable.java:127)
	at 
org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeBaseImageDescripto
r(JDIModelPresentation.java:893)
	at 
org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage
(JDIModelPresentation.java:751)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage
(JDIModelPresentation.java:618)
	at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage
(LazyModelPresentation.java:61)
	at org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage
(DelegatingModelPresentation.java:105)
	at 
org.eclipse.debug.internal.ui.views.variables.VariablesView$VariablesViewLabelPr
ovider.getImage(VariablesView.java:126)
	at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:96)
	at 
org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run
(AbstractTreeViewer.java:87)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem
(AbstractTreeViewer.java:406)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run
(StructuredViewer.java:119)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem
(StructuredViewer.java:1271)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem
(AbstractTreeViewer.java:320)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run
(AbstractTreeViewer.java:303)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:65)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren
(AbstractTreeViewer.java:289)
	at org.eclipse.jface.viewers.AbstractTreeViewer$5.run
(AbstractTreeViewer.java:729)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection
(StructuredViewer.java:801)
	at org.eclipse.jface.viewers.AbstractTreeViewer.inputChanged
(AbstractTreeViewer.java:721)
	at org.eclipse.jface.viewers.ContentViewer.setInput
(ContentViewer.java:232)
	at org.eclipse.jface.viewers.StructuredViewer.setInput
(StructuredViewer.java:991)
	at 
org.eclipse.debug.internal.ui.views.variables.VariablesView.setViewerInput
(VariablesView.java:358)
	at 
org.eclipse.debug.internal.ui.views.variables.VariablesView.selectionChanged
(VariablesView.java:1090)
	at org.eclipse.ui.internal.AbstractPartSelectionTracker$1.run
(AbstractPartSelectionTracker.java:105)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.ui.internal.AbstractPartSelectionTracker.fireSelection
(AbstractPartSelectionTracker.java:103)
	at org.eclipse.ui.internal.PagePartSelectionTracker$1.selectionChanged
(PagePartSelectionTracker.java:32)
	at org.eclipse.jface.viewers.Viewer$2.run(Viewer.java:153)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged
(Viewer.java:151)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection
(StructuredViewer.java:1290)
	at org.eclipse.jface.viewers.StructuredViewer.setSelection
(StructuredViewer.java:1020)
	at org.eclipse.debug.internal.ui.views.launch.LaunchView.autoExpand
(LaunchView.java:962)
	at 
org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleSuspen
dThreadEvent(LaunchViewEventHandler.java:229)
	at 
org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleSuspen
dEvent(LaunchViewEventHandler.java:175)
	at 
org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleDebugE
vents(LaunchViewEventHandler.java:96)
	at org.eclipse.debug.internal.ui.views.AbstractDebugEventHandler$1.run
(AbstractDebugEventHandler.java:66)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:31)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:94)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1754)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1489)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1400)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:1383)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:247)
	at org.eclipse.core.launcher.Main.run(Main.java:703)
	at org.eclipse.core.launcher.Main.main(Main.java:539)
!ENTRY org.eclipse.jdt.debug 4 5010 mar 21, 2003 12:27:58.560
!MESSAGE Exception occurred while retrieving modifiers.
!STACK 0
com.sun.jdi.VMDisconnectedException: Got IOException from Virtual Machine
	at org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply
(PacketReceiveManager.java:139)
	at org.eclipse.jdi.internal.connect.PacketReceiveManager.getReply
(PacketReceiveManager.java:152)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:167)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:185)
	at org.eclipse.jdi.internal.MirrorImpl.requestVM(MirrorImpl.java:215)
	at org.eclipse.jdi.internal.ReferenceTypeImpl.modifiers
(ReferenceTypeImpl.java:205)
	at org.eclipse.jdi.internal.AccessibleImpl.isPublic
(AccessibleImpl.java:73)
	at org.eclipse.jdt.internal.debug.core.model.JDIThisVariable.isPublic
(JDIThisVariable.java:127)
	at 
org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeBaseImageDescripto
r(JDIModelPresentation.java:893)
	at 
org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage
(JDIModelPresentation.java:751)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage
(JDIModelPresentation.java:618)
	at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage
(LazyModelPresentation.java:61)
	at org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage
(DelegatingModelPresentation.java:105)
	at 
org.eclipse.debug.internal.ui.views.variables.VariablesView$VariablesViewLabelPr
ovider.getImage(VariablesView.java:126)
	at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:96)
	at 
org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run
(AbstractTreeViewer.java:87)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem
(AbstractTreeViewer.java:406)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run
(StructuredViewer.java:119)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem
(StructuredViewer.java:1271)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem
(AbstractTreeViewer.java:320)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run
(AbstractTreeViewer.java:303)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:65)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren
(AbstractTreeViewer.java:289)
	at org.eclipse.jface.viewers.AbstractTreeViewer$5.run
(AbstractTreeViewer.java:729)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection
(StructuredViewer.java:801)
	at org.eclipse.jface.viewers.AbstractTreeViewer.inputChanged
(AbstractTreeViewer.java:721)
	at org.eclipse.jface.viewers.ContentViewer.setInput
(ContentViewer.java:232)
	at org.eclipse.jface.viewers.StructuredViewer.setInput
(StructuredViewer.java:991)
	at 
org.eclipse.debug.internal.ui.views.variables.VariablesView.setViewerInput
(VariablesView.java:358)
	at 
org.eclipse.debug.internal.ui.views.variables.VariablesView.selectionChanged
(VariablesView.java:1090)
	at org.eclipse.ui.internal.AbstractPartSelectionTracker$1.run
(AbstractPartSelectionTracker.java:105)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.ui.internal.AbstractPartSelectionTracker.fireSelection
(AbstractPartSelectionTracker.java:103)
	at org.eclipse.ui.internal.PagePartSelectionTracker$1.selectionChanged
(PagePartSelectionTracker.java:32)
	at org.eclipse.jface.viewers.Viewer$2.run(Viewer.java:153)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.jface.viewers.Viewer.fireSelectionChanged
(Viewer.java:151)
	at org.eclipse.jface.viewers.StructuredViewer.updateSelection
(StructuredViewer.java:1290)
	at org.eclipse.jface.viewers.StructuredViewer.setSelection
(StructuredViewer.java:1020)
	at org.eclipse.debug.internal.ui.views.launch.LaunchView.autoExpand
(LaunchView.java:962)
	at 
org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleSuspen
dThreadEvent(LaunchViewEventHandler.java:229)
	at 
org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleSuspen
dEvent(LaunchViewEventHandler.java:175)
	at 
org.eclipse.debug.internal.ui.views.launch.LaunchViewEventHandler.doHandleDebugE
vents(LaunchViewEventHandler.java:96)
	at org.eclipse.debug.internal.ui.views.AbstractDebugEventHandler$1.run
(AbstractDebugEventHandler.java:66)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:31)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:94)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:1754)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1489)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1400)
	at org.eclipse.ui.internal.Workbench.run(Workbench.java:1383)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:247)
	at org.eclipse.core.launcher.Main.run(Main.java:703)
	at org.eclipse.core.launcher.Main.main(Main.java:539)
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 21, 2003 13:03:41.877
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
Changed title from "CVS can get confused when files a directory is deleted from 
the local storage outside Eclipse".

Better error recovery in this situation should be investigated. At least the 
user should be lead to perform a refresh.
This bug has not been touched for 2 years. Closing as WONTFIX. Please reopen if 
you feel this is still an important issue.</WithStack>
    <WithOutStack>I was creating and deleting some directories for testing purposes, and when I 
got back into Eclipse CVS was a bit confused about which directories existed or 
not.

Normally I wouldn't have reported this bug, since my description is pretty 
useless, but then I found the exceptions below.


!SESSION mar 20, 2003 16:44:55.167 ---------------------------------------------
java.version=1.4.1_01
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=no_NO
Command-line arguments: -os win32 -ws win32 -arch x86 -install file:C:/eclipse/
!ENTRY org.eclipse.team.cvs.core 4 271 mar 20, 2003 16:44:55.167
!MESSAGE File not found: C:\eclipse\workspace\webstart\rubbish\CVS\Root.
!STACK 1
!ENTRY org.eclipse.core.resources 4 271 mar 20, 2003 16:44:55.167
!MESSAGE File not found: C:\eclipse\workspace\webstart\rubbish\CVS\Root.
!SESSION mar 20, 2003 16:52:45.137 ---------------------------------------------
java.version=1.4.1_01
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=no_NO
Command-line arguments: -os win32 -ws win32 -arch x86 -install file:C:/eclipse/
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 20, 2003 16:52:45.137
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
!SESSION mar 21, 2003 09:04:00.264 ---------------------------------------------
java.version=1.4.1_01
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=no_NO
Command-line arguments: -os win32 -ws win32 -arch x86 -install file:C:/eclipse/
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 21, 2003 09:04:00.264
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 21, 2003 09:46:32.143
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
!ENTRY org.eclipse.team.cvs.core 4 -6 mar 21, 2003 12:05:06.812
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
!ENTRY org.eclipse.jdt.debug.ui 4 150 mar 21, 2003 12:27:58.550
!MESSAGE Internal Error
!STACK 1
org.eclipse.debug.core.DebugException[5010]: 
!ENTRY org.eclipse.jdt.debug 4 5010 mar 21, 2003 12:27:58.560
!MESSAGE Exception occurred while retrieving modifiers.
!STACK 0

!ENTRY org.eclipse.team.cvs.core 4 -6 mar 21, 2003 13:03:41.877
!MESSAGE Invalid attempt to modify the sync info for 
resource '/webstart/rubbish'
Changed title from "CVS can get confused when files a directory is deleted from 
the local storage outside Eclipse".

Better error recovery in this situation should be investigated. At least the 
user should be lead to perform a refresh.
This bug has not been touched for 2 years. Closing as WONTFIX. Please reopen if 
you feel this is still an important issue.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35465" />
    <CreationDate amount="2003-03-21 09:08:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Refresh does not take into account changes in classpath</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="3">
      <Enumeration lines="10">
        <Lines>
          <Line>- Create a project</Line>
          <Line>- Add a reference to a .jar in the classpath</Line>
          <Line>- Delete the .jar</Line>
          <Line>- Try to compile -&gt; get error</Line>
          <Line>- Restore the .jar</Line>
          <Line>- Select project-&gt;Refresh</Line>
          <Line>- Nothing happens</Line>
          <Line>- Rebuild project works</Line>
          <Line>Neither the workspace nor the Navigator know anything about the classpath.</Line>
          <Line>Refresh on a project in the Java views could handle this case.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="5">
        <Lines>
          <Line>- I'm using a library jannealer.jar that I compile my project with</Line>
          <Line>- A new version was released. This version is API incompatible</Line>
          <Line>- I copied jannealer.jar on top of the old jannealer.jar</Line>
          <Line>- I did a refresh on the project</Line>
          <Line>- Nothing happened</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="2">
        <Lines>
          <Line>- I did a rebuild</Line>
          <Line>- I got the expected errors due to the API changes</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>- Create a project
- Add a reference to a .jar in the classpath
- Delete the .jar
- Try to compile -&gt; get error
- Restore the .jar
- Select project-&gt;Refresh
- Nothing happens
- Rebuild project works
Neither the workspace nor the Navigator know anything about the classpath.
Refresh on a project in the Java views could handle this case.

yvind, what exactly do you expect refresh to do ? 
&gt;yvind, what exactly do you expect refresh to do ? 

If files have changed on disk, I expect Eclipse to recompile those parts that 
need to be recompiled.

i.e. if I have a script that builds a .jar in the classpath of the project, I 
expect Eclipse to recompile once the .jar "comes into existence". (After a 
Refresh).

This happens for .java files. Why shouldn't it happen for .jars in the 
classpath?

Note that I did set the priority of this report as low as it goes.

yvind


yvind

Moving to JDT/Core for comments. Current we only consider external archives in 
the refresh action. 
Kent - aren't we getting a delta for this scenario ?
I cannot reproduce this case on build RC3a.

yvind, which build are you running?
&gt;I cannot reproduce this case on build RC3a.
&gt;
&gt;yvind, which build are you running?

RC2.

I was going to download RC3a, but it has a big red x in the status column for 
Windows.

yvind

yvind, can you reproduce this on R2.1?
&gt;yvind, can you reproduce this on R2.1?

Same problem in R2.1.

yvind

Still cannot reproduce.

How are you deleting the jar file? Do you delete it from inside Eclipse or just 
from disk?

Is the jar file still visible in the Eclipse UI, even though it no longer 
exists on disk?

Is auto-build enabled?
I tried the same today and it now works...

Either I was confused when I tested today(likely) or something much stranger is 
afoot.

Sorry.

yvind

Something stranger....

Here is something that I did try today that didn't work as expected:

- I'm using a library jannealer.jar that I compile my project with
- A new version was released. This version is API incompatible
- I copied jannealer.jar on top of the old jannealer.jar
- I did a refresh on the project
- Nothing happened

- I did a rebuild
- I got the expected errors due to the API changes


Strange.

I don't understand how Refresh decides that a rebuild is in order.

I would have expected it to rebuild if any of the jars changed (date older or 
newer, md5, whatever), came or went.

yvind



Was the jar file external to your workspace?

I was only able to reproduce when the jar was external (if its internal, then a 
rebuild happens on refresh).

The builder is never called when the project is refreshed to 'notice' an 
externel jar change.
Indeed, external JARs aren't managed by Eclipse as part of the automatic build 
if resource have changed story.

&gt;Indeed, external JARs aren't managed by Eclipse as part of the 
&gt;automatic build if resource have changed story.

The jar was indeed external.

It seems to me that Eclipse should pick this up on a manual refresh.

yvind

Did you perform the refresh in the navigator or in the package view ? 
(in the package view, it should cause the refresh behavior you are expecting).

The navigator is not as evolved (yet)
&gt;Did you perform the refresh in the navigator or in the package view ? 
&gt;(in the package view, it should cause the refresh behavior you are expecting).

Its been a while since I looked at this now.

But it was from the Package view in the Java Perspective.

&gt;The navigator is not as evolved (yet)

I wasn't using the navigator.

I assume by navigator you mean the navigator view in the resource perspective.

yvind

Yes, I meant the navigator view. This means we still have an issue.
Should consider deleting the build states for all projects referencing an 
external jar file when we notice it has changed in 
DeltaProcessor.checkExternalArchiveChanges(). This is called when the JavaModel 
is told to refresh.

But one could also argue that if the JavaModel only looks for external jar 
files changes because the user did a refresh, then why not also leave it up to 
the user to do a rebuild all.
Deferred
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>- Create a project
- Add a reference to a .jar in the classpath
- Delete the .jar
- Try to compile -&gt; get error
- Restore the .jar
- Select project-&gt;Refresh
- Nothing happens
- Rebuild project works
Neither the workspace nor the Navigator know anything about the classpath.
Refresh on a project in the Java views could handle this case.

yvind, what exactly do you expect refresh to do ? 
&gt;yvind, what exactly do you expect refresh to do ? 

If files have changed on disk, I expect Eclipse to recompile those parts that 
need to be recompiled.

i.e. if I have a script that builds a .jar in the classpath of the project, I 
expect Eclipse to recompile once the .jar "comes into existence". (After a 
Refresh).

This happens for .java files. Why shouldn't it happen for .jars in the 
classpath?

Note that I did set the priority of this report as low as it goes.

yvind


yvind

Moving to JDT/Core for comments. Current we only consider external archives in 
the refresh action. 
Kent - aren't we getting a delta for this scenario ?
I cannot reproduce this case on build RC3a.

yvind, which build are you running?
&gt;I cannot reproduce this case on build RC3a.
&gt;
&gt;yvind, which build are you running?

RC2.

I was going to download RC3a, but it has a big red x in the status column for 
Windows.

yvind

yvind, can you reproduce this on R2.1?
&gt;yvind, can you reproduce this on R2.1?

Same problem in R2.1.

yvind

Still cannot reproduce.

How are you deleting the jar file? Do you delete it from inside Eclipse or just 
from disk?

Is the jar file still visible in the Eclipse UI, even though it no longer 
exists on disk?

Is auto-build enabled?
I tried the same today and it now works...

Either I was confused when I tested today(likely) or something much stranger is 
afoot.

Sorry.

yvind

Something stranger....

Here is something that I did try today that didn't work as expected:

- I'm using a library jannealer.jar that I compile my project with
- A new version was released. This version is API incompatible
- I copied jannealer.jar on top of the old jannealer.jar
- I did a refresh on the project
- Nothing happened

- I did a rebuild
- I got the expected errors due to the API changes


Strange.

I don't understand how Refresh decides that a rebuild is in order.

I would have expected it to rebuild if any of the jars changed (date older or 
newer, md5, whatever), came or went.

yvind



Was the jar file external to your workspace?

I was only able to reproduce when the jar was external (if its internal, then a 
rebuild happens on refresh).

The builder is never called when the project is refreshed to 'notice' an 
externel jar change.
Indeed, external JARs aren't managed by Eclipse as part of the automatic build 
if resource have changed story.

&gt;Indeed, external JARs aren't managed by Eclipse as part of the 
&gt;automatic build if resource have changed story.

The jar was indeed external.

It seems to me that Eclipse should pick this up on a manual refresh.

yvind

Did you perform the refresh in the navigator or in the package view ? 
(in the package view, it should cause the refresh behavior you are expecting).

The navigator is not as evolved (yet)
&gt;Did you perform the refresh in the navigator or in the package view ? 
&gt;(in the package view, it should cause the refresh behavior you are expecting).

Its been a while since I looked at this now.

But it was from the Package view in the Java Perspective.

&gt;The navigator is not as evolved (yet)

I wasn't using the navigator.

I assume by navigator you mean the navigator view in the resource perspective.

yvind

Yes, I meant the navigator view. This means we still have an issue.
Should consider deleting the build states for all projects referencing an 
external jar file when we notice it has changed in 
DeltaProcessor.checkExternalArchiveChanges(). This is called when the JavaModel 
is told to refresh.

But one could also argue that if the JavaModel only looks for external jar 
files changes because the user did a refresh, then why not also leave it up to 
the user to do a rebuild all.
Deferred
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35466" />
    <CreationDate amount="2003-03-21 09:12:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>References to external resources can't be found when self hosting</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="12">
        <Lines>
          <Line>1. The Plugin development environment allows file system links (new Folder :</Line>
          <Line>Link to folder in the file system) or external Jars (Java Build Path :</Line>
          <Line>Libraries : Add External Jar) to be included in a project making it seem that</Line>
          <Line>this is a perfectly valid thing to do.  The plugin containing the references</Line>
          <Line>compiles without error.</Line>
          <Line />
          <Line>2. Once referenced, the development environment allows external resources to</Line>
          <Line>be exported (Java Build Path : Order and Export) just as local resources would</Line>
          <Line>be.  Applications or other plugins which depend on the plugin containing the</Line>
          <Line>external references compile without error.  It is also possible to specify</Line>
          <Line>these resources (linked folder or external jar) in plugin.xml &lt;library&gt;</Line>
          <Line>elements as if they were local resources.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>The runtime workbench issues java.lang.NoClassDefFoundError exceptions for a 
plugin's external resource references during self-hosting.

While this isn't entirely unexpected (it is a reasonably well-known 
requirement that plugin resources be local when deployed), it is at best 
confusing due to the fact that the plugin development environment appears to 
sanction the use of external resources.  In particular:

1. The Plugin development environment allows file system links (new Folder : 
Link to folder in the file system) or external Jars (Java Build Path : 
Libraries : Add External Jar) to be included in a project making it seem that 
this is a perfectly valid thing to do.  The plugin containing the references 
compiles without error.

2. Once referenced, the development environment allows external resources to 
be exported (Java Build Path : Order and Export) just as local resources would 
be.  Applications or other plugins which depend on the plugin containing the 
external references compile without error.  It is also possible to specify 
these resources (linked folder or external jar) in plugin.xml &lt;library&gt; 
elements as if they were local resources.

Reasons why I consider this feature to be desirable:

I have several third-party tools I commonly package as plugins. These tools 
are frequently updated via CVS, and built outside the Eclipse environment 
using their own unique build scripts. It would be nice to have my plugin  
maintain links to the tool directories so that I can incorporate the most 
recent jars without having to make local copies that require version tracking 
and frequent updating.  Allowing self-hosting to support external references 
to these resources in the runtime workbench insures that I always use the most 
recent versions of these tools with no additional overhead.  Given this 
capability, it would also be nice to give developers the opportunity to take 
a "snapshot" of the plugin at deployment time, effectively copying all remote 
references as local resources.

If, for some reason, remote resource resolution during self-host is 
technically problematic, clear indications should be given to the developer 
that use of external resources is prohibited in plugins.  This could be 
accomplished by warning against or preventing the inclusion and/or export of 
remote resources during plugin development.

Newsgroup thread with additional detail (eclipse.tools):
[PLUGIN] Include linked resource in runtime library?

Possible related bugs:

http://dev.eclipse.org/bugs/show_bug.cgi?id=21728
http://dev.eclipse.org/bugs/show_bug.cgi?id=30032
Created attachment 4280
Plugin perspective supports adding links to projects

The attachment shows a plugin perspective with linked external resources (in
this case the link is to the file system)
Created attachment 4281
Plugin perspective supports exporting linked libraries

The attachment illustrates that the development environment appears to support
exporting of linked resources to other plugins and applications.
On re-reading my report, I realize there may be some confusion about the 
section "Reasons why I consider this feature to be desirable".  In case there 
is any confusion I'm suggesting that PDE ought to support references to remote 
resources via the runtime workbench when self-hosting.
Could you please move to PDE-UI
This is not doable because when you launch the runtime workbench, it is not 
PDE but the runtime that looks for these resources on disk.  The runtime has 
no concept of linked resources.  So if the content of a plug-in are coming 
from all over the place, it will not be able to locate them.

PDE can't warn about not using linked resources, because self-hosting using 
links works as long as it's within limits.  For instance, if you import a plug-
in with linking, all the resources are coming from the same place and relative 
to the plugin.xml.  When PDE passes the URL of this plug-in to the runtime 
workbench, it passes the actual location of the plugin.xml on disk, so the 
runtime can find all that it needs since the plug-in is encapsulated in one 
place on disk.</WithStack>
    <WithOutStack>The runtime workbench issues java.lang.NoClassDefFoundError exceptions for a 
plugin's external resource references during self-hosting.

While this isn't entirely unexpected (it is a reasonably well-known 
requirement that plugin resources be local when deployed), it is at best 
confusing due to the fact that the plugin development environment appears to 
sanction the use of external resources.  In particular:

1. The Plugin development environment allows file system links (new Folder : 
Link to folder in the file system) or external Jars (Java Build Path : 
Libraries : Add External Jar) to be included in a project making it seem that 
this is a perfectly valid thing to do.  The plugin containing the references 
compiles without error.

2. Once referenced, the development environment allows external resources to 
be exported (Java Build Path : Order and Export) just as local resources would 
be.  Applications or other plugins which depend on the plugin containing the 
external references compile without error.  It is also possible to specify 
these resources (linked folder or external jar) in plugin.xml &lt;library&gt; 
elements as if they were local resources.

Reasons why I consider this feature to be desirable:

I have several third-party tools I commonly package as plugins. These tools 
are frequently updated via CVS, and built outside the Eclipse environment 
using their own unique build scripts. It would be nice to have my plugin  
maintain links to the tool directories so that I can incorporate the most 
recent jars without having to make local copies that require version tracking 
and frequent updating.  Allowing self-hosting to support external references 
to these resources in the runtime workbench insures that I always use the most 
recent versions of these tools with no additional overhead.  Given this 
capability, it would also be nice to give developers the opportunity to take 
a "snapshot" of the plugin at deployment time, effectively copying all remote 
references as local resources.

If, for some reason, remote resource resolution during self-host is 
technically problematic, clear indications should be given to the developer 
that use of external resources is prohibited in plugins.  This could be 
accomplished by warning against or preventing the inclusion and/or export of 
remote resources during plugin development.

Newsgroup thread with additional detail (eclipse.tools):
[PLUGIN] Include linked resource in runtime library?

Possible related bugs:

http://dev.eclipse.org/bugs/show_bug.cgi?id=21728
http://dev.eclipse.org/bugs/show_bug.cgi?id=30032
Created attachment 4280
Plugin perspective supports adding links to projects

The attachment shows a plugin perspective with linked external resources (in
this case the link is to the file system)
Created attachment 4281
Plugin perspective supports exporting linked libraries

The attachment illustrates that the development environment appears to support
exporting of linked resources to other plugins and applications.
On re-reading my report, I realize there may be some confusion about the 
section "Reasons why I consider this feature to be desirable".  In case there 
is any confusion I'm suggesting that PDE ought to support references to remote 
resources via the runtime workbench when self-hosting.
Could you please move to PDE-UI
This is not doable because when you launch the runtime workbench, it is not 
PDE but the runtime that looks for these resources on disk.  The runtime has 
no concept of linked resources.  So if the content of a plug-in are coming 
from all over the place, it will not be able to locate them.

PDE can't warn about not using linked resources, because self-hosting using 
links works as long as it's within limits.  For instance, if you import a plug-
in with linking, all the resources are coming from the same place and relative 
to the plugin.xml.  When PDE passes the URL of this plug-in to the runtime 
workbench, it passes the actual location of the plugin.xml on disk, so the 
runtime can find all that it needs since the plug-in is encapsulated in one 
place on disk.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35467" />
    <CreationDate amount="2003-03-21 09:45:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>CVS Compare editor doesn't support ctrl-s</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="functiondef">
        <location start="1162" end="1272" />
        <code>public void propertyChange(PropertyChangeEvent event) {
  if (isDirty())
    firePropertyChange(PROP_DIRTY);
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="2">
        <Lines>
          <Line>- show as dirty</Line>
          <Line>- allow ctrl-s</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>2.1 RC3
The CVSLocalCompareInput::isSaveNeeded() method is bogus. It returns false all
the time which means that the editor is never marked as dirty. As a result if
you edit a local file in the compare view the editor doesn't:

- show as dirty
- allow ctrl-s

The fix is to remove the isSaveNeeded() method from CVSLocalCompareInput and
instead use the inherited one from CompareInput. Also, doulbe check that this
won't impact the sync view. The method isn't commented so I am unsure of why it
was overriden in this class to begin with. It doesn't make sense.

Workaround is to use the context menu save action.

Bug 20327 is somewhat related.
Kevin thinks that this could be a low risk last minute fix to Team. Since we
have already enabled global save within the sync view it would be consistent to
add it to the remaining compare/merge editors. To complete this PR there is also
a fix required in the Compare plugin. Andre, could you comment on your level of
comfort in fixing this for RC4?

Currently the compare editor doesn't dispatch a property change when the dirty
state goes from dirty -&gt; clean. The following method in CompareEditor is the
culprit.

public void propertyChange(PropertyChangeEvent event) {
  if (isDirty())
    firePropertyChange(PROP_DIRTY);
}

This bug can be seen when you edit the left pane text merge viewer then clicks
on another node in the structure diff and answers "No" to save changes. The
editor doesn't revert to being clean (e.g. global save disabled and '*' in
editor tab goes away).
I will submit the changes to Team to support ctrl-s but the compare change is
more risky for 2.1 because it breaks the assumption that compare editors are
buffered. 

Note that this code will also have to be changed to allow a "revert" action to
be implemented.

Created a new compare bug: Bug 35647</WithStack>
    <WithOutStack>2.1 RC3
The CVSLocalCompareInput::isSaveNeeded() method is bogus. It returns false all
the time which means that the editor is never marked as dirty. As a result if
you edit a local file in the compare view the editor doesn't:

- show as dirty
- allow ctrl-s

The fix is to remove the isSaveNeeded() method from CVSLocalCompareInput and
instead use the inherited one from CompareInput. Also, doulbe check that this
won't impact the sync view. The method isn't commented so I am unsure of why it
was overriden in this class to begin with. It doesn't make sense.

Workaround is to use the context menu save action.

Bug 20327 is somewhat related.
Kevin thinks that this could be a low risk last minute fix to Team. Since we
have already enabled global save within the sync view it would be consistent to
add it to the remaining compare/merge editors. To complete this PR there is also
a fix required in the Compare plugin. Andre, could you comment on your level of
comfort in fixing this for RC4?

Currently the compare editor doesn't dispatch a property change when the dirty
state goes from dirty -&gt; clean. The following method in CompareEditor is the
culprit.

public void propertyChange(PropertyChangeEvent event) {
  if (isDirty())
    firePropertyChange(PROP_DIRTY);
}

This bug can be seen when you edit the left pane text merge viewer then clicks
on another node in the structure diff and answers "No" to save changes. The
editor doesn't revert to being clean (e.g. global save disabled and '*' in
editor tab goes away).
I will submit the changes to Team to support ctrl-s but the compare change is
more risky for 2.1 because it breaks the assumption that compare editors are
buffered. 

Note that this code will also have to be changed to allow a "revert" action to
be implemented.

Created a new compare bug: Bug 35647</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35468" />
    <CreationDate amount="2003-03-21 09:56:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Import of an external plugin gets errors (possible regression)</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Import worked with no errors on the I20030317 build and prior 2.1 builds
It gets an error using I20030319 build (same error on RC3a)

I imported an external plugin (in this case the 1.3.7 version of com.ibm.lpex)

Can be reproduced with a fresh workspace.   Imported the above plugin using 
I20030319 and I would get the following error:
"Error	Unable to read 'com.ibm.lpex/.classpath' file.	com.ibm.lpex	Build 
path"

It appears that the import process decided that the root directory of the 
plugin was a source directory.   This is different from previous builds where 
no source directory would be specified.   If I remove the source entry in the 
Project-&gt;properties-&gt;Java Build Path then it works as expected.

I don't know if this intended behaviour but it looks like regression for 
something that worked before.   

If this is new intended behaviour then it is not easy to diagnose when you get 
the error.
Please move it to PDE-UI
More problems:

Previous builds would find a jar in the plugin and add it to the export list.

Starting with I20030319 it no longer does this.  I now have to manually export 
the jar in the plugin.
Fixed in RC3b.</WithStack>
    <WithOutStack>Import worked with no errors on the I20030317 build and prior 2.1 builds
It gets an error using I20030319 build (same error on RC3a)

I imported an external plugin (in this case the 1.3.7 version of com.ibm.lpex)

Can be reproduced with a fresh workspace.   Imported the above plugin using 
I20030319 and I would get the following error:
"Error	Unable to read 'com.ibm.lpex/.classpath' file.	com.ibm.lpex	Build 
path"

It appears that the import process decided that the root directory of the 
plugin was a source directory.   This is different from previous builds where 
no source directory would be specified.   If I remove the source entry in the 
Project-&gt;properties-&gt;Java Build Path then it works as expected.

I don't know if this intended behaviour but it looks like regression for 
something that worked before.   

If this is new intended behaviour then it is not easy to diagnose when you get 
the error.
Please move it to PDE-UI
More problems:

Previous builds would find a jar in the plugin and add it to the export list.

Starting with I20030319 it no longer does this.  I now have to manually export 
the jar in the plugin.
Fixed in RC3b.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35469" />
    <CreationDate amount="2003-03-21 10:11:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-Motif" />
    <priority amount="P3" />
    <bug_severity amount="critical" />
    <Summery>Encoding is lost in Japanese</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="2">
      <source_code type="class">
        <location start="155" end="499" />
        <code>public class FontTest {

	public static void main(String[] args) {

		FontData data =
			new FontData("1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal-old
style-*-140-75-75-c-*-jisx0208.1997-0");
		
		Font font = new Font(Display.getDefault(),data);
		FontData[] newData = font.getFontData();
		System.out.println(newData[0].toString());
	}

}</code>
      </source_code>
      <source_code type="class">
        <location start="1267" end="1664" />
        <code>public class FontTest {

	public static void main(String[] args) {

		FontData data =
			new FontData("1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal-old
style-*-140-75-75-c-*-jisx0208.1997-0");
		
		Font font = new Font(Display.getDefault(),data);
		FontData[] newData = font.getFontData();
		for(int i =0; i&lt; newData.length; i ++){
			System.out.println(newData[0].toString());
				}
		}
		

}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>RC2
Linux Motif Japanese

When you execute the code below you will see that the encoding portion of the
font definition is lost when the font is created.

public class FontTest {

	public static void main(String[] args) {

		FontData data =
			new FontData("1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal-old
style-*-140-75-75-c-*-jisx0208.1997-0");
		
		Font font = new Font(Display.getDefault(),data);
		FontData[] newData = font.getFontData();
		System.out.println(newData[0].toString());
	}

}

This will print the result 

1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal--15-140-75-75-c-90-iso8859-1
Upping severity to correspond to triggering PR.

It is possible that one font data when turned into a font will generate 
multiple font data when the font is queried back.  The best match for your 
original font data should appear as an entry in the font data array.  Please 
reopen if this is not the case.
The problem is determining how to continue to use the FontDialog then which 
will only take and return one FontData - we would need to be able to get the 
full value from SWT to able to support this.
This is a more valid test as it checks all of the FontDatas. On my machine I
still only get the iso8859-1 one. Fuse-san please verify this behaviour.

public class FontTest {

	public static void main(String[] args) {

		FontData data =
			new FontData("1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal-old
style-*-140-75-75-c-*-jisx0208.1997-0");
		
		Font font = new Font(Display.getDefault(),data);
		FontData[] newData = font.getFontData();
		for(int i =0; i&lt; newData.length; i ++){
			System.out.println(newData[0].toString());
				}
		}
		

}
NOTE: that your testcase has a bug. It loops to show all the font datas but
always print the font data at 0.


The font you are trying to load: 
1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal-oldstyle-*-140-75-75-c-*-jisx0208.1997-0"
Does not exist (in my system at least). 
(more precisily The add style "oldstyle" and the registry "jisx0208.1997" do not
exist)

Running your code I got the output:
1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal--15-140-75-75-c-90-iso8859-1
1|fixed|14|0|MOTIF|1|-jis-fixed-medium-r-normal--15-140-75-75-c-150-jisx0208.1983-0
1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal--15-140-75-75-c-80-jisx0201.1976-0

This is right!
It has loaded what the code has asked for except by the invalid fields.

It also has loaded the right fontset for the ja_JP locale, look the XLC_LOCALE:
(less /usr/X11R6/lib/X11/locale/ja/XLC_LOCALE)

It defines that the first charset is ISO8859-1, the second is JISX0208.1983-0,
and the last is JISX0201.1976-0.




Fuse-san are you getting the following warning to the console when running this?

Warning: locale not supported by C library, locale unchanged
After talking to Felipe the root of the problem is that there are too many fonts
in the file dialog.

The only fonts on Motif that are valid for any given Locale are those that are
in /usr/X11R6/lib/X11/locale/&lt;locale&gt;/XLC_LOCALE. On my Japanese install this is
generally 2 or 3 fonts - not the 100s in the dialog.

Plus run the test below using one of the fonts in your XLC_LOCALE file - if you
need help defining them in the example please attach them to this PR.
Tod, I didn't get the warning message, and I am aware your test case had a bug.
Now I get rerurn of font name as Felipe mentioned at #5.

XLC_LOCALE file defines font charset name that is a part of X window logical 
font name and can be used on Motif. But the font dialog lists all of logical 
font queried by font server. Am I right? If so, this PR should be closed.

Yes Fuse san you are right. I will close the PR.</WithStack>
    <WithOutStack>RC2
Linux Motif Japanese

When you execute the code below you will see that the encoding portion of the
font definition is lost when the font is created.

public class FontTest {

	public static void main(String[] args) {

		FontData data =
			new FontData("1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal-old
style-*-140-75-75-c-*-jisx0208.1997-0");
		
		Font font = new Font(Display.getDefault(),data);
		FontData[] newData = font.getFontData();
		System.out.println(newData[0].toString());
	}

}

This will print the result 

1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal--15-140-75-75-c-90-iso8859-1
Upping severity to correspond to triggering PR.

It is possible that one font data when turned into a font will generate 
multiple font data when the font is queried back.  The best match for your 
original font data should appear as an entry in the font data array.  Please 
reopen if this is not the case.
The problem is determining how to continue to use the FontDialog then which 
will only take and return one FontData - we would need to be able to get the 
full value from SWT to able to support this.
This is a more valid test as it checks all of the FontDatas. On my machine I
still only get the iso8859-1 one. Fuse-san please verify this behaviour.

public class FontTest {

	public static void main(String[] args) {

		FontData data =
			new FontData("1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal-old
style-*-140-75-75-c-*-jisx0208.1997-0");
		
		Font font = new Font(Display.getDefault(),data);
		FontData[] newData = font.getFontData();
		for(int i =0; i&lt; newData.length; i ++){
			System.out.println(newData[0].toString());
				}
		}
		

}
NOTE: that your testcase has a bug. It loops to show all the font datas but
always print the font data at 0.


The font you are trying to load: 
1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal-oldstyle-*-140-75-75-c-*-jisx0208.1997-0"
Does not exist (in my system at least). 
(more precisily The add style "oldstyle" and the registry "jisx0208.1997" do not
exist)

Running your code I got the output:
1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal--15-140-75-75-c-90-iso8859-1
1|fixed|14|0|MOTIF|1|-jis-fixed-medium-r-normal--15-140-75-75-c-150-jisx0208.1983-0
1|fixed|14|0|MOTIF|1|-misc-fixed-medium-r-normal--15-140-75-75-c-80-jisx0201.1976-0

This is right!
It has loaded what the code has asked for except by the invalid fields.

It also has loaded the right fontset for the ja_JP locale, look the XLC_LOCALE:
(less /usr/X11R6/lib/X11/locale/ja/XLC_LOCALE)

It defines that the first charset is ISO8859-1, the second is JISX0208.1983-0,
and the last is JISX0201.1976-0.




Fuse-san are you getting the following warning to the console when running this?

Warning: locale not supported by C library, locale unchanged
After talking to Felipe the root of the problem is that there are too many fonts
in the file dialog.

The only fonts on Motif that are valid for any given Locale are those that are
in /usr/X11R6/lib/X11/locale/&lt;locale&gt;/XLC_LOCALE. On my Japanese install this is
generally 2 or 3 fonts - not the 100s in the dialog.

Plus run the test below using one of the fonts in your XLC_LOCALE file - if you
need help defining them in the example please attach them to this PR.
Tod, I didn't get the warning message, and I am aware your test case had a bug.
Now I get rerurn of font name as Felipe mentioned at #5.

XLC_LOCALE file defines font charset name that is a part of X window logical 
font name and can be used on Motif. But the font dialog lists all of logical 
font queried by font server. Am I right? If so, this PR should be closed.

Yes Fuse san you are right. I will close the PR.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35470" />
    <CreationDate amount="2003-03-21 10:19:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[misc] "Assertion failed" popup on save from Java Editor</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="6">
        <Lines>
          <Line>1. I had a bunch of files open, all saved, all compiled</Line>
          <Line>2. ran organize imports on project.  This resulted in a bunch of files being</Line>
          <Line>opened and left in modified state.</Line>
          <Line>3. I manually saved a couple of them and then tried saveall.  I got the assert</Line>
          <Line>several times.  I don't know if it saved any of the files, but it might have.</Line>
          <Line>So I went through and saved them all manually.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>I get these every once in a while.

I'll include a log.
Created attachment 4282
.metadate\.log from that Eclipse run.
I also get them sporadically.
I am using the 2.1 release build.
Ill attach the relevant snippet from my log.
Created attachment 4406
Relevant snippets from .log
I got it too and found this bug so I'll attach all messages in the log from 
today.
Created attachment 4487
Log messages from the last session showing the save failures at the end.
Any chance will get a comment on this bug?
It occured again for me today.

Scott
I didn"t have it with 2.1 but now I updated to 2.1.1 and get it after editing 
and saving the same file several times. But the save seems to be successful.
Created attachment 5716
Eclipse Log

I've just seen this exact same behaviour using the I20030806 build.
Happens in TextSelectionNavigation. Some code is setting either the length or
the offset of fPosition to a value &lt; 0 which is invalid.

I now protected the setter methods to be as strict as the constructor. This will
allow us to find the code which sets the negative value.

Created attachment 11533
assert traceback updating markers
Okay, I lost my comments I just made about the attachment.

In rc1, I saw a very similar assert, but with a different traceback (attached).
 Basically, here's what I had done (haven't tried to reproduce).

1. I had a bunch of files open, all saved, all compiled
2. ran organize imports on project.  This resulted in a bunch of files being
opened and left in modified state.
3. I manually saved a couple of them and then tried saveall.  I got the assert
several times.  I don't know if it saved any of the files, but it might have. 
So I went through and saved them all manually.

Ernest, the asserts are not related. Could you file a new PR with the steps and
all log entries. Thanks.
Setting to REMIND since we didn't get it again so far.
Get rid of deprecated state.
.</WithStack>
    <WithOutStack>I get these every once in a while.

I'll include a log.
Created attachment 4282
.metadate\.log from that Eclipse run.
I also get them sporadically.
I am using the 2.1 release build.
Ill attach the relevant snippet from my log.
Created attachment 4406
Relevant snippets from .log
I got it too and found this bug so I'll attach all messages in the log from 
today.
Created attachment 4487
Log messages from the last session showing the save failures at the end.
Any chance will get a comment on this bug?
It occured again for me today.

Scott
I didn"t have it with 2.1 but now I updated to 2.1.1 and get it after editing 
and saving the same file several times. But the save seems to be successful.
Created attachment 5716
Eclipse Log

I've just seen this exact same behaviour using the I20030806 build.
Happens in TextSelectionNavigation. Some code is setting either the length or
the offset of fPosition to a value &lt; 0 which is invalid.

I now protected the setter methods to be as strict as the constructor. This will
allow us to find the code which sets the negative value.

Created attachment 11533
assert traceback updating markers
Okay, I lost my comments I just made about the attachment.

In rc1, I saw a very similar assert, but with a different traceback (attached).
 Basically, here's what I had done (haven't tried to reproduce).

1. I had a bunch of files open, all saved, all compiled
2. ran organize imports on project.  This resulted in a bunch of files being
opened and left in modified state.
3. I manually saved a couple of them and then tried saveall.  I got the assert
several times.  I don't know if it saved any of the files, but it might have. 
So I went through and saved them all manually.

Ernest, the asserts are not related. Could you file a new PR with the steps and
all log entries. Thanks.
Setting to REMIND since we didn't get it again so far.
Get rid of deprecated state.
.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35471" />
    <CreationDate amount="2003-03-21 10:23:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="User Assistance" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Primary tocs that link to the same help home page break</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="6">
        <Lines>
          <Line>- IE -&gt; choose book2 or book3. It stays open but focus in the Contents frame</Line>
          <Line>jumps back to book1 but book1 does not open. (I mean you're left with what you</Line>
          <Line>chose open but book1 is what's highlighted).</Line>
          <Line>- Mozilla 1.3 -&gt; choose book2 or book3. I starts to open and almost finishes to</Line>
          <Line>load, but then closes again and focus jumps back to book1 and it opens.</Line>
          <Line>Netscape 7.02 -&gt; exact same as Mozilla 1.3.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="CLOSED" />
    <resolution amount="FIXED" />
    <WithStack>I'll attach a small testcase.

In one plug-in, I've got multiple toc's and I declare them all primary. In the 
toc tag for each of these, I include a topic="html/helphome.html" attribute 
(html/helphome.html is a valid path and filename in the plugin). In the 
testcase (and I'll refer to them this way), they're book1, book2, and book3 
where book1 is declared primary first in plugin.xml and it's the one that 
appears at the top of the 3 in the Contents frame.

The resulting behaviour:

- IE -&gt; choose book2 or book3. It stays open but focus in the Contents frame 
jumps back to book1 but book1 does not open. (I mean you're left with what you 
chose open but book1 is what's highlighted).
- Mozilla 1.3 -&gt; choose book2 or book3. I starts to open and almost finishes to 
load, but then closes again and focus jumps back to book1 and it opens.
Netscape 7.02 -&gt; exact same as Mozilla 1.3.

If you remove the toc attributes that call the topic HTML, the books behave as 
expected in the Contents frame.
Created attachment 4283
Sample plug-in.

Plug-in id is 'test' (ie. preserve the test directory as root).
Yes, this is a tree bug. All the nodes are treated in the same way: when the 
same topic href is used by a number of topic nodes in the tree(in this case it 
is the book nodes) the one to be highlighted will be the first one encountered, 
going top to bottom.
While this makes sense for the actual topics, it is incorrect for books. 

Workaround: until a fix is provided, you can create copies of the 
html/helphome.html file and have each book point to a different href.

Fixed.
Sorry - I should have verified this much sooner. I've now verified it in
eclipse-SDK-3.1M4-win32.
Closing.</WithStack>
    <WithOutStack>I'll attach a small testcase.

In one plug-in, I've got multiple toc's and I declare them all primary. In the 
toc tag for each of these, I include a topic="html/helphome.html" attribute 
(html/helphome.html is a valid path and filename in the plugin). In the 
testcase (and I'll refer to them this way), they're book1, book2, and book3 
where book1 is declared primary first in plugin.xml and it's the one that 
appears at the top of the 3 in the Contents frame.

The resulting behaviour:

- IE -&gt; choose book2 or book3. It stays open but focus in the Contents frame 
jumps back to book1 but book1 does not open. (I mean you're left with what you 
chose open but book1 is what's highlighted).
- Mozilla 1.3 -&gt; choose book2 or book3. I starts to open and almost finishes to 
load, but then closes again and focus jumps back to book1 and it opens.
Netscape 7.02 -&gt; exact same as Mozilla 1.3.

If you remove the toc attributes that call the topic HTML, the books behave as 
expected in the Contents frame.
Created attachment 4283
Sample plug-in.

Plug-in id is 'test' (ie. preserve the test directory as root).
Yes, this is a tree bug. All the nodes are treated in the same way: when the 
same topic href is used by a number of topic nodes in the tree(in this case it 
is the book nodes) the one to be highlighted will be the first one encountered, 
going top to bottom.
While this makes sense for the actual topics, it is incorrect for books. 

Workaround: until a fix is provided, you can create copies of the 
html/helphome.html file and have each book point to a different href.

Fixed.
Sorry - I should have verified this much sooner. I've now verified it in
eclipse-SDK-3.1M4-win32.
Closing.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35472" />
    <CreationDate amount="2003-03-21 10:24:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>create a StackLayout example tab</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>And reorganize examples while at it (remove redundancies in particular).
Doesn't fit in with the other types of layout in the example.</WithStack>
    <WithOutStack>And reorganize examples while at it (remove redundancies in particular).
Doesn't fit in with the other types of layout in the example.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35473" />
    <CreationDate amount="2003-03-21 10:28:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>NPE when exiting Eclipse</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437340488197">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">org.eclipse.jdt.internal.core.search.indexing.IndexManager.shutdown(IndexManager.java:511)</Frame>
          <Frame depth="1">org.eclipse.jdt.internal.core.JavaModelManager.shutdown(JavaModelManager.java:1550)</Frame>
          <Frame depth="2">org.eclipse.jdt.core.JavaCore.shutdown(JavaCore.java:3004)</Frame>
          <Frame depth="3">org.eclipse.core.internal.plugins.PluginRegistry$2.run(PluginRegistry.java:283)</Frame>
          <Frame depth="4">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:937)</Frame>
          <Frame depth="5">org.eclipse.core.internal.plugins.PluginRegistry$1.visit(PluginRegistry.java:296)</Frame>
          <Frame depth="6">org.eclipse.core.internal.plugins.PluginRegistry.accept(PluginRegistry.java:55)</Frame>
          <Frame depth="7">org.eclipse.core.internal.plugins.PluginRegistry.shutdownPlugins(PluginRegistry.java:299)</Frame>
          <Frame depth="8">org.eclipse.core.internal.plugins.PluginRegistry.shutdown(PluginRegistry.java:265)</Frame>
          <Frame depth="9">org.eclipse.core.internal.runtime.InternalPlatform.loaderShutdown(InternalPlatform.java:518)</Frame>
          <Frame depth="10">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="11">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="12">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="13">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="14">org.eclipse.core.internal.boot.InternalBootLoader.shutdown(InternalBootLoader.java:979)</Frame>
          <Frame depth="15">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:850)</Frame>
          <Frame depth="16">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="17">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</Frame>
          <Frame depth="18">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)</Frame>
          <Frame depth="19">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</Frame>
          <Frame depth="20">java.lang.reflect.Method.invoke(Method.java:324)</Frame>
          <Frame depth="21">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="22">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="23">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="6">
      <source_code type="assignment">
        <location start="875" end="930" />
        <code>IIndex[] selectedIndexes = indexSelector.getIndexes();</code>
      </source_code>
      <source_code type="assignment">
        <location start="931" end="987" />
        <code>SimpleLookupTable knownPaths = new SimpleLookupTable();</code>
      </source_code>
      <source_code type="functiondef">
        <location start="988" end="1152" />
        <code>for (int i = 0, max = selectedIndexes.length; i &lt; max; i++) {
		String path = selectedIndexes[i].getIndexFile().getAbsolutePath();
		knownPaths.put(path, path);
	}</code>
      </source_code>
      <source_code type="assignment">
        <location start="1310" end="1365" />
        <code>IIndex[] selectedIndexes = indexSelector.getIndexes();</code>
      </source_code>
      <source_code type="assignment">
        <location start="1366" end="1422" />
        <code>SimpleLookupTable knownPaths = new SimpleLookupTable();</code>
      </source_code>
      <source_code type="functiondef">
        <location start="1423" end="1728" />
        <code>for (int i = 0, max = selectedIndexes.length; i &lt; max; i++) {
                IIndex selectedIndex = selectedIndexes[i];
                if (selectedIndex != null) {
                     String path = selectedIndex.getIndexFile().getAbsolutePath();
		     knownPaths.put(path, path);
                }
	}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="1">
      <Enumeration lines="6">
        <Lines>
          <Line>- download the workspace from http://www.weinand.org/eclipse/workspace.zip (its</Line>
          <Line>being uploaded so wait for another 30 minutes).</Line>
          <Line>- Unzip and copy the workspace into the same directory where Eclipse lives.</Line>
          <Line>- Start Eclipse and quit immediately.</Line>
          <Line>- open the .log file. There should be a new entry at the end.</Line>
          <Line>In this code,</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>RC3a
whenever I exit Eclipse with some small test workspace,
I get the following NPE:

!SESSION Mar 21, 2003 16:04:43.492 ---------------------------------------------
java.version=1.4.1-beta
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
Command-line arguments: -os win32 -ws win32 -arch x86 -install 
file:D:/eclipse/rt/eclipse/
!ENTRY org.eclipse.core.runtime 4 2 Mar 21, 2003 16:04:43.492
!MESSAGE Problems occurred when invoking code from plug-
in: "org.eclipse.core.runtime".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.search.indexing.IndexManager.shutdown
(IndexManager.java:511)
	at org.eclipse.jdt.internal.core.JavaModelManager.shutdown
(JavaModelManager.java:1550)
	at org.eclipse.jdt.core.JavaCore.shutdown(JavaCore.java:3004)
	at org.eclipse.core.internal.plugins.PluginRegistry$2.run
(PluginRegistry.java:283)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:937)
	at org.eclipse.core.internal.plugins.PluginRegistry$1.visit
(PluginRegistry.java:296)
	at org.eclipse.core.internal.plugins.PluginRegistry.accept
(PluginRegistry.java:55)
	at org.eclipse.core.internal.plugins.PluginRegistry.shutdownPlugins
(PluginRegistry.java:299)
	at org.eclipse.core.internal.plugins.PluginRegistry.shutdown
(PluginRegistry.java:265)
	at org.eclipse.core.internal.runtime.InternalPlatform.loaderShutdown
(InternalPlatform.java:518)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.internal.boot.InternalBootLoader.shutdown
(InternalBootLoader.java:979)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:850)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
	at org.eclipse.core.launcher.Main.run(Main.java:747)
	at org.eclipse.core.launcher.Main.main(Main.java:583)


To reproduce
- download the workspace from http://www.weinand.org/eclipse/workspace.zip (its 
being uploaded so wait for another 30 minutes).
- Unzip and copy the workspace into the same directory where Eclipse lives.
- Start Eclipse and quit immediately.
- open the .log file. There should be a new entry at the end.
In this code,

	IIndex[] selectedIndexes = indexSelector.getIndexes();
	SimpleLookupTable knownPaths = new SimpleLookupTable();
	for (int i = 0, max = selectedIndexes.length; i &lt; max; i++) {
		String path = selectedIndexes[i].getIndexFile().getAbsolutePath();
		knownPaths.put(path, path);
	}

getIndexes() can return a collection which contains null entries, if some index
needs to be created.
So a fix would be to add a null check in the for loop.
	IIndex[] selectedIndexes = indexSelector.getIndexes();
	SimpleLookupTable knownPaths = new SimpleLookupTable();
	for (int i = 0, max = selectedIndexes.length; i &lt; max; i++) {
                IIndex selectedIndex = selectedIndexes[i];
                if (selectedIndex != null) {
                     String path = selectedIndex.getIndexFile().getAbsolutePath();
		     knownPaths.put(path, path);
                }
	}
Created attachment 4289
Patch for this NPE

Applying this patch fixed the problem on my machine.
Null indexes could be computed incorrectly as a consequence of fix for bug 
35306. This is a regression.

Need to be fixed for RC4 (null indexes are simply to be ignored).
Created attachment 4290
Better fix for this issue

#getIndexes() must not answer null indexes, since clients do not expect this.
Also the problem may occur elsewhere than during shutdown (whenever a search
job is running without waiting for indexing to have finished).
Patch verified.
+1
Is this a regression of Bug 33462?  I am seeing it in RC3b.
No, this is a different problem. In fact, this is a consequence of fixing bug 
35306.

Fix is not yet released (that's why you're seeing it in RC3b)
*** Bug 35608 has been marked as a duplicate of this bug. ***
*** Bug 35642 has been marked as a duplicate of this bug. ***
Fix released for integration
Verified.</WithStack>
    <WithOutStack>RC3a
whenever I exit Eclipse with some small test workspace,
I get the following NPE:

!SESSION Mar 21, 2003 16:04:43.492 ---------------------------------------------
java.version=1.4.1-beta
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
Command-line arguments: -os win32 -ws win32 -arch x86 -install 
file:D:/eclipse/rt/eclipse/
!ENTRY org.eclipse.core.runtime 4 2 Mar 21, 2003 16:04:43.492
!MESSAGE Problems occurred when invoking code from plug-
in: "org.eclipse.core.runtime".
!STACK 0



To reproduce
- download the workspace from http://www.weinand.org/eclipse/workspace.zip (its 
being uploaded so wait for another 30 minutes).
- Unzip and copy the workspace into the same directory where Eclipse lives.
- Start Eclipse and quit immediately.
- open the .log file. There should be a new entry at the end.
In this code,

	IIndex[] selectedIndexes = indexSelector.getIndexes();
	SimpleLookupTable knownPaths = new SimpleLookupTable();
	for (int i = 0, max = selectedIndexes.length; i &lt; max; i++) {
		String path = selectedIndexes[i].getIndexFile().getAbsolutePath();
		knownPaths.put(path, path);
	}

getIndexes() can return a collection which contains null entries, if some index
needs to be created.
So a fix would be to add a null check in the for loop.
	IIndex[] selectedIndexes = indexSelector.getIndexes();
	SimpleLookupTable knownPaths = new SimpleLookupTable();
	for (int i = 0, max = selectedIndexes.length; i &lt; max; i++) {
                IIndex selectedIndex = selectedIndexes[i];
                if (selectedIndex != null) {
                     String path = selectedIndex.getIndexFile().getAbsolutePath();
		     knownPaths.put(path, path);
                }
	}
Created attachment 4289
Patch for this NPE

Applying this patch fixed the problem on my machine.
Null indexes could be computed incorrectly as a consequence of fix for bug 
35306. This is a regression.

Need to be fixed for RC4 (null indexes are simply to be ignored).
Created attachment 4290
Better fix for this issue

#getIndexes() must not answer null indexes, since clients do not expect this.
Also the problem may occur elsewhere than during shutdown (whenever a search
job is running without waiting for indexing to have finished).
Patch verified.
+1
Is this a regression of Bug 33462?  I am seeing it in RC3b.
No, this is a different problem. In fact, this is a consequence of fixing bug 
35306.

Fix is not yet released (that's why you're seeing it in RC3b)
*** Bug 35608 has been marked as a duplicate of this bug. ***
*** Bug 35642 has been marked as a duplicate of this bug. ***
Fix released for integration
Verified.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35474" />
    <CreationDate amount="2003-03-21 10:35:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[Decorators] Stale binary project decorator after checkout</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="3">
        <Lines>
          <Line>1) I imported all 65 plugins into the workspace, without copying contents</Line>
          <Line>2) I connected to dev.eclipse.org, and checked out the "platform" module</Line>
          <Line>3) I then checked out the "jdt" and "pde" modules.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>Build: 2.1 RC3a

1) I imported all 65 plugins into the workspace, without copying contents
2) I connected to dev.eclipse.org, and checked out the "platform" module
3) I then checked out the "jdt" and "pde" modules.

-&gt; All projects checked out successfully, but all JDT and PDE projects still
show up with the binary project decoration
Created attachment 4284
Screen shot showing binary decorator on source project
If I turn the decorator off, then on again, it now shows the correct decorations.
This looks to me like notification failure. Our decorators are 'light' i.e. 
their usage is fully dependent on evaluation of the 'enablement' XML expression 
declared in plug-in manifest. We don't run any code to compute this value.
Funny, I just imported everything as binary, then imported PDE plug-ins as 
source and the binary decorator went away (as designed). Maybe in my case it 
worked because I had CVS view as 'fast view' and it was overlapping Package 
Explorer.
I had three perspectives: resources, java, CVS repository exploring.  None of
these were customized in any way (no fast views).

I checked out from the CVS perspective, and then noticed the stale decorators in
the java and resources perspectives.  So perhahps it's related to the fact that
the perspective I checked out from didn't have *any* views that would display
any decorators.
Ack. I am moving this to platform UI because lightweight decorators are managed 
by the UI and it looks like condition comutation is not the problem - 
notification is.
Cannot replicate in 2.1.</WithStack>
    <WithOutStack>Build: 2.1 RC3a

1) I imported all 65 plugins into the workspace, without copying contents
2) I connected to dev.eclipse.org, and checked out the "platform" module
3) I then checked out the "jdt" and "pde" modules.

-&gt; All projects checked out successfully, but all JDT and PDE projects still
show up with the binary project decoration
Created attachment 4284
Screen shot showing binary decorator on source project
If I turn the decorator off, then on again, it now shows the correct decorations.
This looks to me like notification failure. Our decorators are 'light' i.e. 
their usage is fully dependent on evaluation of the 'enablement' XML expression 
declared in plug-in manifest. We don't run any code to compute this value.
Funny, I just imported everything as binary, then imported PDE plug-ins as 
source and the binary decorator went away (as designed). Maybe in my case it 
worked because I had CVS view as 'fast view' and it was overlapping Package 
Explorer.
I had three perspectives: resources, java, CVS repository exploring.  None of
these were customized in any way (no fast views).

I checked out from the CVS perspective, and then noticed the stale decorators in
the java and resources perspectives.  So perhahps it's related to the fact that
the perspective I checked out from didn't have *any* views that would display
any decorators.
Ack. I am moving this to platform UI because lightweight decorators are managed 
by the UI and it looks like condition comutation is not the problem - 
notification is.
Cannot replicate in 2.1.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35475" />
    <CreationDate amount="2003-03-21 10:36:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Debug" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Stepping sometimes has side-effect of making a busy cursor "stick"</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="CLOSED" />
    <resolution amount="WONTFIX" />
    <WithStack>Eclipse 2.1, RC2

When debugging my own language (which can step much faster than JDT), if I 
keep hitting "Step Into" with the mouse, super fast, sometimes the cursor 
switches to the hourglass and stays like that. The GUI is responsive an all, I 
can click around and keep using Eclipse just fine, just as if the cursor was 
normal. But the cursor is an hourglass (misleading) and the problem doesn't 
fix itself anymore. If I move the cursor to teh text editor, it becomes a 
caret, normally. But as soon as I enter that view with the stack frames again, 
it becomes an hourglass.

My stepping code generates the debug events etc, no real GUI code. Any 
possibility there's a race condition or perhaps some GUI exception preventing 
that view's cursor from switching back ?

Thanks in advance.
Anything in the .log?
Nothing in the .log.
Deferred
Closing
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>Eclipse 2.1, RC2

When debugging my own language (which can step much faster than JDT), if I 
keep hitting "Step Into" with the mouse, super fast, sometimes the cursor 
switches to the hourglass and stays like that. The GUI is responsive an all, I 
can click around and keep using Eclipse just fine, just as if the cursor was 
normal. But the cursor is an hourglass (misleading) and the problem doesn't 
fix itself anymore. If I move the cursor to teh text editor, it becomes a 
caret, normally. But as soon as I enter that view with the stack frames again, 
it becomes an hourglass.

My stepping code generates the debug events etc, no real GUI code. Any 
possibility there's a race condition or perhaps some GUI exception preventing 
that view's cursor from switching back ?

Thanks in advance.
Anything in the .log?
Nothing in the .log.
Deferred
Closing
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35476" />
    <CreationDate amount="2003-03-21 10:55:00 -0500" />
    <DupId amount="35731" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="major" />
    <Summery>Null pointer exception in org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage</Summery>
    <Patches amount="0" />
    <Stacktraces amount="2">
      <Stacktrace timestamp="1437340488197">
        <Exception>java.lang.NullPointerException</Exception>
        <Reason />
        <Frames>
          <Frame depth="0">java.lang.String.&lt;init&gt;(String.java(Compiled Code))</Frame>
          <Frame depth="1">org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java(Compiled Code))</Frame>
          <Frame depth="2">org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java(Compiled Code))</Frame>
          <Frame depth="3">org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java(Compiled Code))</Frame>
          <Frame depth="4">org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java(Compiled Code))</Frame>
          <Frame depth="5">org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java(Compiled Code))</Frame>
          <Frame depth="6">org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java(Compiled Code))</Frame>
          <Frame depth="7">org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:973)</Frame>
          <Frame depth="8">org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:39)</Frame>
          <Frame depth="9">org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:97)</Frame>
          <Frame depth="10">org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:149)</Frame>
          <Frame depth="11">org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:324)</Frame>
          <Frame depth="12">org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:127)</Frame>
          <Frame depth="13">org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:313)</Frame>
          <Frame depth="14">org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:789)</Frame>
          <Frame depth="15">org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:830)</Frame>
          <Frame depth="16">org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:251)</Frame>
          <Frame depth="17">org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:538)</Frame>
          <Frame depth="18">org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:338)</Frame>
          <Frame depth="19">org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:195)</Frame>
          <Frame depth="20">org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:145)</Frame>
          <Frame depth="21">org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:51)</Frame>
          <Frame depth="22">org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:194)</Frame>
          <Frame depth="23">org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:122)</Frame>
          <Frame depth="24">org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:424)</Frame>
          <Frame depth="25">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="26">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="27">org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:125)</Frame>
          <Frame depth="28">org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:181)</Frame>
          <Frame depth="29">org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:191)</Frame>
          <Frame depth="30">org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:151)</Frame>
          <Frame depth="31">org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)</Frame>
          <Frame depth="32">org.eclipse.core.runtime.Platform.run(Platform.java:413)</Frame>
          <Frame depth="33">org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:165)</Frame>
          <Frame depth="34">org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:265)</Frame>
          <Frame depth="35">org.eclipse.core.internal.resources.Project.build(Project.java:85)</Frame>
          <Frame depth="36">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.buildProject(BatchExtension.java:561)</Frame>
          <Frame depth="37">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.internalJarProcess(BatchExtension.java:525)</Frame>
          <Frame depth="38">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.runJarDeploy(BatchExtension.java:429)</Frame>
          <Frame depth="39">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.access$1(BatchExtension.java:394)</Frame>
          <Frame depth="40">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension$RunDeploy.run(BatchExtension.java:245)</Frame>
          <Frame depth="41">org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1588)</Frame>
          <Frame depth="42">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension$RunDeploy.execute(BatchExtension.java:227)</Frame>
          <Frame depth="43">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.run(BatchExtension.java:190)</Frame>
          <Frame depth="44">java.lang.reflect.Method.invoke(Native Method)</Frame>
          <Frame depth="45">com.ibm.etools.ejbdeploy.batch.impl.BootLoaderLoader.run(BootLoaderLoader.java:255)</Frame>
          <Frame depth="46">com.ibm.etools.ejbdeploy.batch.impl.BatchDeploy.execute(BatchDeploy.java:133)</Frame>
          <Frame depth="47">com.ibm.etools.ejbdeploy.EJBDeploy.execute(EJBDeploy.java:82)</Frame>
          <Frame depth="48">com.ibm.etools.ejbdeploy.EJBDeploy.main(EJBDeploy.java:309)</Frame>
          <Frame depth="49">com.ibm.etools.ejbdeploy.batch.impl.Test.run(Test.java:63)</Frame>
          <Frame depth="50">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="51">org.eclipse.core.boot.BootLoader.run(BootLoader.java:431)</Frame>
          <Frame depth="52">EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:24)</Frame>
        </Frames>
      </Stacktrace>
      <Stacktrace timestamp="1437340488197">
        <Exception>&gt;com.ibm.etools.ejbdeploy.EJBDeploymentException</Exception>
        <Reason>(An error occurred while 
compiling the .java code. Correct the code, and try again.)
&lt;0&gt;java.lang.NullPointerException encountered while running 
org.eclipse.jdt.internal.core.builder.JavaBuilder.
org.eclipse.core.internal.resources.ResourceException: Errors during build.</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:267)</Frame>
          <Frame depth="1">org.eclipse.core.internal.resources.Project.build(Project.java:85)</Frame>
          <Frame depth="2">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.buildProject(BatchExtension.java:561)</Frame>
          <Frame depth="3">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.internalJarProcess(BatchExtension.java:525)</Frame>
          <Frame depth="4">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.runJarDeploy(BatchExtension.java:429)</Frame>
          <Frame depth="5">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.access$1(BatchExtension.java:394)</Frame>
          <Frame depth="6">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension$RunDeploy.run(BatchExtension.java:245)</Frame>
          <Frame depth="7">org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1588)</Frame>
          <Frame depth="8">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension$RunDeploy.execute(BatchExtension.java:227)</Frame>
          <Frame depth="9">com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.run(BatchExtension.java:190)</Frame>
          <Frame depth="10">java.lang.reflect.Method.invoke(Native Method)</Frame>
          <Frame depth="11">com.ibm.etools.ejbdeploy.batch.impl.BootLoaderLoader.run(BootLoaderLoader.java:255)</Frame>
          <Frame depth="12">com.ibm.etools.ejbdeploy.batch.impl.BatchDeploy.execute(BatchDeploy.java:133)</Frame>
          <Frame depth="13">com.ibm.etools.ejbdeploy.EJBDeploy.execute(EJBDeploy.java:82)</Frame>
          <Frame depth="14">com.ibm.etools.ejbdeploy.EJBDeploy.main(EJBDeploy.java:309)</Frame>
          <Frame depth="15">com.ibm.etools.ejbdeploy.batch.impl.Test.run(Test.java:63)</Frame>
          <Frame depth="16">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="17">org.eclipse.core.boot.BootLoader.run(BootLoader.java:431)</Frame>
          <Frame depth="18">EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:24)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="2">
        <Lines>
          <Line>- Using IBM JRE 1.3.1 SR2</Line>
          <Line>- This problem does not occur when JIT is disabled</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>When deploying EJB and the builder is invoked on the generated code, the 
compiler throws a NPE (trace is below).  Please contact Leonard Theivendra at 
theivend@ca.ibm.com for a testcase.

The eclipse driver used in this build of IBM Websphere Studio is based on the 
Eclipse RC1 build.  I realize this will be hard for you to reproduce given that 
you don't have our plugins, runtimes, etc.  Hopefully the following stack trace 
helps, if it does not, please contact me and I will attempt to put together a 
simple .java source file that reproduced this compiler NPE.

Trace from our tool:

java.lang.NullPointerException
	at java.lang.String.&lt;init&gt;(String.java(Compiled Code))
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage
(Scope.java(Compiled Code))
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage
(Scope.java(Compiled Code))
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage
(Scope.java(Compiled Code))
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage
(Scope.java(Compiled Code))
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage
(Scope.java(Compiled Code))
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage
(Scope.java(Compiled Code))
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType
(Scope.java:973)
	at 
org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding
(SingleTypeReference.java:39)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType
(TypeReference.java:97)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve
(LocalDeclaration.java:149)
	at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatement
s(AbstractMethodDeclaration.java:324)
	at 
org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements
(MethodDeclaration.java:127)
	at 
org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve
(AbstractMethodDeclaration.java:313)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve
(TypeDeclaration.java:789)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve
(TypeDeclaration.java:830)
	at 
org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve
(CompilationUnitDeclaration.java:251)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:538)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:338)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:195)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile
(AbstractImageBuilder.java:145)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build
(BatchImageBuilder.java:51)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll
(JavaBuilder.java:194)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build
(JavaBuilder.java:122)
	at org.eclipse.core.internal.events.BuildManager$2.run
(BuildManager.java:424)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.core.internal.events.BuildManager.basicBuild
(BuildManager.java:125)
	at org.eclipse.core.internal.events.BuildManager.basicBuild
(BuildManager.java:181)
	at org.eclipse.core.internal.events.BuildManager.basicBuild
(BuildManager.java:191)
	at org.eclipse.core.internal.events.BuildManager$1.run
(BuildManager.java:151)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:867)
	at org.eclipse.core.runtime.Platform.run(Platform.java:413)
	at org.eclipse.core.internal.events.BuildManager.basicBuild
(BuildManager.java:165)
	at org.eclipse.core.internal.events.BuildManager.build
(BuildManager.java:265)
	at org.eclipse.core.internal.resources.Project.build(Project.java:85)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.buildProject
(BatchExtension.java:561)
	at 
com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.internalJarProcess
(BatchExtension.java:525)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.runJarDeploy
(BatchExtension.java:429)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.access$1
(BatchExtension.java:394)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension$RunDeploy.run
(BatchExtension.java:245)
	at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1588)
	at 
com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension$RunDeploy.execute
(BatchExtension.java:227)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.run
(BatchExtension.java:190)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.ibm.etools.ejbdeploy.batch.impl.BootLoaderLoader.run
(BootLoaderLoader.java:255)
	at com.ibm.etools.ejbdeploy.batch.impl.BatchDeploy.execute
(BatchDeploy.java:133)
	at com.ibm.etools.ejbdeploy.EJBDeploy.execute(EJBDeploy.java:82)
	at com.ibm.etools.ejbdeploy.EJBDeploy.main(EJBDeploy.java:309)
	at com.ibm.etools.ejbdeploy.batch.impl.Test.run(Test.java:63)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:431)
	at EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:24)
  (Found: 1 error, 2 warnings) Compiling 239586.jar/ejbModule/stinh/ejb11
  (Found: 1 error, 2 warnings) Build done
  Invoking Validation on /239586.jar.
  Invoking Library Copying Builder on /239586.jar.
  Updating.
[*Error] An unexpected exception was thrown.  Halting execution.
Shutting down workbench.

An error occurred while compiling the .java code. Correct the code, and try 
again.
&gt;com.ibm.etools.ejbdeploy.EJBDeploymentException (An error occurred while 
compiling the .java code. Correct the code, and try again.)
&lt;0&gt;java.lang.NullPointerException encountered while running 
org.eclipse.jdt.internal.core.builder.JavaBuilder.
org.eclipse.core.internal.resources.ResourceException: Errors during build.
	at org.eclipse.core.internal.events.BuildManager.build
(BuildManager.java:267)
	at org.eclipse.core.internal.resources.Project.build(Project.java:85)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.buildProject
(BatchExtension.java:561)
	at 
com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.internalJarProcess
(BatchExtension.java:525)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.runJarDeploy
(BatchExtension.java:429)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.access$1
(BatchExtension.java:394)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension$RunDeploy.run
(BatchExtension.java:245)
	at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1588)
	at 
com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension$RunDeploy.execute
(BatchExtension.java:227)
	at com.ibm.etools.ejbdeploy.batch.plugin.BatchExtension.run
(BatchExtension.java:190)
	at java.lang.reflect.Method.invoke(Native Method)
	at com.ibm.etools.ejbdeploy.batch.impl.BootLoaderLoader.run
(BootLoaderLoader.java:255)
	at com.ibm.etools.ejbdeploy.batch.impl.BatchDeploy.execute
(BatchDeploy.java:133)
	at com.ibm.etools.ejbdeploy.EJBDeploy.execute(EJBDeploy.java:82)
	at com.ibm.etools.ejbdeploy.EJBDeploy.main(EJBDeploy.java:309)
	at com.ibm.etools.ejbdeploy.batch.impl.Test.run(Test.java:63)
	at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
	at org.eclipse.core.boot.BootLoader.run(BootLoader.java:431)
	at EclipseRuntimeLauncher.main(EclipseRuntimeLauncher.java:24)
EJBDeploy level: 20030319_2000-WB210-AD-V51D-W2
Leonard - a testcase would be much appreciated.
I don't think we would have directly addressed a NPE since then in this area.
Which VM are you using?
IBM JDK1.3.1 SR2?
- Using IBM JRE 1.3.1 SR2
- This problem does not occur when JIT is disabled

Thanks, closing then as JIT bug.
Reopen to workaround


*** This bug has been marked as a duplicate of 35731 ***</WithStack>
    <WithOutStack>When deploying EJB and the builder is invoked on the generated code, the 
compiler throws a NPE (trace is below).  Please contact Leonard Theivendra at 
theivend@ca.ibm.com for a testcase.

The eclipse driver used in this build of IBM Websphere Studio is based on the 
Eclipse RC1 build.  I realize this will be hard for you to reproduce given that 
you don't have our plugins, runtimes, etc.  Hopefully the following stack trace 
helps, if it does not, please contact me and I will attempt to put together a 
simple .java source file that reproduced this compiler NPE.

Trace from our tool:

  (Found: 1 error, 2 warnings) Compiling 239586.jar/ejbModule/stinh/ejb11
  (Found: 1 error, 2 warnings) Build done
  Invoking Validation on /239586.jar.
  Invoking Library Copying Builder on /239586.jar.
  Updating.
[*Error] An unexpected exception was thrown.  Halting execution.
Shutting down workbench.

An error occurred while compiling the .java code. Correct the code, and try 
again.

EJBDeploy level: 20030319_2000-WB210-AD-V51D-W2
Leonard - a testcase would be much appreciated.
I don't think we would have directly addressed a NPE since then in this area.
Which VM are you using?
IBM JDK1.3.1 SR2?
- Using IBM JRE 1.3.1 SR2
- This problem does not occur when JIT is disabled

Thanks, closing then as JIT bug.
Reopen to workaround


*** This bug has been marked as a duplicate of 35731 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35477" />
    <CreationDate amount="2003-03-21 10:57:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="minor" />
    <Summery>Typo in plugin.xml of org.eclipse.team.core</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build: 2.1 RC3a

The plugin.xml of team.core contains:

&lt;extension point="org.eclipse.core.resources.moveDeleteHook" id="MoveDeleteHook"&gt;
	&lt;moveDeleteHook class="org.eclipse.team.internal.core.MoveDeleteManager"/&gt;
&lt;/extension&gt;

&lt;extension point="org.eclipse.core.resources.teamHook" id="TeamHook"&gt;
	&lt;moveDeleteHook class="org.eclipse.team.internal.core.TeamHookDispatcher"/&gt;
&lt;/extension&gt;

Notice the cut and paste typo in the teamHook extension.  It defines a
"moveDeleteHook" element rather than a "teamHook" element.

Luckily, we don't check this name when we instantiate the extension.  However,
the PDE manifest build flags this as a warning since it doesn't match the schema.
Fixed in RC4.
Really fixed now.</WithStack>
    <WithOutStack>Build: 2.1 RC3a

The plugin.xml of team.core contains:

&lt;extension point="org.eclipse.core.resources.moveDeleteHook" id="MoveDeleteHook"&gt;
	&lt;moveDeleteHook class="org.eclipse.team.internal.core.MoveDeleteManager"/&gt;
&lt;/extension&gt;

&lt;extension point="org.eclipse.core.resources.teamHook" id="TeamHook"&gt;
	&lt;moveDeleteHook class="org.eclipse.team.internal.core.TeamHookDispatcher"/&gt;
&lt;/extension&gt;

Notice the cut and paste typo in the teamHook extension.  It defines a
"moveDeleteHook" element rather than a "teamHook" element.

Luckily, we don't check this name when we instantiate the extension.  However,
the PDE manifest build flags this as a warning since it doesn't match the schema.
Fixed in RC4.
Really fixed now.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35478" />
    <CreationDate amount="2003-03-21 11:04:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>Replace ConvertLineDelimitersAction.DummyMonitor with NullProgressMonitor</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build I20030321

Replace ConvertLineDelimitersAction.DummyMonitor with NullProgressMonitor

Note: After 2.1
Available in builds &gt; N20030509</WithStack>
    <WithOutStack>Build I20030321

Replace ConvertLineDelimitersAction.DummyMonitor with NullProgressMonitor

Note: After 2.1
Available in builds &gt; N20030509</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35479" />
    <CreationDate amount="2003-03-21 11:05:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="minor" />
    <Summery>[Schema] Illegal attributes in extension definitions [general issue]</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>Build: 2.1 RC3a

If I checkout JDT projects as source from the repository, there are a number of
errors reported in the plugin.xml files:

org.eclipse.jdt.junit
 line 126: unknown attribute 'javatype'

org.eclipse.jdt.ui
 line 970: unknown attribute 'description'
 line 1015: unknown attribute 'description'
 line 225: unknown attribute 'javatype'
 line 234: unknown attribute 'javatype'
javatype: this is correct. It is an additional attribute we add to workbench 
schema.

description: not needed and should be removed.


Not critical since the reported problems are warnings. The javatype attribute 
raises a new issue:

The schema for wizards is defined in Platform/UI. JDT/UI adds an attribute to 
the element (which is legal), but can't define a new schema for it. Have to 
check after 2.1 what to do here 
Fixed the description error. Regarding the javatype: afaik it is allowed to 
add additional attributes to an extension point. Moving to PDE for commenting 
if there is something we can do in the schema file to handle this case.
Move to PDE UI
I am afraid I don't understand what you do. You add attributes that are not 
part of the original wizard schema and somehow use them in JDT UI? Can you 
explain?
JDT/UI are good plugin.xml citizens now.  They no longer add their own 
attributes to extensions.  They use the class ref format to specify classes 
and pass additional parameters.</WithStack>
    <WithOutStack>Build: 2.1 RC3a

If I checkout JDT projects as source from the repository, there are a number of
errors reported in the plugin.xml files:

org.eclipse.jdt.junit
 line 126: unknown attribute 'javatype'

org.eclipse.jdt.ui
 line 970: unknown attribute 'description'
 line 1015: unknown attribute 'description'
 line 225: unknown attribute 'javatype'
 line 234: unknown attribute 'javatype'
javatype: this is correct. It is an additional attribute we add to workbench 
schema.

description: not needed and should be removed.


Not critical since the reported problems are warnings. The javatype attribute 
raises a new issue:

The schema for wizards is defined in Platform/UI. JDT/UI adds an attribute to 
the element (which is legal), but can't define a new schema for it. Have to 
check after 2.1 what to do here 
Fixed the description error. Regarding the javatype: afaik it is allowed to 
add additional attributes to an extension point. Moving to PDE for commenting 
if there is something we can do in the schema file to handle this case.
Move to PDE UI
I am afraid I don't understand what you do. You add attributes that are not 
part of the original wizard schema and somehow use them in JDT UI? Can you 
explain?
JDT/UI are good plugin.xml citizens now.  They no longer add their own 
attributes to extensions.  They use the class ref format to specify classes 
and pass additional parameters.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35480" />
    <CreationDate amount="2003-03-21 11:08:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Text" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="major" />
    <Summery>IllegalArgumentException pressing the HOME key</Summery>
    <Patches amount="0" />
    <Stacktraces amount="1">
      <Stacktrace timestamp="1437340488207">
        <Exception>java.lang.IllegalArgumentException</Exception>
        <Reason>Index out of bounds</Reason>
        <Frames>
          <Frame depth="0">org.eclipse.swt.SWT.error(SWT.java:2306)</Frame>
          <Frame depth="1">org.eclipse.swt.SWT.error(SWT.java:2250)</Frame>
          <Frame depth="2">org.eclipse.swt.custom.StyledText.getText(StyledText.java:4561)</Frame>
          <Frame depth="3">org.eclipse.ui.texteditor.AbstractTextEditor$LineStartAction.run(AbstractTextEditor.java:967)</Frame>
          <Frame depth="4">org.eclipse.ui.texteditor.AbstractTextEditor$ActivationCodeTrigger.verifyKey(AbstractTextEditor.java:545)</Frame>
          <Frame depth="5">org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:368)</Frame>
          <Frame depth="6">org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:55)</Frame>
          <Frame depth="7">org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java(Compiled Code))</Frame>
          <Frame depth="8">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java(Compiled Code))</Frame>
          <Frame depth="9">org.eclipse.swt.widgets.Widget.sendEvent(Widget.java(Compiled Code))</Frame>
          <Frame depth="10">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java(Compiled Code))</Frame>
          <Frame depth="11">org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java(Compiled Code))</Frame>
          <Frame depth="12">org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:5215)</Frame>
          <Frame depth="13">org.eclipse.swt.custom.StyledText$8.handleEvent(StyledText.java:4964)</Frame>
          <Frame depth="14">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))</Frame>
          <Frame depth="15">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))</Frame>
          <Frame depth="16">org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java(Compiled Code))</Frame>
          <Frame depth="17">org.eclipse.swt.widgets.Display.readAndDispatch(Display.java(Compiled Code))</Frame>
          <Frame depth="18">org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java(Compiled Code))</Frame>
          <Frame depth="19">org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)</Frame>
          <Frame depth="20">org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)</Frame>
          <Frame depth="21">org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)</Frame>
          <Frame depth="22">java.lang.reflect.Method.invoke(Native Method)</Frame>
          <Frame depth="23">org.eclipse.core.launcher.Main.basicRun(Main.java:291)</Frame>
          <Frame depth="24">org.eclipse.core.launcher.Main.run(Main.java:747)</Frame>
          <Frame depth="25">org.eclipse.core.launcher.Main.main(Main.java:583)</Frame>
        </Frames>
      </Stacktrace>
    </Stacktraces>
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="7">
        <Lines>
          <Line>1) Fresh Eclipse install</Line>
          <Line>2) Select the "show methods only" toolbar.</Line>
          <Line>3) Open the attached Java file in Eclipse.</Line>
          <Line>4) Select the bar method</Line>
          <Line>5) Position the cursor after the last } of the method</Line>
          <Line>6) Press HOME</Line>
          <Line>7) Nothing happens and we get an exception in the console</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Eclipse 2.1 RC3a

1) Fresh Eclipse install
2) Select the "show methods only" toolbar.
3) Open the attached Java file in Eclipse.
4) Select the bar method
5) Position the cursor after the last } of the method
6) Press HOME
7) Nothing happens and we get an exception in the console

!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 11:03:20.478
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 11:03:20.618
!MESSAGE Index out of bounds
!STACK 0
java.lang.IllegalArgumentException: Index out of bounds
        at org.eclipse.swt.SWT.error(SWT.java:2306)
        at org.eclipse.swt.SWT.error(SWT.java:2250)
        at org.eclipse.swt.custom.StyledText.getText(StyledText.java:4561)
        at org.eclipse.ui.texteditor.AbstractTextEditor$LineStartAction.run
(AbstractTextEditor.java:967)
        at 
org.eclipse.ui.texteditor.AbstractTextEditor$ActivationCodeTrigger.verifyKey
(AbstractTextEditor.java:545)
        at 
org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey
(TextViewer.java:368)
        at org.eclipse.swt.custom.StyledTextListener.handleEvent
(StyledTextListener.java:55)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java
(Compiled Code))
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java(Compiled Code))
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java(Compiled Code))
        at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java(Compiled 
Code))
        at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java(Compiled 
Code))
        at org.eclipse.swt.custom.StyledText.handleKeyDown
(StyledText.java:5215)
        at org.eclipse.swt.custom.StyledText$8.handleEvent
(StyledText.java:4964)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java
(Compiled Code))
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java
(Compiled Code))
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java
(Compiled Code))
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java
(Compiled Code))
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java
(Compiled Code))
        at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385)
        at org.eclipse.core.internal.boot.InternalBootLoader.run
(InternalBootLoader.java:845)
        at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
        at java.lang.reflect.Method.invoke(Native Method)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:291)
        at org.eclipse.core.launcher.Main.run(Main.java:747)
        at org.eclipse.core.launcher.Main.main(Main.java:583)
Index out of bounds
Created attachment 4287
java file example
The last line of bar has a whitespace behind the closing '}'. This is what is 
causing the problem with HOME. END suffers from the same problem.
Created attachment 4338
patch
+1
+1
+1
Reviewed and released to head. Marking as fixed. Will be reopened in case of 
veto within the next 24 hours.</WithStack>
    <WithOutStack>Eclipse 2.1 RC3a

1) Fresh Eclipse install
2) Select the "show methods only" toolbar.
3) Open the attached Java file in Eclipse.
4) Select the bar method
5) Position the cursor after the last } of the method
6) Press HOME
7) Nothing happens and we get an exception in the console

!ENTRY org.eclipse.ui 4 4 Mar 21, 2003 11:03:20.478
!MESSAGE Unhandled exception caught in event loop.
Unhandled exception caught in event loop.
Reason:
!ENTRY org.eclipse.ui 4 0 Mar 21, 2003 11:03:20.618
!MESSAGE Index out of bounds
!STACK 0

Index out of bounds
Created attachment 4287
java file example
The last line of bar has a whitespace behind the closing '}'. This is what is 
causing the problem with HOME. END suffers from the same problem.
Created attachment 4338
patch
+1
+1
+1
Reviewed and released to head. Marking as fixed. Will be reopened in case of 
veto within the next 24 hours.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35481" />
    <CreationDate amount="2003-03-21 11:19:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>constructor Image( ImageData ) ignores information</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="ifstatement">
        <location start="771" end="903" />
        <code>if (data.transparentPixel &gt;= 0) {
		ImageData maskData = data.getTransparencyMask();
		return new Image(device, data, maskData);
	}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>When calling new Image(null, imageData), the caller assumes that the new image 
will be constructed using all of the information contained in the ImageData 
construct.  This is not true however, and the JavaDoc is vague.

This constructor *only* uses the source information from the imagedata, and 
ignores the transparency information. Why? The workaround is to call new Image
(null, data, data.getTransparencyMask()).

This is like a constructor that takes a Point, and only looks at the x value 
even though the y value is very important.
As far as I know the constructor Image(device, imageData) also looks
at the transparency info of the image data. Please could you provide
a testcase showing your problem?
See JFace's ImageDescriptor class line 135 for the code:

	if (data.transparentPixel &gt;= 0) {
		ImageData maskData = data.getTransparencyMask();
		return new Image(device, data, maskData);
	}

If you change this to just use the data, without first extracting the mask, 
then you do not get transparency.  Try running a modified version of 
ImageDescriptor with Eclipse.
I believe this is done because some widgets (like Button) do not support
images with transparent pixel. They only support icons (transparency mask). 
GC.drawImage() will draw the image created with Image(Device, ImageData)
properly.
Thanks for the clarification. Maybe the limitations of windows 
Buttons/ToolItems, etc could be mentioned in the JavaDoc? Also, as a Java 
programmer, I don't really know the difference between an Image and an Icon, 
and even then, it's not obvious when SWT creates one versus the other when 
loading from a resource.</WithStack>
    <WithOutStack>When calling new Image(null, imageData), the caller assumes that the new image 
will be constructed using all of the information contained in the ImageData 
construct.  This is not true however, and the JavaDoc is vague.

This constructor *only* uses the source information from the imagedata, and 
ignores the transparency information. Why? The workaround is to call new Image
(null, data, data.getTransparencyMask()).

This is like a constructor that takes a Point, and only looks at the x value 
even though the y value is very important.
As far as I know the constructor Image(device, imageData) also looks
at the transparency info of the image data. Please could you provide
a testcase showing your problem?
See JFace's ImageDescriptor class line 135 for the code:

	if (data.transparentPixel &gt;= 0) {
		ImageData maskData = data.getTransparencyMask();
		return new Image(device, data, maskData);
	}

If you change this to just use the data, without first extracting the mask, 
then you do not get transparency.  Try running a modified version of 
ImageDescriptor with Eclipse.
I believe this is done because some widgets (like Button) do not support
images with transparent pixel. They only support icons (transparency mask). 
GC.drawImage() will draw the image created with Image(Device, ImageData)
properly.
Thanks for the clarification. Maybe the limitations of windows 
Buttons/ToolItems, etc could be mentioned in the JavaDoc? Also, as a Java 
programmer, I don't really know the difference between an Image and an Icon, 
and even then, it's not obvious when SWT creates one versus the other when 
loading from a resource.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35482" />
    <CreationDate amount="2003-03-21 11:22:00 -0500" />
    <DupId amount="35515" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>CVS Problem "Malformed entry line:"</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>We are getting a few installations which are seeing this problem on any updates
or checkouts.  It shouldn't be the cvs server because some other installations
are working as well as our wincvs stuff.  In the cvs perspective you can still
refresh tree and browse around.  In the cvs console you don't see anything come
up.  No errors show up in the eclipse log.
Please read the dup PR and follow the steps to fix your workspaces. Re-open if
you can't resolve.

*** This bug has been marked as a duplicate of 35515 ***</WithStack>
    <WithOutStack>We are getting a few installations which are seeing this problem on any updates
or checkouts.  It shouldn't be the cvs server because some other installations
are working as well as our wincvs stuff.  In the cvs perspective you can still
refresh tree and browse around.  In the cvs console you don't see anything come
up.  No errors show up in the eclipse log.
Please read the dup PR and follow the steps to fix your workspaces. Re-open if
you can't resolve.

*** This bug has been marked as a duplicate of 35515 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35483" />
    <CreationDate amount="2003-03-21 11:27:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>cvs updates not updating correct folder after update on individual file</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WORKSFORME" />
    <WithStack>In the package explorer, after updating a single file, another update on any
folder will re-update the file that was originally updated.  Using a second
individual file will work just fine, but again, folders after that don't seem to
refresh the update location.  This is validated by watching the cvs console.
Your problem report is a bit vague. I don't see any strange behavior using 
Team&gt;Update. If you still see strange behavior, please reopen with specific 
steps to reproduce. Including the console output would be helpful as well.</WithStack>
    <WithOutStack>In the package explorer, after updating a single file, another update on any
folder will re-update the file that was originally updated.  Using a second
individual file will work just fine, but again, folders after that don't seem to
refresh the update location.  This is validated by watching the cvs console.
Your problem report is a bit vague. I don't see any strange behavior using 
Team&gt;Update. If you still see strange behavior, please reopen with specific 
steps to reproduce. Including the console output would be helpful as well.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35484" />
    <CreationDate amount="2003-03-21 11:36:00 -0500" />
    <DupId amount="13460" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Team" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>Tag ordering issue</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Build RC3a

I have always been annoyed by the fact that version tags are sorted 
alphabetically most time I have to pick one (e.g. compare with different 
version).

However I noticed than in the CVS explorer view, when expanding versions of a 
project, the ordering of the versions is chronological, which is exactly what I 
would expect it to be in all cases I have to pick any.

So, why isn't it consistently using the chronological order when displaying a 
list of version tags ?
Version tags should always be sorted in reverse alphebetical order and branch 
tags should be sorted in alphebetical order (there is no gauranteed way to get 
the actual time a tag was created so tags are not sorted chronologically). I 
have done a quick check and this is the case everywhere I looked. If you know 
of a particular place where this is not the case, please reopen stating the 
exact location (view, dialog, etc).
Look at org.eclipse.jdt.core in CVS explorer, under 
Versions/org.eclipse.jdt.core,
you'll see that v_312 is the last one listed. OK

Now open editor on IJavaProject, then show it in CVS resource history. You'll 
notice that v_312 is listed last again. OK

Now try to tag it with existing version name, expand Versions subtree, and 
you'll see that v_312 isn't the first available candidate.
I see the problem. In CVS, tags are kept on files only. Therefore, you need a 
file to get the tags. For projects (and folders in the project), we use 
the .project file of the project (this is a default that can be configured). 
For files, we actually get the tags directly off the file. The problem is that 
the IJavaProject file has more tags on it then the project's .project file so 
you are actually seeing all the tags on the file from the beginning of it's 
life and some of these are after v_312 alphebetically (so appear before v_312).
I think what we really need here is a mechanism for filtering tags (see bug 
13460). It may even be possible to filter by date (given a file that is 
modified regularly). 

If you are satisfied with the above, let me know and I will mark this as a 
duplicate of bug 13460 and annotate that bug with a request to investigate 
filtering tags by date.
I see now. Filtering would indeed be a good idea.


*** This bug has been marked as a duplicate of 13460 ***</WithStack>
    <WithOutStack>Build RC3a

I have always been annoyed by the fact that version tags are sorted 
alphabetically most time I have to pick one (e.g. compare with different 
version).

However I noticed than in the CVS explorer view, when expanding versions of a 
project, the ordering of the versions is chronological, which is exactly what I 
would expect it to be in all cases I have to pick any.

So, why isn't it consistently using the chronological order when displaying a 
list of version tags ?
Version tags should always be sorted in reverse alphebetical order and branch 
tags should be sorted in alphebetical order (there is no gauranteed way to get 
the actual time a tag was created so tags are not sorted chronologically). I 
have done a quick check and this is the case everywhere I looked. If you know 
of a particular place where this is not the case, please reopen stating the 
exact location (view, dialog, etc).
Look at org.eclipse.jdt.core in CVS explorer, under 
Versions/org.eclipse.jdt.core,
you'll see that v_312 is the last one listed. OK

Now open editor on IJavaProject, then show it in CVS resource history. You'll 
notice that v_312 is listed last again. OK

Now try to tag it with existing version name, expand Versions subtree, and 
you'll see that v_312 isn't the first available candidate.
I see the problem. In CVS, tags are kept on files only. Therefore, you need a 
file to get the tags. For projects (and folders in the project), we use 
the .project file of the project (this is a default that can be configured). 
For files, we actually get the tags directly off the file. The problem is that 
the IJavaProject file has more tags on it then the project's .project file so 
you are actually seeing all the tags on the file from the beginning of it's 
life and some of these are after v_312 alphebetically (so appear before v_312).
I think what we really need here is a mechanism for filtering tags (see bug 
13460). It may even be possible to filter by date (given a file that is 
modified regularly). 

If you are satisfied with the above, let me know and I will mark this as a 
duplicate of bug 13460 and annotate that bug with a request to investigate 
filtering tags by date.
I see now. Filtering would indeed be a good idea.


*** This bug has been marked as a duplicate of 13460 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35485" />
    <CreationDate amount="2003-03-21 11:38:00 -0500" />
    <DupId amount="30842" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="User Assistance" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Help Preference Page should use Radio Buttons</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>RC3

The buttons in the Help Preference page have radio behaviour but are check 
boxes. They should be radio buttons.
This was done because the SWT table only supported the checkbox style.
A different (customized) widget should be used instead, but the fix will be 
done in the next release.

*** This bug has been marked as a duplicate of 30842 ***</WithStack>
    <WithOutStack>RC3

The buttons in the Help Preference page have radio behaviour but are check 
boxes. They should be radio buttons.
This was done because the SWT table only supported the checkbox style.
A different (customized) widget should be used instead, but the fix will be 
done in the next release.

*** This bug has been marked as a duplicate of 30842 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35486" />
    <CreationDate amount="2003-03-21 11:42:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="All" />
    <op_sys amount="All" />
    <priority amount="P3" />
    <bug_severity amount="enhancement" />
    <Summery>[Working Sets] Enhancements for Working Sets</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="3">
      <Enumeration lines="20">
        <Lines>
          <Line>1. duplicate of bug 15938</Line>
          <Line>2. duplicate of bug 15941</Line>
          <Line>3. should use filters for this, see bug 30578</Line>
          <Line>4. a sort of working set hierarchy was suggested before, in bug 22493. What</Line>
          <Line>kind of hierarchy do you envision? Do you have a use case for this feature? I'm</Line>
          <Line>skeptical as nested working sets sound complicated.</Line>
          <Line>Chris, please read bug 37389 and comment whether that is the kind of working</Line>
          <Line>set hierarchy you have in mind (i.e., nested working sets). I would like to</Line>
          <Line>mark this bug as a duplicate of bug 37389 if this is indeed what you want.</Line>
          <Line>email exchange from 5/16:</Line>
          <Line>Chris: "Bug 35486 is really about integration with file operations in general.</Line>
          <Line>Hierarchical orgnaization is indeed covered well by 37389, but I think that's a</Line>
          <Line>separate issue."</Line>
          <Line>Knut: "Right, I think the file/resource interactions are adequately captured in</Line>
          <Line>the other bugs I mention. If I'm wrong and you have other concerns/suggestions</Line>
          <Line>please describe them in more detail in the bug."</Line>
          <Line />
          <Line>Closing this bug. The concerns are documented in bug 15938, bug 15941 and bug</Line>
          <Line>37389. Please open specific bugs if you find other areas where working sets</Line>
          <Line>could be better integrated with resource (e.g., file) operations.</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="2">
        <Lines>
          <Line>- When a file is renamed, updated any Working Sets that reference it</Line>
          <Line>- When a file is created, offer prompt to add it to existing Working Set(s)</Line>
        </Lines>
      </Enumeration>
      <Enumeration lines="18">
        <Lines>
          <Line>- Provide a filter field in Edit Working Set (eg, *Test)</Line>
          <Line>- Allow hierarchies of Working Sets (ambitious?)</Line>
          <Line>1. duplicate of bug 15938</Line>
          <Line>2. duplicate of bug 15941</Line>
          <Line>3. should use filters for this, see bug 30578</Line>
          <Line>4. a sort of working set hierarchy was suggested before, in bug 22493. What</Line>
          <Line>kind of hierarchy do you envision? Do you have a use case for this feature? I'm</Line>
          <Line>skeptical as nested working sets sound complicated.</Line>
          <Line>Chris, please read bug 37389 and comment whether that is the kind of working</Line>
          <Line>set hierarchy you have in mind (i.e., nested working sets). I would like to</Line>
          <Line>mark this bug as a duplicate of bug 37389 if this is indeed what you want.</Line>
          <Line>email exchange from 5/16:</Line>
          <Line>Chris: "Bug 35486 is really about integration with file operations in general.</Line>
          <Line>Hierarchical orgnaization is indeed covered well by 37389, but I think that's a</Line>
          <Line>separate issue."</Line>
          <Line>Knut: "Right, I think the file/resource interactions are adequately captured in</Line>
          <Line>the other bugs I mention. If I'm wrong and you have other concerns/suggestions</Line>
          <Line>please describe them in more detail in the bug."</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="INVALID" />
    <WithStack>Provide integration with operations that deal with resources. For example:
- When a file is renamed, updated any Working Sets that reference it
- When a file is created, offer prompt to add it to existing Working Set(s)

Other:
- Provide a filter field in Edit Working Set (eg, *Test)
- Allow hierarchies of Working Sets (ambitious?)
1. duplicate of bug 15938
2. duplicate of bug 15941
3. should use filters for this, see bug 30578
4. a sort of working set hierarchy was suggested before, in bug 22493. What 
kind of hierarchy do you envision? Do you have a use case for this feature? I'm 
skeptical as nested working sets sound complicated.
Chris, please read bug 37389 and comment whether that is the kind of working 
set hierarchy you have in mind (i.e., nested working sets). I would like to 
mark this bug as a duplicate of bug 37389 if this is indeed what you want.
email exchange from 5/16:
Chris: "Bug 35486 is really about integration with file operations in general. 
Hierarchical orgnaization is indeed covered well by 37389, but I think that's a 
separate issue."
Knut: "Right, I think the file/resource interactions are adequately captured in 
the other bugs I mention. If I'm wrong and you have other concerns/suggestions 
please describe them in more detail in the bug."

Closing this bug. The concerns are documented in bug 15938, bug 15941 and bug 
37389. Please open specific bugs if you find other areas where working sets 
could be better integrated with resource (e.g., file) operations.</WithStack>
    <WithOutStack>Provide integration with operations that deal with resources. For example:
- When a file is renamed, updated any Working Sets that reference it
- When a file is created, offer prompt to add it to existing Working Set(s)

Other:
- Provide a filter field in Edit Working Set (eg, *Test)
- Allow hierarchies of Working Sets (ambitious?)
1. duplicate of bug 15938
2. duplicate of bug 15941
3. should use filters for this, see bug 30578
4. a sort of working set hierarchy was suggested before, in bug 22493. What 
kind of hierarchy do you envision? Do you have a use case for this feature? I'm 
skeptical as nested working sets sound complicated.
Chris, please read bug 37389 and comment whether that is the kind of working 
set hierarchy you have in mind (i.e., nested working sets). I would like to 
mark this bug as a duplicate of bug 37389 if this is indeed what you want.
email exchange from 5/16:
Chris: "Bug 35486 is really about integration with file operations in general. 
Hierarchical orgnaization is indeed covered well by 37389, but I think that's a 
separate issue."
Knut: "Right, I think the file/resource interactions are adequately captured in 
the other bugs I mention. If I'm wrong and you have other concerns/suggestions 
please describe them in more detail in the bug."

Closing this bug. The concerns are documented in bug 15938, bug 15941 and bug 
37389. Please open specific bugs if you find other areas where working sets 
could be better integrated with resource (e.g., file) operations.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35487" />
    <CreationDate amount="2003-03-21 11:47:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-Motif" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Clipped message in refactoring dialog</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Build: 2.1 RC3a

The refactor &gt; change method signature refactoring opens a dialog where
parameter ordering is specified, etc.

On Linux Motif, the message at the bottom is clipped to be only a couple of
pixels high.  It is impossible to read.  From Windows, I can see this message
says, "Specify the new order of parameters and/or their new names".
Have to investigate under Linux what is going on. 
Message isn't clipped under Linux-GTK and Windows. However fix is easy and we 
should put it in for RC4 since all refactoring dialogs are affected under Linux-Motif. 
 
Problem is that height under Motif of a test containing the text ("\n\n") isn't computed 
correctly. It is when using " \n "; 
Created attachment 4310
Patch that fixes the problem
Risk of fix is low
If we don't fix this for 2.1 error messages in the refactoring wizard aren't 
readable under Motif.
+1
Tested it under MacOS as well and Mac shows the same error as Motif (the error 
message isn't readable at all). The proposed fix fixes the problem under Mac 
as well.
Fixed reviewed by Andre Weinand and approved 
+1
Fixed reviewed by Martin Aeschlimann. 
Fixed released for RC4 
+1</WithStack>
    <WithOutStack>Build: 2.1 RC3a

The refactor &gt; change method signature refactoring opens a dialog where
parameter ordering is specified, etc.

On Linux Motif, the message at the bottom is clipped to be only a couple of
pixels high.  It is impossible to read.  From Windows, I can see this message
says, "Specify the new order of parameters and/or their new names".
Have to investigate under Linux what is going on. 
Message isn't clipped under Linux-GTK and Windows. However fix is easy and we 
should put it in for RC4 since all refactoring dialogs are affected under Linux-Motif. 
 
Problem is that height under Motif of a test containing the text ("\n\n") isn't computed 
correctly. It is when using " \n "; 
Created attachment 4310
Patch that fixes the problem
Risk of fix is low
If we don't fix this for 2.1 error messages in the refactoring wizard aren't 
readable under Motif.
+1
Tested it under MacOS as well and Mac shows the same error as Motif (the error 
message isn't readable at all). The proposed fix fixes the problem under Mac 
as well.
Fixed reviewed by Andre Weinand and approved 
+1
Fixed reviewed by Martin Aeschlimann. 
Fixed released for RC4 
+1</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35488" />
    <CreationDate amount="2003-03-21 11:50:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="PDE" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Could not create workspace</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="7">
        <Lines>
          <Line>1) Launch External Plugins Import wizard</Line>
          <Line>2) Accept defaults on the first page</Line>
          <Line>3) In the second page, select JDT Core, add dependent plug-ins, then decline to</Line>
          <Line>override JDT COre itself when asked (you want to keep JDT COre in source form).</Line>
          <Line>4) Go to Target Platform and press 'not in workspace' button to fill in the gap</Line>
          <Line>(the rest of the product that is not in the workspace)</Line>
          <Line>OK.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>RC3a build.

What am I doing wrong?

I started a new empty workspace on the RC3a build and selected every plugin 
except jdt.core from the Target Platform page.

Then I added jdt.core from our repository.

It failed to build because it cannot find any of the required projects even 
though they're visible in the plugins view of the PDE perspective.

What am I missing?
JDT Core in repository has the classpath that requires all other dependent plug-
ins to be in the workspace as well. You have chosen to work against external 
plug-ins.

In order to compile, you need to import binary projects from the JDT Core 
dependency list. To so:

1) Launch External Plugins Import wizard
2) Accept defaults on the first page
3) In the second page, select JDT Core, add dependent plug-ins, then decline to 
override JDT COre itself when asked (you want to keep JDT COre in source form).
4) Go to Target Platform and press 'not in workspace' button to fill in the gap 
(the rest of the product that is not in the workspace)
OK.

But I find the message at the top of the Target Platform page to be very 
confusing. It reads: 'When compiling against these plug-ins, their libraries 
will appear as external JARS in the classpath.'

How is the novice user supposed to know when this applies &amp; when it doesn't?
Novice users don't check out projects from the CVS repository.
Start with a clean workspace and create 'Hello, World' plug-in using PDE 
project wizard. You will see that a novice will not have to even know about the 
target platform.

The moment you get into CVS repository, shared projects etc. you must stop 
being novice. In this particular instance, you tried to check out a project 
from a team that collectively uses binary projects for self-hosting. In order 
to compile, you must as well.

If you want to be compatible with other Eclipse developers, do the following:

1) Check out projects from CVS you want to see in source
2) Launch import wizard, then in the second page select 'Existing projects' 
then 'Invert selection'. This will import all the external plug-ins as binary 
projects into your workspace. This is how all of us work and you will see
all the compile errors go away (unfortunately, not with RC3a which has 
a stop-ship defect with importing :-).
But I thought the whole point was to let me build larger workspaces?

How is adding every plug-in in the world as a binary project going to get me 
there?

I've talked to several people about what they think the 3 lines of text mean on 
the Target Platform page and EVERYONE of them expects to do what I did.

You should really consider rewriting the 3 lines.
I didn't say that you need to add everything into the workspace. I simply said 
that JDT Core belongs to a team that uses binary projects for selfhosting. You 
cannot use their .classpath as-is and expect to compile if you don't set up 
your workspace as they do.

Indeed, large product teams have very few projects in their workspace. However, 
those that are in the repository are set up for this selfhosting mode and have 
external JARs in their .classpath file, not project references.
Lowering severity...
Kent,
what do you suggest the three lines should read?
These issues have long been resolved.</WithStack>
    <WithOutStack>RC3a build.

What am I doing wrong?

I started a new empty workspace on the RC3a build and selected every plugin 
except jdt.core from the Target Platform page.

Then I added jdt.core from our repository.

It failed to build because it cannot find any of the required projects even 
though they're visible in the plugins view of the PDE perspective.

What am I missing?
JDT Core in repository has the classpath that requires all other dependent plug-
ins to be in the workspace as well. You have chosen to work against external 
plug-ins.

In order to compile, you need to import binary projects from the JDT Core 
dependency list. To so:

1) Launch External Plugins Import wizard
2) Accept defaults on the first page
3) In the second page, select JDT Core, add dependent plug-ins, then decline to 
override JDT COre itself when asked (you want to keep JDT COre in source form).
4) Go to Target Platform and press 'not in workspace' button to fill in the gap 
(the rest of the product that is not in the workspace)
OK.

But I find the message at the top of the Target Platform page to be very 
confusing. It reads: 'When compiling against these plug-ins, their libraries 
will appear as external JARS in the classpath.'

How is the novice user supposed to know when this applies &amp; when it doesn't?
Novice users don't check out projects from the CVS repository.
Start with a clean workspace and create 'Hello, World' plug-in using PDE 
project wizard. You will see that a novice will not have to even know about the 
target platform.

The moment you get into CVS repository, shared projects etc. you must stop 
being novice. In this particular instance, you tried to check out a project 
from a team that collectively uses binary projects for self-hosting. In order 
to compile, you must as well.

If you want to be compatible with other Eclipse developers, do the following:

1) Check out projects from CVS you want to see in source
2) Launch import wizard, then in the second page select 'Existing projects' 
then 'Invert selection'. This will import all the external plug-ins as binary 
projects into your workspace. This is how all of us work and you will see
all the compile errors go away (unfortunately, not with RC3a which has 
a stop-ship defect with importing :-).
But I thought the whole point was to let me build larger workspaces?

How is adding every plug-in in the world as a binary project going to get me 
there?

I've talked to several people about what they think the 3 lines of text mean on 
the Target Platform page and EVERYONE of them expects to do what I did.

You should really consider rewriting the 3 lines.
I didn't say that you need to add everything into the workspace. I simply said 
that JDT Core belongs to a team that uses binary projects for selfhosting. You 
cannot use their .classpath as-is and expect to compile if you don't set up 
your workspace as they do.

Indeed, large product teams have very few projects in their workspace. However, 
those that are in the repository are set up for this selfhosting mode and have 
external JARs in their .classpath file, not project references.
Lowering severity...
Kent,
what do you suggest the three lines should read?
These issues have long been resolved.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35489" />
    <CreationDate amount="2003-03-21 11:53:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Resources" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="trivial" />
    <Summery>typo in AdapterManager class comment</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>interaces should be interfaces 

&lt;li&gt;a depth-first traversal of the target class's interaces in the order
Released.</WithStack>
    <WithOutStack>interaces should be interfaces 

&lt;li&gt;a depth-first traversal of the target class's interaces in the order
Released.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35490" />
    <CreationDate amount="2003-03-21 11:56:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="Core" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows 2000" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Search doesn't work for reference of 'cursorLocation'</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="7">
        <Lines>
          <Line>1) create a fresh workspace</Line>
          <Line>2) import jdtcore as source and required projects as binary</Line>
          <Line>3) open 'CompletionParser'</Line>
          <Line>4) open 'dietParse()' method</Line>
          <Line>5) select 'cursorLocation' in 'completionScanner.cursorLocation =</Line>
          <Line>cursorLocation;'</Line>
          <Line>6) search reference in workspace</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>1) create a fresh workspace
2) import jdtcore as source and required projects as binary
3) open 'CompletionParser'
4) open 'dietParse()' method
5) select 'cursorLocation' in 'completionScanner.cursorLocation = 
cursorLocation;'
6) search reference in workspace

Only two references are found. All the references in CompletionScanner are not 
found.
Fix is trivial and only affects SearchEngine.
Created attachment 4288
CharOperation patch
Actually, it only occurs if block first entry is a prefix of the search key.
Not frequent scenario, removing RC4 tag.
Defer
Reopening
Fixed
Backported to 2.1 maintenance stream.
Fixed in 2.2 stream as well.
Verified.
Verified. for 3.0M1.</WithStack>
    <WithOutStack>1) create a fresh workspace
2) import jdtcore as source and required projects as binary
3) open 'CompletionParser'
4) open 'dietParse()' method
5) select 'cursorLocation' in 'completionScanner.cursorLocation = 
cursorLocation;'
6) search reference in workspace

Only two references are found. All the references in CompletionScanner are not 
found.
Fix is trivial and only affects SearchEngine.
Created attachment 4288
CharOperation patch
Actually, it only occurs if block first entry is a prefix of the search key.
Not frequent scenario, removing RC4 tag.
Defer
Reopening
Fixed
Backported to 2.1 maintenance stream.
Fixed in 2.2 stream as well.
Verified.
Verified. for 3.0M1.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35491" />
    <CreationDate amount="2003-03-21 11:57:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="User Assistance" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P4" />
    <bug_severity amount="normal" />
    <Summery>Mozilla 1.1:  Repaint problems when resizing help navigation views</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Open help, do a search, resize the help view, synchronize.
The Contents view is partially not painted correctly.
Problem exists on only on Suse, but also on RedHat.  The Mozilla version with 
the problem is 1.0.1 (Also Netscape 6.23, 7, 7.01).
The problem does not occur using Mozilla 1.2.1 (one is shipped with RedHat 9).
Mozilla 1.1 has problem too.  1.2.1 is the lowest version I tried that works.
Mozilla 1.1 can be consider an old version, especially in 2004 when Eclipse 
3.0 is scheduled.  RedHat 9 and Suse 8.2 already ship with Mozilla 1.2.1 that 
has the problem fixed, and there is no need to polute help code with 
workarounds for older browsers.</WithStack>
    <WithOutStack>Open help, do a search, resize the help view, synchronize.
The Contents view is partially not painted correctly.
Problem exists on only on Suse, but also on RedHat.  The Mozilla version with 
the problem is 1.0.1 (Also Netscape 6.23, 7, 7.01).
The problem does not occur using Mozilla 1.2.1 (one is shipped with RedHat 9).
Mozilla 1.1 has problem too.  1.2.1 is the lowest version I tried that works.
Mozilla 1.1 can be consider an old version, especially in 2004 when Eclipse 
3.0 is scheduled.  RedHat 9 and Suse 8.2 already ship with Mozilla 1.2.1 that 
has the problem fixed, and there is no need to polute help code with 
workarounds for older browsers.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35492" />
    <CreationDate amount="2003-03-21 12:05:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>[DND] Wrong Tracker positioning</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Eclipse RC3a.

When moving views that are positioned in a certain way, the tracker's 
rectangles will appear at completely wrong positions.

Start with a fresh RC3a.  Go to Java Browsing.  Create a project with a 
class.  Make some syntax errors and save.  The Tasks will be shown at the 
bottom.  Try moving the Tasks view.  The Tracker rectangle will be way above 
where the original view was, as well as well above the mouse.

I don't know if it is because the toDisplay/toControl is not happening against 
the right control (or against the right handle in a control), or it is a 
timing issue:  it behaves differently depending both on the sizing/positioning 
and on how fast I move the mouse (I remember at some problem we had a problem 
with event time vs. current time, in the piece that tells the X server "send 
me more mouse events").
The problem is that DragDetect isn't firing soon enough.  When UI receives the 
DragDetect event they do a display.getCursorControl(), but if you've moved the 
mouse off of the CLabel by this point then whatever you're hovering over is 
answered instead, which leads to a miscalculation of the Tracker's initial 
bounds.

UI's use of display.getCursorControl() is not valid since there's no guarantee 
that the pointer will be over the same widget for the whole duration of a 
DragDetect.  If a widget boundary is crossed within the drag detection 
threshold then this will always fail.  This problem can also happen on win32, 
by starting the mouse down at the very top of the CLabel and quickly dragging 
up.

UI should make use of the x and y in the DragDetect event instead.  
Unfortunately we don't currently fill this in, which probably explains the use 
of display.getCursorControl().  So this bug is dependent upon bug 43251 .

The x and y coordinates have been added to the Event objects signaling 
DragDetect, so now moving report to UI.

I did a quick experiment of changing the handleEvent method of PartDragDrop's 
dragControl to simply "isDragAllowed(new Point (event.x, event.y));" and got 
the desired results when self-hosting.  I'm not sure that this is the complete 
fix, but it demonstrates a nicer approach that can be used now that the x and y 
coordinates are being provided.

Stefan please mark as closed/fixed if you agree
This has been fixed in the new look stream.</WithStack>
    <WithOutStack>Eclipse RC3a.

When moving views that are positioned in a certain way, the tracker's 
rectangles will appear at completely wrong positions.

Start with a fresh RC3a.  Go to Java Browsing.  Create a project with a 
class.  Make some syntax errors and save.  The Tasks will be shown at the 
bottom.  Try moving the Tasks view.  The Tracker rectangle will be way above 
where the original view was, as well as well above the mouse.

I don't know if it is because the toDisplay/toControl is not happening against 
the right control (or against the right handle in a control), or it is a 
timing issue:  it behaves differently depending both on the sizing/positioning 
and on how fast I move the mouse (I remember at some problem we had a problem 
with event time vs. current time, in the piece that tells the X server "send 
me more mouse events").
The problem is that DragDetect isn't firing soon enough.  When UI receives the 
DragDetect event they do a display.getCursorControl(), but if you've moved the 
mouse off of the CLabel by this point then whatever you're hovering over is 
answered instead, which leads to a miscalculation of the Tracker's initial 
bounds.

UI's use of display.getCursorControl() is not valid since there's no guarantee 
that the pointer will be over the same widget for the whole duration of a 
DragDetect.  If a widget boundary is crossed within the drag detection 
threshold then this will always fail.  This problem can also happen on win32, 
by starting the mouse down at the very top of the CLabel and quickly dragging 
up.

UI should make use of the x and y in the DragDetect event instead.  
Unfortunately we don't currently fill this in, which probably explains the use 
of display.getCursorControl().  So this bug is dependent upon bug 43251 .

The x and y coordinates have been added to the Event objects signaling 
DragDetect, so now moving report to UI.

I did a quick experiment of changing the handleEvent method of PartDragDrop's 
dragControl to simply "isDragAllowed(new Point (event.x, event.y));" and got 
the desired results when self-hosting.  I'm not sure that this is the complete 
fix, but it demonstrates a nicer approach that can be used now that the x and y 
coordinates are being provided.

Stefan please mark as closed/fixed if you agree
This has been fixed in the new look stream.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35493" />
    <CreationDate amount="2003-03-21 12:18:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows All" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>OleClientSite hang</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="1">
      <source_code type="functiondef">
        <location start="68" end="762" />
        <code>public static void main(String[] args) {
       Display disp = new Display();
       Shell mainWnd = new Shell(disp);
       mainWnd.setText("OleTest");
       mainWnd.setLayout(new FillLayout());
       OleFrame frame = new OleFrame(mainWnd, SWT.BORDER);
       String progID = "Word.Document";
       OleClientSite fSite = new OleClientSite(frame, SWT.NONE, progID);
      // fSite.doVerb(OLE.OLEIVERB_SHOW); // call doVerb before shell is open 
and OK
       mainWnd.open();
       fSite.doVerb(OLE.OLEIVERB_SHOW); //call doVerb after shell is open and 
GP
       while (!mainWnd.isDisposed()) {
           if (!disp.readAndDispatch()) {
               disp.sleep();
           }
        }
}</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>I20030317

Calling SHOW on Word after shell is open causes a hang.

public static void main(String[] args) {
       Display disp = new Display();
       Shell mainWnd = new Shell(disp);
       mainWnd.setText("OleTest");
       mainWnd.setLayout(new FillLayout());
       OleFrame frame = new OleFrame(mainWnd, SWT.BORDER);
       String progID = "Word.Document";
       OleClientSite fSite = new OleClientSite(frame, SWT.NONE, progID);
      // fSite.doVerb(OLE.OLEIVERB_SHOW); // call doVerb before shell is open 
and OK
       mainWnd.open();
       fSite.doVerb(OLE.OLEIVERB_SHOW); //call doVerb after shell is open and 
GP
       while (!mainWnd.isDisposed()) {
           if (!disp.readAndDispatch()) {
               disp.sleep();
           }
        }
}
Veronika,

the attached mail seems to come from you, therefore I reply to you. I did
the steps you described below. The problems I've had with Eclipse 2.0.0
seem to be fixed with the swt update - so I'm partly happy! Partly because
the fix did not solve my WSAD 5 (Eclipse 2.0.2) problem... My WSAD5 has no
plugins/org.eclipse.swt.win32_2.0.0 directory, only a
plugins/org.eclipse.swt.win32_2.0.2 directory exists, because it's Eclipse
2.0.2...  I copied the 2 files into the plugins/org.eclipse.swt.win32_2.0.2
/ws/win32 and plugins/org.eclipse.swt.win32_2.0.2/os/win32/x86 directories
and restarted both my machine and WSAD. No effect, the memory problem still
occurs. Is there another fix for 2.0.2?

Thanks in advance!
Regards
Matthias Schneider
Please ignore the previous comment - I pasted it in the wrong bug report.
IOleDucomentSite does provide the scrollbars for Word but it is causing Word 
and other ole documents to fail in other places.  Many Ole documents just 
won't open and others freeze after a while.
Assessed as a bad problem by SWT and relatively low risk fix.  Approved for 
2.1.1.
Backed out the IOleDocumentSite interface support.</WithStack>
    <WithOutStack>I20030317

Calling SHOW on Word after shell is open causes a hang.

public static void main(String[] args) {
       Display disp = new Display();
       Shell mainWnd = new Shell(disp);
       mainWnd.setText("OleTest");
       mainWnd.setLayout(new FillLayout());
       OleFrame frame = new OleFrame(mainWnd, SWT.BORDER);
       String progID = "Word.Document";
       OleClientSite fSite = new OleClientSite(frame, SWT.NONE, progID);
      // fSite.doVerb(OLE.OLEIVERB_SHOW); // call doVerb before shell is open 
and OK
       mainWnd.open();
       fSite.doVerb(OLE.OLEIVERB_SHOW); //call doVerb after shell is open and 
GP
       while (!mainWnd.isDisposed()) {
           if (!disp.readAndDispatch()) {
               disp.sleep();
           }
        }
}
Veronika,

the attached mail seems to come from you, therefore I reply to you. I did
the steps you described below. The problems I've had with Eclipse 2.0.0
seem to be fixed with the swt update - so I'm partly happy! Partly because
the fix did not solve my WSAD 5 (Eclipse 2.0.2) problem... My WSAD5 has no
plugins/org.eclipse.swt.win32_2.0.0 directory, only a
plugins/org.eclipse.swt.win32_2.0.2 directory exists, because it's Eclipse
2.0.2...  I copied the 2 files into the plugins/org.eclipse.swt.win32_2.0.2
/ws/win32 and plugins/org.eclipse.swt.win32_2.0.2/os/win32/x86 directories
and restarted both my machine and WSAD. No effect, the memory problem still
occurs. Is there another fix for 2.0.2?

Thanks in advance!
Regards
Matthias Schneider
Please ignore the previous comment - I pasted it in the wrong bug report.
IOleDucomentSite does provide the scrollbars for Word but it is causing Word 
and other ole documents to fail in other places.  Many Ole documents just 
won't open and others freeze after a while.
Assessed as a bad problem by SWT and relatively low risk fix.  Approved for 
2.1.1.
Backed out the IOleDocumentSite interface support.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35494" />
    <CreationDate amount="2003-03-21 12:20:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>ControlExample - Table preferred size does not adjust width</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>RC3a
Run ControlExample, tab 'table'
Make sure 'Preferred' size is selected.

Change font size. The height of the table is correctly adjusted, the width is 
unchanged, regardless of the font size.
I guess we need to call pack on each of the columns when the font is changed.
Fixed &gt; 20031021.</WithStack>
    <WithOutStack>RC3a
Run ControlExample, tab 'table'
Make sure 'Preferred' size is selected.

Change font size. The height of the table is correctly adjusted, the width is 
unchanged, regardless of the font size.
I guess we need to call pack on each of the columns when the font is changed.
Fixed &gt; 20031021.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35495" />
    <CreationDate amount="2003-03-21 12:37:00 -0500" />
    <DupId amount="35156" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Cannot summon F1 help on KDE</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>Build 20030320
Linux-GTK
KDE 3.0.3

Pressing Ctrl+F1 to summon help in KDE doesn't work.
Someone just pointed out to me that the problem here is another instance of
our shortcuts conflicting with KDE's shortcuts. Ctrl+F1 is the key to switch
to KDE's first desktop.
On KDE, Help is not Ctrl F1 but I believe it is supposed to be F1.
On Gnome, help is Ctrl+F1.

By using the GTK call, hopefully we get the right thing according to the 
window manager.


*** This bug has been marked as a duplicate of 35156 ***
F1 doesn't summon help on KDE. Bug 35156 sounds like it's specific to the
Combo widget. This bug is that help doesn't work for anything at all in KDE.
Is this really a dup?</WithStack>
    <WithOutStack>Build 20030320
Linux-GTK
KDE 3.0.3

Pressing Ctrl+F1 to summon help in KDE doesn't work.
Someone just pointed out to me that the problem here is another instance of
our shortcuts conflicting with KDE's shortcuts. Ctrl+F1 is the key to switch
to KDE's first desktop.
On KDE, Help is not Ctrl F1 but I believe it is supposed to be F1.
On Gnome, help is Ctrl+F1.

By using the GTK call, hopefully we get the right thing according to the 
window manager.


*** This bug has been marked as a duplicate of 35156 ***
F1 doesn't summon help on KDE. Bug 35156 sounds like it's specific to the
Combo widget. This bug is that help doesn't work for anything at all in KDE.
Is this really a dup?</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35496" />
    <CreationDate amount="2003-03-21 12:46:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Setting font for Table headers does not work</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="4">
      <source_code type="functiondef">
        <location start="318" end="620" />
        <code>public void setFont (Font font) {
	checkWidget ();
	super.setFont (font);
	setScrollWidth ();
	/*
	* Bug in Windows.  Setting the font will cause the 
	* table area to be redrawn but not the column headers.
	* Fix is to force a redraw on the column headers.
	*/
        ... doing the native stuff ...
}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="720" end="854" />
        <code>void setFontDescription (int font) {
	OS.gtk_widget_modify_font (labelHandle, font);
	OS.gtk_widget_modify_font (imageHandle, font);
}</code>
      </source_code>
      <source_code type="functiondef">
        <location start="871" end="1103" />
        <code>void setFontDescription (int font) {
	super.setFontDescription (font);
	TableColumn[] cloumns = getColumns ();
	for (int i = 0; i &lt; cloumns.length; i++) {
		if (cloumns[i] != null) {
			cloumns[i].setFontDescription (font);
		}
	}
}</code>
      </source_code>
      <source_code type="functioncall">
        <location start="1156" end="1207" />
        <code>column.setFontDescription (getFontDescription ());</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Assigning a new font to a Table sets the new font for the rows within the table,
but leaves the Table headers as they are. It DOES work under Win32, though.

I looked in the SWT source code (for Win32) for tables setFont() method, and
found the following ...
Maybe something similiar needs to be done for GTK, too ?

public void setFont (Font font) {
	checkWidget ();
	super.setFont (font);
	setScrollWidth ();
	/*
	* Bug in Windows.  Setting the font will cause the 
	* table area to be redrawn but not the column headers.
	* Fix is to force a redraw on the column headers.
	*/
        ... doing the native stuff ...
}
We should fix that. We can use the same solution used in TabFolder to fix it.

To TableColumn add:
void setFontDescription (int font) {
	OS.gtk_widget_modify_font (labelHandle, font);
	OS.gtk_widget_modify_font (imageHandle, font);
}

To Table add: 
void setFontDescription (int font) {
	super.setFontDescription (font);
	TableColumn[] cloumns = getColumns ();
	for (int i = 0; i &lt; cloumns.length; i++) {
		if (cloumns[i] != null) {
			cloumns[i].setFontDescription (font);
		}
	}
}
and Table.createItem (TableColumn, int) add at end:
	column.setFontDescription (getFontDescription ());

Fixed &gt; 20030403 (HEAD)</WithStack>
    <WithOutStack>Assigning a new font to a Table sets the new font for the rows within the table,
but leaves the Table headers as they are. It DOES work under Win32, though.

I looked in the SWT source code (for Win32) for tables setFont() method, and
found the following ...
Maybe something similiar needs to be done for GTK, too ?

public void setFont (Font font) {
	checkWidget ();
	super.setFont (font);
	setScrollWidth ();
	/*
	* Bug in Windows.  Setting the font will cause the 
	* table area to be redrawn but not the column headers.
	* Fix is to force a redraw on the column headers.
	*/
        ... doing the native stuff ...
}
We should fix that. We can use the same solution used in TabFolder to fix it.

To TableColumn add:
void setFontDescription (int font) {
	OS.gtk_widget_modify_font (labelHandle, font);
	OS.gtk_widget_modify_font (imageHandle, font);
}

To Table add: 
void setFontDescription (int font) {
	super.setFontDescription (font);
	TableColumn[] cloumns = getColumns ();
	for (int i = 0; i &lt; cloumns.length; i++) {
		if (cloumns[i] != null) {
			cloumns[i].setFontDescription (font);
		}
	}
}
and Table.createItem (TableColumn, int) add at end:
	column.setFontDescription (getFontDescription ());

Fixed &gt; 20030403 (HEAD)</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35497" />
    <CreationDate amount="2003-03-21 12:51:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="Ant" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="All" />
    <priority amount="P2" />
    <bug_severity amount="normal" />
    <Summery>ArrayIndexOutOfBounds on external tools page</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="1">
      <Enumeration lines="15">
        <Lines>
          <Line>- create a simple Project</Line>
          <Line>- select it, right-click -&gt; Properties</Line>
          <Line>- go to the External Tools Builders page</Line>
          <Line>- press Copy, will bring up a dialog with an empty text and list</Line>
          <Line>- press OK and you'll get the attached exception</Line>
          <Line>Created attachment 4293</Line>
          <Line>exception</Line>
          <Line>Can only occur if you have no configurations defined in the workspace.</Line>
          <Line>Deferred to post 2.1</Line>
          <Line>Re-opening.</Line>
          <Line>Fixed in BuilderPropertyPage.</Line>
          <Line>Please verify DarinW.</Line>
          <Line>Possible 2.1.1 candidate.</Line>
          <Line>Verified. Approved for 2.1.1</Line>
          <Line>Released to the 2.1.1 stream.</Line>
        </Lines>
      </Enumeration>
    </Enumerations>
    <bug_status amount="VERIFIED" />
    <resolution amount="FIXED" />
    <WithStack>RC3a

- create a simple Project
- select it, right-click -&gt; Properties
- go to the External Tools Builders page
- press Copy, will bring up a dialog with an empty text and list
- press OK and you'll get the attached exception
Created attachment 4293
exception
Can only occur if you have no configurations defined in the workspace.
Deferred to post 2.1
Re-opening.
Fixed in BuilderPropertyPage.
Please verify DarinW.
Possible 2.1.1 candidate.
Verified. Approved for 2.1.1
Released to the 2.1.1 stream.</WithStack>
    <WithOutStack>RC3a

- create a simple Project
- select it, right-click -&gt; Properties
- go to the External Tools Builders page
- press Copy, will bring up a dialog with an empty text and list
- press OK and you'll get the attached exception
Created attachment 4293
exception
Can only occur if you have no configurations defined in the workspace.
Deferred to post 2.1
Re-opening.
Fixed in BuilderPropertyPage.
Please verify DarinW.
Possible 2.1.1 candidate.
Verified. Approved for 2.1.1
Released to the 2.1.1 stream.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35498" />
    <CreationDate amount="2003-03-21 13:05:00 -0500" />
    <DupId amount="38948" />
    <classification amount="Eclipse" />
    <Product amount="Platform" />
    <component amount="SWT" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Code generation pref. page does not layout well</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="2">
      <source_code type="assignment">
        <location start="454" end="521" />
        <code>int result= table.getItemHeight() * rows + table.getHeaderHeight();</code>
      </source_code>
      <source_code type="assignment">
        <location start="551" end="599" />
        <code>result+= table.getGridLineWidth() * (rows - 1);</code>
      </source_code>
    </SourceCodeRegions>
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="DUPLICATE" />
    <WithStack>RC3a - Linux/GTK
Red Hat 8.0

The Java-&gt;Code Generation preferences page has a bad layout on its "Names" tab.

I will attach a screenshot.
Created attachment 4294
screenshot
Same thing for:
Java -&gt; Appearance -&gt; Members Sort Order (shows only 5 items)
Java -&gt; Task Tags (shows only 3 items)

It is annoying having to scroll when there is a lot of unused space below the
widget.


We are using the following algorithm to compute the height of the widget

int result= table.getItemHeight() * rows + table.getHeaderHeight();
if (table.getLinesVisible())
	result+= table.getGridLineWidth() * (rows - 1);

The algorithm works well under Windows. Asking SWT for clarification. If it is 
an easy fix we should consider it for 2.1

Works well under Mtoif as well. 


*** This bug has been marked as a duplicate of 38948 ***</WithStack>
    <WithOutStack>RC3a - Linux/GTK
Red Hat 8.0

The Java-&gt;Code Generation preferences page has a bad layout on its "Names" tab.

I will attach a screenshot.
Created attachment 4294
screenshot
Same thing for:
Java -&gt; Appearance -&gt; Members Sort Order (shows only 5 items)
Java -&gt; Task Tags (shows only 3 items)

It is annoying having to scroll when there is a lot of unused space below the
widget.


We are using the following algorithm to compute the height of the widget

int result= table.getItemHeight() * rows + table.getHeaderHeight();
if (table.getLinesVisible())
	result+= table.getGridLineWidth() * (rows - 1);

The algorithm works well under Windows. Asking SWT for clarification. If it is 
an easy fix we should consider it for 2.1

Works well under Mtoif as well. 


*** This bug has been marked as a duplicate of 38948 ***</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35499" />
    <CreationDate amount="2003-03-21 13:05:00 -0500" />
    <DupId amount="" />
    <classification amount="Tools" />
    <Product amount="CDT" />
    <component amount="cdt-build" />
    <Version amount="2.0" />
    <rep_platform amount="PC" />
    <op_sys amount="Linux-GTK" />
    <priority amount="P3" />
    <bug_severity amount="normal" />
    <Summery>Build error reported with autotools based project</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="FIXED" />
    <WithStack>Hi!
I am using org.eclipse.cdt-200303100300-linux-gtk_1.0.1.bin.dist.zip with
eclipse-platform-RC3a-linux-gtk.zip.

(1)
I have an autotools base c++ project with release and version-numbering.
The following line reads inside the C-build view:

/bin/sh ../libtool --mode=link g++  -g -O2   -o libvcbasio_0_1.la -rpath
/home/nicolai/devel++/lib -version-info 1:0:1 -release 0:1:1 vcbasio.lo


It is interpreted as a build error and yields the following entry in the task-view:

Error			1 -release 0:1:1 vcbasio.lo tinystr.lo tinyxml.lo tinyxmlerror.lo
tinyxmlparser.lo[/bin/sh ../libtool --mode=link g++  -g -O2   -o
libvcbasio_0_1.la -rpath /home/nicolai/devel++/lib -version-info 1]	vcbasio		line 0


The same happens with other lines where the C-build output is s.th. like '...
a:b:c blabla ...' and results in a reported error of 'c blabla ...' which
suggestes a pattern.

(2)
Furthermore, when refreshing the c/c++ view, I get an error:
Problems occurred refreshing the selected resources.
  libvcbasio_0_1-0:1:1.so.0 is an invalid resource name.
  libvcbasio_0_1-0:1:1.so.0.1.0 is an invalid resource name.


Hope that helped.

Regards
Nick

ECLIPSE_IS_GREAT!!!
PR was targeted to the 2.0 release but not resolved, moving target to 2.1
The new error parsers in 3.1 fix this problem.</WithStack>
    <WithOutStack>Hi!
I am using org.eclipse.cdt-200303100300-linux-gtk_1.0.1.bin.dist.zip with
eclipse-platform-RC3a-linux-gtk.zip.

(1)
I have an autotools base c++ project with release and version-numbering.
The following line reads inside the C-build view:

/bin/sh ../libtool --mode=link g++  -g -O2   -o libvcbasio_0_1.la -rpath
/home/nicolai/devel++/lib -version-info 1:0:1 -release 0:1:1 vcbasio.lo


It is interpreted as a build error and yields the following entry in the task-view:

Error			1 -release 0:1:1 vcbasio.lo tinystr.lo tinyxml.lo tinyxmlerror.lo
tinyxmlparser.lo[/bin/sh ../libtool --mode=link g++  -g -O2   -o
libvcbasio_0_1.la -rpath /home/nicolai/devel++/lib -version-info 1]	vcbasio		line 0


The same happens with other lines where the C-build output is s.th. like '...
a:b:c blabla ...' and results in a reported error of 'c blabla ...' which
suggestes a pattern.

(2)
Furthermore, when refreshing the c/c++ view, I get an error:
Problems occurred refreshing the selected resources.
  libvcbasio_0_1-0:1:1.so.0 is an invalid resource name.
  libvcbasio_0_1-0:1:1.so.0.1.0 is an invalid resource name.


Hope that helped.

Regards
Nick

ECLIPSE_IS_GREAT!!!
PR was targeted to the 2.0 release but not resolved, moving target to 2.1
The new error parsers in 3.1 fix this problem.</WithOutStack>
  </Bug>
  <Bug>
    <BugId amount="35500" />
    <CreationDate amount="2003-03-21 13:15:00 -0500" />
    <DupId amount="" />
    <classification amount="Eclipse" />
    <Product amount="JDT" />
    <component amount="UI" />
    <Version amount="2.1" />
    <rep_platform amount="PC" />
    <op_sys amount="Windows XP" />
    <priority amount="P3" />
    <bug_severity amount="trivial" />
    <Summery>Add Constructors from Superclass: Unneccessary super()-call  in default constructor [code manipulation]</Summery>
    <Patches amount="0" />
    <Stacktraces amount="0" />
    <SourceCodeRegions amount="0" />
    <Enumerations amount="0" />
    <bug_status amount="RESOLVED" />
    <resolution amount="WONTFIX" />
    <WithStack>Add Constructors from Superclass inserts an unneccessary super()-call to the
default constructor.
No aciton planned for 2.1
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithStack>
    <WithOutStack>Add Constructors from Superclass inserts an unneccessary super()-call to the
default constructor.
No aciton planned for 2.1
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.</WithOutStack>
  </Bug>
</infozilla-output>

